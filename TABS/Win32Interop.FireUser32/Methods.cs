using System;
using System.Runtime.InteropServices;
using System.Text;
using Win32Interop.Enums;
using Win32Interop.Structs;

// ReSharper disable CheckNamespace

namespace Win32Interop.Methods
// ReSharper restore CheckNamespace
{
	// ReSharper disable InconsistentNaming

	/// <summary>
	///     <para>
	///         An application-defined callback function used with the <see cref="User32.EnumWindowStations" /> function. It receives a window station name.
	///     </para>
	///     <para>
	///         The <see cref="EnumWindowStationProc" /> type defines a pointer to this callback function. <see cref="EnumWindowStationProc" /> is a placeholder for
	///         the application-defined function name.
	///     </para>
	/// </summary>
	/// <param name="lpszWindowStation">The name of the window station.</param>
	/// <param name="lParam">
	///     An application-defined value specified in the <see cref="User32.EnumWindowStations" /> function.
	/// </param>
	/// <returns>To continue enumeration, the callback function must return TRUE. To stop enumeration, it must return FALSE.</returns>
	/// <remarks>
	///     An application must register this callback function by passing its address to <see cref="User32.EnumWindowStations" />.
	/// </remarks>
	[UnmanagedFunctionPointer(CallingConvention.StdCall)]
	public delegate int EnumWindowStationProc(StringBuilder lpszWindowStation, IntPtr lParam);

	/// <summary>Callback function that processes help events for the message box.</summary>
	/// <param name="lpHelpInfo">Identifies what help information to display to the user.</param>
	[UnmanagedFunctionPointer(CallingConvention.StdCall)]
	public delegate void MsgBoxCallback(ref HELPINFO lpHelpInfo);

	/// <summary>
	///     Application-defined callback function used with the CreateDialog and DialogBox families of functions. It processes messages sent to a modal or
	///     modeless dialog box. The <see cref="DialogProc" /> type defines a pointer to this callback function.
	///     <see cref="DialogProc" /> is a placeholder for the application-defined function name.
	/// </summary>
	/// <param name="hwndDlg">A handle to the dialog box.</param>
	/// <param name="uMsg">The message.</param>
	/// <param name="wParam">Additional message-specific information.</param>
	/// <param name="lParam">Additional message-specific information.</param>
	/// <returns>
	///     <para>
	///         Typically, the dialog box procedure should return TRUE if it processed the message, and FALSE if it did not. If the dialog box procedure
	///         returns FALSE, the dialog manager performs the default dialog operation in response to the message.
	///     </para>
	///     <para>
	///         If the dialog box procedure processes a message that requires a specific return value, the dialog box procedure should set the desired return
	///         value by calling <see cref="User32.SetWindowLong" />(hwndDlg, DWL_MSGRESULT, lResult) immediately before returning TRUE. Note that you must
	///         call <see cref="User32.SetWindowLong" /> immediately before returning TRUE; doing so earlier may result in the DWL_MSGRESULT value being
	///         overwritten by a nested dialog box message.
	///     </para>
	///     <para>
	///         The following messages are exceptions to the general rules stated above. Consult the documentation for the specific message for details on
	///         the semantics of the return value.
	///     </para>
	/// </returns>
	/// <remarks>
	///     You should use the dialog box procedure only if you use the dialog box class for the dialog box. This is the default class and is used when no
	///     explicit class is specified in the dialog box template. Although the dialog box procedure is similar to a window procedure, it must not call the
	///     <see cref="User32.DefWindowProc" /> function to process unwanted messages. Unwanted messages are processed internally by the dialog box window
	///     procedure.
	/// </remarks>
	[UnmanagedFunctionPointer(CallingConvention.StdCall)]
	public delegate int DialogProc(IntPtr hwndDlg, uint uMsg, IntPtr wParam, IntPtr lParam);

	/// <summary>
	///     An application-defined callback function used with the <see cref="User32.SendMessageCallback" /> function. The system passes the message to the
	///     callback function after passing the message to the destination window procedure. The <see cref="SendAsyncProc" /> type defines a pointer to this
	///     callback function. <see cref="SendAsyncProc" /> is a placeholder for the application-defined function name.
	/// </summary>
	/// <param name="hwnd">
	///     <para>A handle to the window whose window procedure received the message.</para>
	///     <para>
	///         If the <see cref="User32.SendMessageCallback" /> function was called with its <paramref name="hwnd" /> parameter set to HWND_BROADCAST, the
	///         system calls the <see cref="SendAsyncProc" /> function once for each top-level window.
	///     </para>
	/// </param>
	/// <param name="uMsg">The message.</param>
	/// <param name="dwData">
	///     An application-defined value sent from the <see cref="User32.SendMessageCallback" /> function.
	/// </param>
	/// <param name="lResult">The result of the message processing. This value depends on the message.</param>
	/// <returns>This callback function does not return a value.</returns>
	/// <remarks>
	///     <para>
	///         You install a <see cref="SendAsyncProc" /> application-defined callback function by passing a <see cref="SendAsyncProc" /> pointer to the
	///         <see cref="User32.SendMessageCallback" /> function.
	///     </para>
	///     <para>
	///         The callback function is only called when the thread that called <see cref="User32.SendMessageCallback" /> calls
	///         <see cref="User32.GetMessage" />,
	///         <see cref="User32.PeekMessage" />, or <see cref="User32.WaitMessage" />.
	///     </para>
	/// </remarks>
	[UnmanagedFunctionPointer(CallingConvention.StdCall)]
	public delegate void SendAsyncProc(IntPtr hwnd, uint uMsg, uint dwData, IntPtr lResult);

	/// <summary>
	///     <para>
	///         A <see cref="MonitorEnumProc" /> function is an application-defined callback function that is called by the
	///         <see cref="User32.EnumDisplayMonitors" /> function.
	///     </para>
	///     <para>
	///         A value of type <see cref="MonitorEnumProc" /> is a pointer to a <see cref="MonitorEnumProc" /> function.
	///     </para>
	/// </summary>
	/// <param name="hMonitor">A handle to the display monitor. This value will always be non-NULL.</param>
	/// <param name="hdcMonitor">
	///     <para>A handle to a device context.</para>
	///     <para>
	///         The device context has color attributes that are appropriate for the display monitor identified by <paramref name="hMonitor" />. The clipping
	///         area of the device context is set to the intersection of the visible region of the device context identified by the hdc parameter of
	///         <see cref="User32.EnumDisplayMonitors" />, the rectangle pointed to by the lprcClip parameter of
	///         <see cref="User32.EnumDisplayMonitors" />, and the display monitor rectangle.
	///     </para>
	///     <para>
	///         This value is NULL if the hdc parameter of <see cref="User32.EnumDisplayMonitors" /> was NULL.
	///     </para>
	/// </param>
	/// <param name="lprcMonitor">
	///     <para>
	///         A pointer to a <see cref="RECT" /> structure.
	///     </para>
	///     <para>
	///         If <paramref name="hdcMonitor" /> is non-NULL, this rectangle is the intersection of the clipping area of the device context identified by
	///         <paramref name="hdcMonitor" /> and the display monitor rectangle. The rectangle coordinates are device-context coordinates.
	///     </para>
	///     <para>
	///         If <paramref name="hdcMonitor" /> is NULL, this rectangle is the display monitor rectangle. The rectangle coordinates are virtual-screen
	///         coordinates.
	///     </para>
	/// </param>
	/// <param name="dwData">
	///     Application-defined data that <see cref="User32.EnumDisplayMonitors" /> passes directly to the enumeration function.
	/// </param>
	/// <returns>
	///     <para>To continue the enumeration, return TRUE.</para>
	///     <para>To stop the enumeration, return FALSE.</para>
	/// </returns>
	/// <remarks>
	///     <para>
	///         You can use the <see cref="User32.EnumDisplayMonitors" /> function to enumerate the set of display monitors that intersect the visible region
	///         of a specified device context and, optionally, a clipping rectangle. To do this, set the hdc parameter to a non-NULL value, and set the
	///         lprcClip parameter as needed.
	///     </para>
	///     <para>
	///         You can also use the <see cref="User32.EnumDisplayMonitors" /> function to enumerate one or more of the display monitors on the desktop,
	///         without supplying a device context. To do this, set the hdc parameter of <see cref="User32.EnumDisplayMonitors" /> to NULL and set the
	///         lprcClip parameter as needed.
	///     </para>
	///     <para>
	///         In all cases, <see cref="User32.EnumDisplayMonitors" /> calls a specified <see cref="MonitorEnumProc" /> function once for each display
	///         monitor in the calculated enumeration set. The <see cref="MonitorEnumProc" /> function always receives a handle to the display monitor.
	///     </para>
	///     <para>
	///         If the hdc parameter of <see cref="User32.EnumDisplayMonitors" /> is non-NULL, the <see cref="MonitorEnumProc" />
	///         function also receives a handle to a device context whose color format is appropriate for the display monitor. You can then paint into the
	///         device context in a manner that is optimal for the display monitor.
	///     </para>
	/// </remarks>
	[UnmanagedFunctionPointer(CallingConvention.StdCall)]
	public delegate int MonitorEnumProc(IntPtr hMonitor, IntPtr hdcMonitor, ref RECT lprcMonitor, IntPtr dwData);

	/// <summary>
	///     An application-defined callback function used with the <see cref="User32.EnumWindows" /> or <see cref="User32.EnumDesktopWindows" /> function. It
	///     receives top-level window handles. The <see cref="EnumWindowsProc" /> type defines a pointer to this callback function.
	///     <see cref="EnumWindowsProc" /> is a placeholder for the application-defined function name.
	/// </summary>
	/// <param name="hwnd">A handle to a top-level window.</param>
	/// <param name="lParam">
	///     The application-defined value given in <see cref="User32.EnumWindows" /> or <see cref="User32.EnumDesktopWindows" />.
	/// </param>
	/// <returns>To continue enumeration, the callback function must return TRUE; to stop enumeration, it must return FALSE.</returns>
	/// <remarks>
	///     An application must register this callback function by passing its address to <see cref="User32.EnumWindows" /> or
	///     <see cref="User32.EnumDesktopWindows" />.
	/// </remarks>
	[UnmanagedFunctionPointer(CallingConvention.StdCall)]
	public delegate int EnumWindowsProc(IntPtr hwnd, IntPtr lParam);

	/// <summary>
	///     <para>
	///         A hook is a mechanism by which an application can intercept events, such as messages, mouse actions, and keystrokes. A function that
	///         intercepts a particular type of event is known as a hook procedure. A hook procedure can act on each event it receives, and then modify or
	///         discard the event.
	///     </para>
	///     <para>The following some example uses for hooks:</para>
	/// </summary>
	[UnmanagedFunctionPointer(CallingConvention.StdCall)]
	public delegate IntPtr HOOKPROC(int code, IntPtr wParam, IntPtr lParam);

	/// <summary>
	///     <para>
	///         An application-defined callback (or hook) function that the system calls in response to events generated by an accessible object. The hook
	///         function processes the event notifications as required. Clients install the hook function and request specific types of event notifications
	///         by calling <see cref="User32.SetWinEventHook" />.
	///     </para>
	///     <para>
	///         The <see cref="WinEventProc" /> type defines a pointer to this callback function. <see cref="WinEventProc" /> is a placeholder for the
	///         application-defined function name.
	///     </para>
	/// </summary>
	/// <param name="hWinEventHook">
	///     Handle to an event hook function. This value is returned by <see cref="User32.SetWinEventHook" /> when the hook function is installed and is
	///     specific to each instance of the hook function.
	/// </param>
	/// <param name="event">Specifies the event that occurred. This value is one of the event constants.</param>
	/// <param name="hwnd">
	///     Handle to the window that generates the event, or NULL if no window is associated with the event. For example, the mouse pointer is not
	///     associated with a window.
	/// </param>
	/// <param name="idObject">Identifies the object associated with the event. This is one of the object identifiers or a custom object ID.</param>
	/// <param name="idChild">
	///     Identifies whether the event was triggered by an object or a child element of the object. If this value is CHILDID_SELF, the event was triggered
	///     by the object; otherwise, this value is the child ID of the element that triggered the event.
	/// </param>
	/// <param name="dwEventThread">Identifies the thread that generated the event, or the thread that owns the current window.</param>
	/// <param name="dwmsEventTime">Specifies the time, in milliseconds, that the event was generated.</param>
	/// <returns>This callback function does not return a value.</returns>
	/// <remarks>
	///     <para>
	///         Within the hook function, the parameters <paramref name="hwnd" />, <paramref name="idObject" />, and <paramref name="idChild" /> are used
	///         when calling AccessibleObjectFromEvent.
	///     </para>
	///     <para>
	///         Servers generate events by calling <see cref="User32.NotifyWinEvent" />.
	///     </para>
	///     <para>Create multiple callback functions to handle different events. For more information, see Registering a Hook Function.</para>
	/// </remarks>
	[UnmanagedFunctionPointer(CallingConvention.StdCall)]
	public delegate void WinEventProc(IntPtr hWinEventHook, uint @event, IntPtr hwnd, int idObject, int idChild, uint dwEventThread, uint dwmsEventTime);

	/// <summary>
	///     <para>
	///         An application-defined function that processes messages sent to a window. The <see cref="WindowProc" /> type defines a pointer to this callback
	///         function.
	///     </para>
	///     <para>
	///         <see cref="WindowProc" /> is a placeholder for the application-defined function name.
	///     </para>
	/// </summary>
	/// <param name="hwnd">A handle to the window.</param>
	/// <param name="uMsg">
	///     <para>The message.</para>
	///     <para>For lists of the system-provided messages, see System-Defined Messages.</para>
	/// </param>
	/// <param name="wParam">
	///     Additional message information. The contents of this parameter depend on the value of the <paramref name="uMsg" /> parameter.
	/// </param>
	/// <param name="lParam">
	///     Additional message information. The contents of this parameter depend on the value of the <paramref name="uMsg" /> parameter.
	/// </param>
	/// <returns>
	///     <para>The return value is the result of the message processing and depends on the message sent.</para>
	/// </returns>
	/// <remarks>
	///     <para>
	///         If your application runs on a 32-bit version of Windows operating system, uncaught exceptions from the callback will be passed onto
	///         higher-level exception handlers of your application when available. The system then calls the unhandled exception filter to handle the
	///         exception prior to terminating the process. If the PCA is enabled, it will offer to fix the problem the next time you run the application.
	///     </para>
	///     <para>
	///         However, if your application runs on a 64-bit version of Windows operating system or WOW64, you should be aware that a 64-bit operating
	///         system handles uncaught exceptions differently based on its 64-bit processor architecture, exception architecture, and calling convention.
	///         The following table summarizes all possible ways that a 64-bit Windows operating system or WOW64 handles uncaught exceptions.
	///     </para>
	/// </remarks>
	[UnmanagedFunctionPointer(CallingConvention.StdCall)]
	public delegate int WindowProc(IntPtr hwnd, uint uMsg, IntPtr wParam, IntPtr lParam);

	/// <summary>
	///     An application-defined callback function used with the Dynamic Data Exchange Management Library (DDEML) functions. It processes Dynamic Data
	///     Exchange (DDE) transactions. The PFNCALLBACK type defines a pointer to this callback function. <see cref="DdeCallback" /> is a
	///     placeholder for the application-defined function name.
	/// </summary>
	/// <param name="uType">
	///     <para>
	///         The type of the current transaction. This parameter consists of a combination of transaction class flags and transaction type flags. The
	///         following table describes each of the transaction classes and provides a list of the transaction types in each class. For information about a
	///         specific transaction type, see the individual description of that type.
	///     </para>
	///     <list type="table">
	///         <item>
	///             <term>XCLASS_BOOL</term>
	///             <description>
	///                 A DDE callback function should return TRUE or FALSE when it finishes processing a transaction that belongs to this class. The
	///                 XCLASS_BOOL transaction class consists of the following types:   XTYP_ADVSTART XTYP_CONNECT
	///             </description>
	///         </item>
	///         <item>
	///             <term>XCLASS_DATA</term>
	///             <description>
	///                 A DDE callback function should return a DDE handle, the CBR_BLOCK return code, or NULL when it finishes processing a transaction that
	///                 belongs to this class. The XCLASS_DATA transaction class consists of the following types:   XTYP_ADVREQ XTYP_REQUEST XTYP_WILDCONNECT
	///             </description>
	///         </item>
	///         <item>
	///             <term>XCLASS_FLAGS</term>
	///             <description>
	///                 A DDE callback function should return DDE_FACK, DDE_FBUSY, or DDE_FNOTPROCESSED when it finishes processing a transaction that
	///                 belongs to this class. The XCLASS_FLAGS transaction class consists of the following types:   XTYP_ADVDATA XTYP_EXECUTE XTYP_POKE
	///             </description>
	///         </item>
	///         <item>
	///             <term>XCLASS_NOTIFICATION</term>
	///             <description>
	///                 The transaction types that belong to this class are for notification purposes only. The return value from the callback function is
	///                 ignored. The XCLASS_NOTIFICATION transaction class consists of the following types:   XTYP_ADVSTOP XTYP_CONNECT_CONFIRM
	///                 XTYP_DISCONNECT XTYP_ERROR XTYP_MONITOR XTYP_REGISTER XTYP_XACT_COMPLETE XTYP_UNREGISTER
	///             </description>
	///         </item>
	///     </list>
	/// </param>
	/// <param name="uFmt">The format in which data is sent or received.</param>
	/// <param name="hconv">A handle to the conversation associated with the current transaction.</param>
	/// <param name="hsz1">
	///     A handle to a string. The meaning of this parameter depends on the type of the current transaction. For the meaning of this parameter, see the
	///     description of the transaction type.
	/// </param>
	/// <param name="hsz2">
	///     A handle to a string. The meaning of this parameter depends on the type of the current transaction. For the meaning of this parameter, see the
	///     description of the transaction type.
	/// </param>
	/// <param name="hdata">
	///     A handle to DDE data. The meaning of this parameter depends on the type of the current transaction. For the meaning of this parameter, see the
	///     description of the transaction type.
	/// </param>
	/// <param name="dwData1">Transaction-specific data. For the meaning of this parameter, see the description of the transaction type.</param>
	/// <param name="dwData2">Transaction-specific data. For the meaning of this parameter, see the description of the transaction type.</param>
	/// <returns>
	///     The return value depends on the transaction class. For more information about the return values, see descriptions of the individual transaction
	///     types.
	/// </returns>
	/// <remarks>
	///     <para>
	///         The callback function is called asynchronously for transactions that do not involve the creation or termination of conversations. An
	///         application that does not frequently accept incoming messages will have reduced DDE performance because the Dynamic Data Exchange Management
	///         Library (DDEML) uses messages to initiate transactions.
	///     </para>
	///     <para>
	///         An application must register the callback function by specifying a pointer to the function in a call to the
	///         <see cref="User32.DdeInitialize" />
	///         function.
	///     </para>
	/// </remarks>
	[UnmanagedFunctionPointer(CallingConvention.StdCall)]
	public delegate IntPtr DdeCallback(uint uType, uint uFmt, IntPtr hconv, IntPtr hsz1, IntPtr hsz2, IntPtr hdata, uint dwData1, uint dwData2);

	/// <summary>
	///     Application-defined callback function used with the <see cref="User32.EnumPropsEx" /> function. The function receives property entries from a window's
	///     property list. The PROPENUMPROCEX type defines a pointer to this callback function. <see cref="PropEnumProcEx" /> is a placeholder for the
	///     application-defined function name.
	/// </summary>
	/// <param name="hwnd">A handle to the window whose property list is being enumerated.</param>
	/// <param name="lpszString">
	///     The string component of a property list entry. This is the string that was specified, along with a data handle, when the property was added to
	///     the window's property list via a call to the <see cref="User32.SetProp" /> function.
	/// </param>
	/// <param name="hData">A handle to the data. This handle is the data component of a property list entry.</param>
	/// <param name="dwData">
	///     Application-defined data. This is the value that was specified as the lParam parameter of the call to
	///     <see cref="User32.EnumPropsEx" /> that initiated the enumeration.
	/// </param>
	/// <returns>
	///     <para>Return TRUE to continue the property list enumeration.</para>
	///     <para>Return FALSE to stop the property list enumeration.</para>
	/// </returns>
	/// <remarks>The following restrictions apply to this callback function:</remarks>
	[UnmanagedFunctionPointer(CallingConvention.StdCall)]
	public delegate int PropEnumProcEx(IntPtr hwnd, StringBuilder lpszString, IntPtr hData, uint dwData);

	/// <summary>
	///     The <see cref="OutputProc" /> function is an application-defined callback function used with the <see cref="User32.GrayString" /> function. It is
	///     used to draw a string. The <see cref="OutputProc" /> type defines a pointer to this callback function. <see cref="OutputProc" /> is a placeholder
	///     for the application-defined or library-defined function name.
	/// </summary>
	/// <param name="hdc">
	///     A handle to a device context with a bitmap of at least the width and height specified by the nWidth and nHeight parameters passed to
	///     <see cref="User32.GrayString" />.
	/// </param>
	/// <param name="lpData">A pointer to the string to be drawn.</param>
	/// <param name="cchData">The length, in characters, of the string.</param>
	/// <returns>
	///     <para>If it succeeds, the callback function should return TRUE.</para>
	///     <para>If the function fails, the return value is FALSE.</para>
	/// </returns>
	/// <remarks>The callback function must draw an image relative to the coordinates (0,0).</remarks>
	[UnmanagedFunctionPointer(CallingConvention.StdCall)]
	public delegate int OutputProc(IntPtr hdc, IntPtr lpData, int cchData);

	/// <summary>
	///     An application-defined callback function used with the <see cref="User32.EnumProps" /> function. The function receives property entries from a window's
	///     property list. The <see cref="PropEnumProc" /> type defines a pointer to this callback function. <see cref="PropEnumProc" /> is a
	///     placeholder for the application-defined function name.
	/// </summary>
	/// <param name="hwnd">A handle to the window whose property list is being enumerated.</param>
	/// <param name="lpszString">
	///     The string component of a property list entry. This is the string that was specified, along with a data handle, when the property was added to
	///     the window's property list via a call to the <see cref="User32.SetProp" /> function.
	/// </param>
	/// <param name="hData">A handle to the data. This handle is the data component of a property list entry.</param>
	/// <returns>
	///     <para>Return TRUE to continue the property list enumeration.</para>
	///     <para>Return FALSE to stop the property list enumeration.</para>
	/// </returns>
	/// <remarks>The following restrictions apply to this callback function:</remarks>
	[UnmanagedFunctionPointer(CallingConvention.StdCall)]
	public delegate int PropEnumProc(IntPtr hwnd, [In] string lpszString, IntPtr hData);

	/// <summary>
	///     The <see cref="DrawStateProc" /> function is an application-defined callback function that renders a complex image for the
	///     <see cref="User32.DrawState" /> function. The <see cref="DrawStateProc" /> type defines a pointer to this callback function.
	///     <see cref="DrawStateProc" /> is a placeholder for the application-defined function name.
	/// </summary>
	/// <param name="hdc">
	///     A handle to the device context to draw in. The device context is a memory device context with a bitmap selected, the dimensions of which are at
	///     least as great as those specified by the <paramref name="cx" /> and <paramref name="cy" /> parameters.
	/// </param>
	/// <param name="lData">
	///     Specifies information about the image, which the application passed to <see cref="User32.DrawState" />.
	/// </param>
	/// <param name="wData">
	///     Specifies information about the image, which the application passed to <see cref="User32.DrawState" />.
	/// </param>
	/// <param name="cx">
	///     The image width, in device units, as specified by the call to <see cref="User32.DrawState" />.
	/// </param>
	/// <param name="cy">
	///     The image height, in device units, as specified by the call to <see cref="User32.DrawState" />.
	/// </param>
	/// <returns>
	///     <para>If the function succeeds, the return value is TRUE.</para>
	///     <para>If the function fails, the return value is FALSE.</para>
	/// </returns>
	[UnmanagedFunctionPointer(CallingConvention.StdCall)]
	public delegate int DrawStateProc(IntPtr hdc, IntPtr lData, IntPtr wData, int cx, int cy);

	/// <summary>
	///     An application-defined callback function that processes <see cref="WM.WM_TIMER" /> messages. The <see cref="TimerProc" /> type defines a pointer
	///     to this callback function. <see cref="TimerProc" /> is a placeholder for the application-defined function name.
	/// </summary>
	/// <param name="hwnd">A handle to the window associated with the timer.</param>
	/// <param name="uMsg">
	///     The <see cref="WM.WM_TIMER" /> message.
	/// </param>
	/// <param name="idEvent">The timer's identifier.</param>
	/// <param name="dwTime">
	///     The number of milliseconds that have elapsed since the system was started. This is the value returned by the GetTickCount
	///     function.
	/// </param>
	/// <returns>This function does not return a value.</returns>
	[UnmanagedFunctionPointer(CallingConvention.StdCall)]
	public delegate void TimerProc(IntPtr hwnd, uint uMsg, IntPtr idEvent, uint dwTime);

	/// <summary>
	/// Collection of native methods in user32.dll.
	/// </summary>
	public class User32
	{
		/// <summary>
		///     Disables the window ghosting feature for the calling GUI process. Window ghosting is a Windows Manager feature that lets the user minimize, move,
		///     or close the main window of an application that is not responding.
		/// </summary>
		/// <returns>This function does not return a value.</returns>
		/// <remarks>
		///     After calling <see cref="DisableProcessWindowsGhosting" />, the ghosting feature is disabled for the duration of the process.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DisableProcessWindowsGhosting")]
		public static extern void DisableProcessWindowsGhosting();

		/// <summary>Closes the specified device notification handle.</summary>
		/// <param name="Handle">
		///     Device notification handle returned by the <see cref="RegisterDeviceNotification" /> function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "UnregisterDeviceNotification")]
		public static extern bool UnregisterDeviceNotification([In] IntPtr Handle);

		/// <summary>Retrieves the information about the raw input devices for the current application.</summary>
		/// <param name="pRawInputDevices">
		///     An array of <see cref="RAWINPUTDEVICE" /> structures for the application.
		/// </param>
		/// <param name="puiNumDevices">
		///     The number of <see cref="RAWINPUTDEVICE" /> structures in *<paramref name="pRawInputDevices" />.
		/// </param>
		/// <param name="cbSize">
		///     The size, in bytes, of a <see cref="RAWINPUTDEVICE" /> structure.
		/// </param>
		/// <returns>
		///     <para>
		///         If successful, the function returns a non-negative number that is the number of <see cref="RAWINPUTDEVICE" /> structures written to the
		///         buffer.
		///     </para>
		///     <para>
		///         If the <paramref name="pRawInputDevices" /> buffer is too small or NULL, the function sets the last error as ERROR_INSUFFICIENT_BUFFER,
		///         returns -1, and sets <paramref name="puiNumDevices" /> to the required number of devices. If the function fails for any other reason, it
		///         returns -1. For more details, call GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     To receive raw input from a device, an application must register it by using <see cref="RegisterRawInputDevices" />.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetRegisteredRawInputDevices")]
		public static extern uint GetRegisteredRawInputDevices(ref RAWINPUTDEVICE[] pRawInputDevices, ref uint puiNumDevices, uint cbSize);

		/// <summary>Registers the device or type of device for which a window will receive notifications.</summary>
		/// <param name="hRecipient">
		///     <para>
		///         A handle to the window or service that will receive device events for the devices specified in the <paramref name="NotificationFilter" />
		///         parameter. The same window handle can be used in multiple calls to <see cref="RegisterDeviceNotification" />.
		///     </para>
		///     <para>Services can specify either a window handle or service status handle.</para>
		/// </param>
		/// <param name="NotificationFilter">
		///     A pointer to a block of data that specifies the type of device for which notifications should be sent. This block always begins with the
		///     <see cref="DEV_BROADCAST_HDR" /> structure. The data following this header is dependent on the value of the <see cref="DEV_BROADCAST_HDR.dbch_devicetype" />
		///     member, which can be <see cref="DBT.DBT_DEVTYP_DEVICEINTERFACE" /> or <see cref="DBT.DBT_DEVTYP_HANDLE" />. For more information, see Remarks.
		/// </param>
		/// <param name="Flags">
		///     <para>This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>DEVICE_NOTIFY_WINDOW_HANDLE 0x00000000</term>
		///             <description>
		///                 The <paramref name="hRecipient" /> parameter is a window handle.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DEVICE_NOTIFY_SERVICE_HANDLE 0x00000001</term>
		///             <description>
		///                 The <paramref name="hRecipient" /> parameter is a service status handle.
		///             </description>
		///         </item>
		///     </list>
		///     <para>In addition, you can specify the following value.</para>
		///     <list type="table">
		///         <item>
		///             <term>DEVICE_NOTIFY_ALL_INTERFACE_CLASSES 0x00000004</term>
		///             <description>
		///                 <para>
		///                     Notifies the recipient of device interface events for all device interface classes. (The dbcc_classguid member is
		///                     ignored.)
		///                 </para>
		///                 <para>
		///                     This value can be used only if the <see cref="DEV_BROADCAST_HDR.dbch_devicetype" /> member is <see cref="DBT.DBT_DEVTYP_DEVICEINTERFACE" />.
		///                 </para>
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a device notification handle.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Applications send event notifications using the <see cref="BroadcastSystemMessage" /> function. Any application with a top-level window can
		///         receive basic notifications by processing the <see cref="WM.WM_DEVICECHANGE" /> message. Applications can use the
		///         <see cref="RegisterDeviceNotification" /> function to register to receive device notifications.
		///     </para>
		///     <para>
		///         Services can use the <see cref="RegisterDeviceNotification" /> function to register to receive device notifications. If a service specifies a
		///         window handle in the <paramref name="hRecipient" /> parameter, the notifications are sent to the window procedure. If
		///         <paramref name="hRecipient" /> is a service status handle, SERVICE_CONTROL_DEVICEEVENT notifications are sent to the service
		///         control handler. For more information about the service control handler, see HandlerEx.
		///     </para>
		///     <para>
		///         Be sure to handle Plug and Play device events as quickly as possible. Otherwise, the system may become unresponsive. If your event handler is
		///         to perform an operation that may block execution (such as I/O), it is best to start another thread to perform the operation asynchronously.
		///     </para>
		///     <para>
		///         Device notification handles returned by <see cref="RegisterDeviceNotification" /> must be closed by calling the
		///         <see cref="UnregisterDeviceNotification" /> function when they are no longer needed.
		///     </para>
		///     <para>
		///         The <see cref="DBT.DBT_DEVICEARRIVAL" /> and <see cref="DBT.DBT_DEVICEREMOVECOMPLETE" /> events are automatically broadcast to all top-level windows
		///         for port devices. Therefore, it is not necessary to call <see cref="RegisterDeviceNotification" /> for ports, and the function fails if the
		///         <see cref="DEV_BROADCAST_HDR.dbch_devicetype" /> member is <see cref="DBT.DBT_DEVTYP_PORT" />. Volume notifications are also broadcast to top-level windows, so the
		///         function fails if <see cref="DEV_BROADCAST_HDR.dbch_devicetype" /> is <see cref="DBT.DBT_DEVTYP_VOLUME" />. OEM-defined devices are not used directly by the
		///         system, so the function fails if <see cref="DEV_BROADCAST_HDR.dbch_devicetype" /> is <see cref="DBT.DBT_DEVTYP_OEM" />.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "RegisterDeviceNotification")]
		public static extern IntPtr RegisterDeviceNotification([In] IntPtr hRecipient, [In] IntPtr NotificationFilter, DEVICE_NOTIFY Flags);

		/// <summary>
		///     Waits until one or all of the specified objects are in the signaled state, an I/O completion routine or asynchronous procedure call (APC) is
		///     queued to the thread, or the time-out interval elapses. The array of objects can include input event objects, which you specify using the
		///     <paramref name="dwWakeMask" /> parameter.
		/// </summary>
		/// <param name="nCount">
		///     The number of object handles in the array pointed to by <paramref name="pHandles" />. The maximum number of object handles is
		///     MAXIMUM_WAIT_OBJECTS minus one.
		/// </param>
		/// <param name="pHandles">
		///     <para>
		///         An array of object handles. For a list of the object types whose handles you can specify, see the Remarks section later in this topic. The
		///         array can contain handles to multiple types of objects. It may not contain multiple copies of the same handle.
		///     </para>
		///     <para>If one of these handles is closed while the wait is still pending, the function's behavior is undefined.</para>
		///     <para>The handles must have the SYNCHRONIZE access right. For more information, see Standard Access Rights.</para>
		/// </param>
		/// <param name="dwMilliseconds">
		///     The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are signaled, an I/O
		///     completion routine or APC is queued, or the interval elapses. If <paramref name="dwMilliseconds" /> is zero, the function does not enter a wait
		///     state if the criteria is not met; it always returns immediately. If <paramref name="dwMilliseconds" /> is INFINITE, the function will return only
		///     when the specified objects are signaled or an I/O completion routine or APC is queued.
		/// </param>
		/// <param name="dwWakeMask">
		///     <para>
		///         The input types for which an input event object handle will be added to the array of object handles. This parameter can be one or more of the
		///         following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>QS_ALLEVENTS 0x04BF</term>
		///             <description>
		///                 <para>
		///                     An input, <see cref="WM.WM_TIMER" />, <see cref="WM.WM_PAINT" />, <see cref="WM.WM_HOTKEY" />, or posted message is in the queue.
		///                 </para>
		///                 <para>
		///                     This value is a combination of <see cref="QS.QS_INPUT" />, <see cref="QS.QS_POSTMESSAGE" />, <see cref="QS.QS_TIMER" />,
		///                     <see cref="QS.QS_PAINT" />, and <see cref="QS.QS_HOTKEY" />.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_ALLINPUT 0x04FF</term>
		///             <description>
		///                 <para>Any message is in the queue.</para>
		///                 <para>
		///                     This value is a combination of <see cref="QS.QS_INPUT" />, <see cref="QS.QS_POSTMESSAGE" />, <see cref="QS.QS_TIMER" />,
		///                     <see cref="QS.QS_PAINT" />, <see cref="QS.QS_HOTKEY" />, and <see cref="QS.QS_SENDMESSAGE" />.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_ALLPOSTMESSAGE 0x0100</term>
		///             <description>
		///                 <para>A posted message is in the queue.</para>
		///                 <para>
		///                     This value is cleared when you call <see cref="GetMessage" /> or <see cref="PeekMessage" /> without filtering messages.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_HOTKEY 0x0080</term>
		///             <description>
		///                 A <see cref="WM.WM_HOTKEY" /> message is in the queue.
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_INPUT 0x407</term>
		///             <description>
		///                 <para>An input message is in the queue.</para>
		///                 <para>
		///                     This value is a combination of <see cref="QS.QS_MOUSE" />, <see cref="QS.QS_KEY" />, and <see cref="QS.QS_RAWINPUT" />.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_KEY 0x0001</term>
		///             <description>
		///                 A <see cref="WM.WM_KEYUP" />, <see cref="WM.WM_KEYDOWN" />, <see cref="WM.WM_SYSKEYUP" />, or <see cref="WM.WM_SYSKEYDOWN" /> message
		///                 is in the queue.
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_MOUSE 0x0006</term>
		///             <description>
		///                 <para>
		///                     A <see cref="WM.WM_MOUSEMOVE" /> message or mouse-button message (<see cref="WM.WM_LBUTTONUP" />,
		///                     <see cref="WM.WM_RBUTTONDOWN" />, and so on).
		///                 </para>
		///                 <para>
		///                     This value is a combination of <see cref="QS.QS_MOUSEMOVE" /> and <see cref="QS.QS_MOUSEBUTTON" />.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_MOUSEBUTTON 0x0004</term>
		///             <description>
		///                 A mouse-button message (<see cref="WM.WM_LBUTTONUP" />, <see cref="WM.WM_RBUTTONDOWN" />, and so on).
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_MOUSEMOVE 0x0002</term>
		///             <description>
		///                 A <see cref="WM.WM_MOUSEMOVE" /> message is in the queue.
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_PAINT 0x0020</term>
		///             <description>
		///                 A <see cref="WM.WM_PAINT" /> message is in the queue.
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_POSTMESSAGE 0x0008</term>
		///             <description>
		///                 <para>A posted message is in the queue.</para>
		///                 <para>
		///                     This value is cleared when you call <see cref="GetMessage" /> or <see cref="PeekMessage" />, whether or not you are filtering
		///                     messages.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_RAWINPUT 0x0400</term>
		///             <description>A raw input message is in the queue. For more information, see Raw Input.</description>
		///         </item>
		///         <item>
		///             <term>QS_SENDMESSAGE 0x0040</term>
		///             <description>A message sent by another thread or application is in the queue.</description>
		///         </item>
		///         <item>
		///             <term>QS_TIMER 0x0010</term>
		///             <description>
		///                 A <see cref="WM.WM_TIMER" /> message is in the queue.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="dwFlags">
		///     <para>The wait type. This parameter can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>0</term>
		///             <description>
		///                 The function returns when any one of the objects is signaled. The return value indicates the object whose state caused the
		///                 function to return.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MWMO_ALERTABLE 0x0002</term>
		///             <description>
		///                 The function also returns if an APC has been queued to the thread with QueueUserAPC while the thread is in the waiting
		///                 state.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MWMO_INPUTAVAILABLE 0x0004</term>
		///             <description>
		///                 The function returns if input exists for the queue, even if the input has been seen (but not removed) using a call to another
		///                 function, such as <see cref="PeekMessage" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MWMO_WAITALL 0x0001</term>
		///             <description>
		///                 The function returns when all objects in the <paramref name="pHandles" /> array are signaled and an input event has been received,
		///                 all at the same time.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values. (Note
		///     that WAIT_OBJECT_0 is defined as 0 and WAIT_ABANDONED_0 is defined as 0x00000080L.)
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="MsgWaitForMultipleObjectsEx" /> function determines whether the conditions specified by <paramref name="dwWakeMask" /> and
		///         <paramref name="dwFlags" /> have been met. If the conditions have not been met, the calling thread enters the wait state until the conditions
		///         of the wait criteria have been met or the time-out interval elapses.
		///     </para>
		///     <para>
		///         When <paramref name="dwFlags" /> is zero, this function checks the handles in the array in order starting with index 0, until one of the
		///         objects is signaled. If multiple objects become signaled, the function returns the index of the first handle in the array whose object was
		///         signaled.
		///     </para>
		///     <para>
		///         <see cref="MsgWaitForMultipleObjectsEx" /> does not return if there is unread input of the specified type in the message queue after the
		///         thread has called a function to check the queue, unless you use the <see cref="MWMO.MWMO_INPUTAVAILABLE" /> flag. This is because functions
		///         such as <see cref="PeekMessage" />, <see cref="GetMessage" />, <see cref="GetQueueStatus" />, and <see cref="WaitMessage" /> check the queue
		///         and then change the state information for the queue so that the input is no longer considered new. A subsequent call to
		///         <see cref="MsgWaitForMultipleObjectsEx" /> will not return until new input of the specified type arrives, unless you use the
		///         <see cref="MWMO.MWMO_INPUTAVAILABLE" /> flag. If this flag is not used, the existing unread input (received prior to the last time the thread
		///         checked the queue) is ignored.
		///     </para>
		///     <para>
		///         The function modifies the state of some types of synchronization objects. Modification occurs only for the object or objects whose signaled
		///         state caused the function to return. For example, the system decreases the count of a semaphore object by one. For more information, see the
		///         documentation for the individual synchronization objects.
		///     </para>
		///     <para>
		///         The <see cref="MsgWaitForMultipleObjectsEx" /> function can specify handles of any of the following object types in the
		///         <paramref name="pHandles" /> array:
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "MsgWaitForMultipleObjectsEx")]
		public static extern uint MsgWaitForMultipleObjectsEx(uint nCount, ref IntPtr pHandles, uint dwMilliseconds, QS dwWakeMask, MWMO dwFlags);

		/// <summary>Searches through icon or cursor data for the icon or cursor that best fits the current display device.</summary>
		/// <param name="presbits">
		///     The icon or cursor directory data. Because this function does not validate the resource data, it causes a general protection (GP) fault or
		///     returns an undefined value if <paramref name="presbits" /> is not pointing to valid resource data.
		/// </param>
		/// <param name="fIcon">
		///     Indicates whether an icon or a cursor is sought. If this parameter is TRUE, the function is searching for an icon; if the parameter is FALSE, the
		///     function is searching for a cursor.
		/// </param>
		/// <param name="cxDesired">
		///     The desired width, in pixels, of the icon. If this parameter is zero, the function uses the <see cref="SM.SM_CXICON" /> or
		///     <see cref="SM.SM_CXCURSOR" /> system metric value.
		/// </param>
		/// <param name="cyDesired">
		///     The desired height, in pixels, of the icon. If this parameter is zero, the function uses the <see cref="SM.SM_CYICON" /> or
		///     <see cref="SM.SM_CYCURSOR" /> system metric value.
		/// </param>
		/// <param name="Flags">
		///     <para>A combination of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>LR_DEFAULTCOLOR 0x00000000</term>
		///             <description>Uses the default color format.</description>
		///         </item>
		///         <item>
		///             <term>LR_MONOCHROME 0x00000001</term>
		///             <description>Creates a monochrome icon or cursor.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is an integer resource identifier for the icon or cursor that best fits the current display
		///         device.
		///     </para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         A resource file of type RT_GROUP_ICON (RT_GROUP_CURSOR indicates cursors) contains icon (or cursor) data in
		///         several device-dependent and device-independent formats. <see cref="LookupIconIdFromDirectoryEx" /> searches the resource file for the icon
		///         (or cursor) that best fits the current display device and returns its integer identifier. The FindResource and
		///         FindResourceEx functions use the MAKEINTRESOURCE macro with this identifier to locate the resource in the module.
		///     </para>
		///     <para>
		///         The icon directory is loaded from a resource file with resource type RT_GROUP_ICON (or RT_GROUP_CURSOR for
		///         cursors), and an integer resource name for the specific icon to be loaded. <see cref="LookupIconIdFromDirectoryEx" /> returns an integer
		///         identifier that is the resource name of the icon that best fits the current display device.
		///     </para>
		///     <para>
		///         The <see cref="LoadIcon" />, <see cref="LoadImage" />, and <see cref="LoadCursor" /> functions use this function to search the specified
		///         resource data for the icon or cursor that best fits the current display device.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "LookupIconIdFromDirectoryEx")]
		public static extern int LookupIconIdFromDirectoryEx(
			[In] ref byte presbits, [MarshalAs(UnmanagedType.Bool)] bool fIcon, int cxDesired, int cyDesired, LR Flags);

		/// <summary>Sets the opacity and transparency color key of a layered window.</summary>
		/// <param name="hwnd">
		///     <para>
		///         A handle to the layered window. A layered window is created by specifying <see cref="WS_EX.WS_EX_LAYERED" /> when creating the window with the
		///         <see cref="CreateWindowEx" /> function or by setting <see cref="WS_EX.WS_EX_LAYERED" /> via <see cref="SetWindowLong" /> after the window has been
		///         created.
		///     </para>
		/// </param>
		/// <param name="crKey">
		///     A <see cref="COLORREF" /> structure that specifies the transparency color key to be used when composing the layered window. All pixels painted by
		///     the window in this color will be transparent. To generate a <see cref="COLORREF" />, use the RGB macro.
		/// </param>
		/// <param name="bAlpha">
		///     Alpha value used to describe the opacity of the layered window. Similar to the <see cref="BLENDFUNCTION.SourceConstantAlpha" /> member of the
		///     <see cref="BLENDFUNCTION" /> structure. When <paramref name="bAlpha" /> is 0, the window is completely transparent. When
		///     <paramref name="bAlpha" /> is 255, the window is opaque.
		/// </param>
		/// <param name="dwFlags">
		///     <para>An action to be taken. This parameter can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>LWA_ALPHA 0x00000002</term>
		///             <description>
		///                 Use <paramref name="bAlpha" /> to determine the opacity of the layered window.
		///             </description>
		///         </item>
		///         <item>
		///             <term>LWA_COLORKEY 0x00000001</term>
		///             <description>
		///                 Use <paramref name="crKey" /> as the transparency color.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Note that once <see cref="SetLayeredWindowAttributes" /> has been called for a layered window, subsequent <see cref="UpdateLayeredWindow" />
		///         calls will fail until the layering style bit is cleared and set again.
		///     </para>
		///     <para>For more information, see Using Layered Windows.</para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetLayeredWindowAttributes")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool SetLayeredWindowAttributes([In] IntPtr hwnd, uint crKey, byte bAlpha, LWA dwFlags);

		/// <summary>Determines whether the clipboard contains data in the specified format.</summary>
		/// <param name="format">A standard or registered clipboard format. For a description of the standard clipboard formats, see Standard Clipboard Formats .</param>
		/// <returns>
		///     <para>If the clipboard format is available, the return value is nonzero.</para>
		///     <para>If the clipboard format is not available, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     Typically, an application that recognizes only one clipboard format would call this function when processing the <see cref="WM.WM_INITMENU" /> or
		///     <see cref="WM.WM_INITMENUPOPUP" /> message. The application would then enable or disable the Paste menu item, depending on the return value.
		///     Applications that recognize more than one clipboard format should use the <see cref="GetPriorityClipboardFormat" /> function for this purpose.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "IsClipboardFormatAvailable")]
		public static extern bool IsClipboardFormatAvailable(uint format);

		/// <summary>
		///     Enables a Dynamic Data Exchange (DDE) server application to impersonate a DDE client application's security context. This protects secure server
		///     data from unauthorized DDE clients.
		/// </summary>
		/// <param name="hWndClient">
		///     A handle to the DDE client window to be impersonated. The client window must have established a DDE conversation with the server window
		///     identified by the <paramref name="hWndServer" /> parameter.
		/// </param>
		/// <param name="hWndServer">A handle to the DDE server window. An application must create the server window before calling this function.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         An application should call the RevertToSelf function to undo the impersonation set by the
		///         <see cref="ImpersonateDdeClientWindow" /> function.
		///     </para>
		///     <para>
		///         A DDEML application should use the <see cref="DdeImpersonateClient" /> function.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "ImpersonateDdeClientWindow")]
		public static extern bool ImpersonateDdeClientWindow(IntPtr hWndClient, IntPtr hWndServer);

		/// <summary>Retrieves the first available clipboard format in the specified list.</summary>
		/// <param name="paFormatPriorityList">
		///     The clipboard formats, in priority order. For a description of the standard clipboard formats, see Standard
		///     Clipboard Formats .
		/// </param>
		/// <param name="cFormats">
		///     The number of entries in the <paramref name="paFormatPriorityList" /> array. This value must not be greater than the number of entries in the
		///     list.
		/// </param>
		/// <returns>
		///     If the function succeeds, the return value is the first clipboard format in the list for which data is available. If the clipboard is empty, the
		///     return value is NULL. If the clipboard contains data, but not in any of the specified formats, the return value is –1. To get extended error
		///     information, call GetLastError.
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetPriorityClipboardFormat")]
		public static extern int GetPriorityClipboardFormat(
			[MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.U4, SizeParamIndex = 1)] uint[] paFormatPriorityList, int cFormats);

		/// <summary>
		///     <para>
		///         Retrieves the dimensions of the default check-mark bitmap. The system displays this bitmap next to selected menu items. Before calling the
		///         <see cref="SetMenuItemBitmaps" /> function to replace the default check-mark bitmap for a menu item, an application must determine the
		///         correct bitmap size by calling <see cref="GetMenuCheckMarkDimensions" />.
		///     </para>
		///     <para>
		///         Note:  The <see cref="GetMenuCheckMarkDimensions" /> function is included only for compatibility with 16-bit versions of Windows.
		///         Applications should use the <see cref="GetSystemMetrics" /> function with the <see cref="SM.SM_CXMENUCHECK" /> and
		///         <see cref="SM.SM_CYMENUCHECK" /> values to retrieve the bitmap dimensions.
		///     </para>
		/// </summary>
		/// <returns>
		///     The return value specifies the height and width, in pixels, of the default check-mark bitmap. The high-order word contains the height; the
		///     low-order word contains the width.
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetMenuCheckMarkDimensions")]
		public static extern int GetMenuCheckMarkDimensions();

		/// <summary>Retrieves the opacity and transparency color key of a layered window.</summary>
		/// <param name="hwnd">
		///     A handle to the layered window. A layered window is created by specifying <see cref="WS_EX.WS_EX_LAYERED" /> when creating the window with the
		///     <see cref="CreateWindowEx" /> function or by setting <see cref="WS_EX.WS_EX_LAYERED" /> using <see cref="SetWindowLong" /> after the window has been
		///     created.
		/// </param>
		/// <param name="pcrKey">
		///     A pointer to a <see cref="COLORREF" /> value that receives the transparency color key to be used when composing the layered window. All pixels
		///     painted by the window in this color will be transparent. This can be NULL if the argument is not needed.
		/// </param>
		/// <param name="pbAlpha">
		///     The Alpha value used to describe the opacity of the layered window. Similar to the <see cref="BLENDFUNCTION.SourceConstantAlpha" /> member of the
		///     <see cref="BLENDFUNCTION" /> structure. When the variable referred to by <paramref name="pbAlpha" /> is 0, the window is completely transparent.
		///     When the variable referred to by <paramref name="pbAlpha" /> is 255, the window is opaque. This can be NULL if the argument is not needed.
		/// </param>
		/// <param name="pdwFlags">
		///     <para>A layering flag. This parameter can be NULL if the value is not needed. The layering flag can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>LWA_ALPHA 0x00000002</term>
		///             <description>
		///                 Use <paramref name="pbAlpha" /> to determine the opacity of the layered window.
		///             </description>
		///         </item>
		///         <item>
		///             <term>LWA_COLORKEY 0x00000001</term>
		///             <description>
		///                 Use <paramref name="pcrKey" /> as the transparency color.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         <see cref="GetLayeredWindowAttributes" /> can be called only if the application has previously called
		///         <see cref="SetLayeredWindowAttributes" /> on the window. The function will fail if the layered window was setup with
		///         <see cref="UpdateLayeredWindow" />.
		///     </para>
		///     <para>For more information, see Using Layered Windows.</para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetLayeredWindowAttributes")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool GetLayeredWindowAttributes([In] IntPtr hwnd, ref COLORREF pcrKey, IntPtr pbAlpha, out LWA pdwFlags);

		/// <summary>Retrieves the clipboard sequence number for the current window station.</summary>
		/// <returns>
		///     The return value is the clipboard sequence number. If you do not have WINSTA_ACCESSCLIPBOARD access to the window station, the function returns
		///     zero.
		/// </returns>
		/// <remarks>
		///     The system keeps a serial number for the clipboard for each window station. This number is incremented whenever the contents of the clipboard
		///     change or the clipboard is emptied. You can track this value to determine whether the clipboard contents have changed and optimize creating
		///     DataObjects. If clipboard rendering is delayed, the sequence number is not incremented until the changes are rendered.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetClipboardSequenceNumber")]
		public static extern uint GetClipboardSequenceNumber();

		/// <summary>
		///     Creates a modeless dialog box from a dialog box template in memory. Before displaying the dialog box, the function passes an application-defined
		///     value to the dialog box procedure as the lParam parameter of the <see cref="WM.WM_INITDIALOG" /> message. An application can use this value to
		///     initialize dialog box controls.
		/// </summary>
		/// <param name="hInstance">A handle to the module that will create the dialog box.</param>
		/// <param name="lpTemplate">
		///     <para>
		///         The template <see cref="CreateDialogIndirectParam" /> uses to create the dialog box. A dialog box template consists of a header that
		///         describes the dialog box, followed by one or more additional blocks of data that describe each of the controls in the dialog box. The
		///         template can use either the standard format or the extended format.
		///     </para>
		///     <para>
		///         In a standard template, the header is a <see cref="DLGTEMPLATE" /> structure followed by additional variable-length arrays. The data for each
		///         control consists of a <see cref="DLGITEMTEMPLATE" /> structure followed by additional variable-length arrays.
		///     </para>
		///     <para>
		///         In an extended dialog box template, the header uses the <see cref="DLGTEMPLATEEX" /> format and the control definitions use the
		///         <see cref="DLGITEMTEMPLATEEX" /> format.
		///     </para>
		///     <para>
		///         After <see cref="CreateDialogIndirectParam" /> returns, you can free the template, which is only used to get the dialog box started.
		///     </para>
		/// </param>
		/// <param name="hWndParent">A handle to the window that owns the dialog box.</param>
		/// <param name="lpDialogFunc">
		///     A pointer to the dialog box procedure. For more information about the dialog box procedure, see <see cref="DialogProc" />.
		/// </param>
		/// <param name="lParamInit">
		///     The value to pass to the dialog box in the lParam parameter of the <see cref="WM.WM_INITDIALOG" /> message.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the window handle to the dialog box.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="CreateDialogIndirectParam" /> function uses the <see cref="CreateWindowEx" /> function to create the dialog box.
		///         <see cref="CreateDialogIndirectParam" /> then sends a <see cref="WM.WM_INITDIALOG" /> message to the dialog box procedure. If the template
		///         specifies the DS_SETFONT or DS_SHELLFONT style, the function also sends a <see cref="WM.WM_SETFONT" /> message to the dialog
		///         box procedure. The function displays the dialog box if the template specifies the <see cref="WS.WS_VISIBLE" /> style. Finally,
		///         <see cref="CreateDialogIndirectParam" /> returns the window handle to the dialog box.
		///     </para>
		///     <para>
		///         After <see cref="CreateDialogIndirectParam" /> returns, you can use the <see cref="ShowWindow" /> function to display the dialog box (if it
		///         is not already visible). To destroy the dialog box, use the <see cref="DestroyWindow" /> function. To support keyboard navigation and other
		///         dialog box functionality, the message loop for the dialog box must call the <see cref="IsDialogMessage" /> function.
		///     </para>
		///     <para>
		///         In a standard dialog box template, the <see cref="DLGTEMPLATE" /> structure and each of the <see cref="DLGITEMTEMPLATE" /> structures must be
		///         aligned on DWORD boundaries. The creation data array that follows a <see cref="DLGITEMTEMPLATE" /> structure must also be aligned on a DWORD
		///         boundary. All of the other variable-length arrays in the template must be aligned on WORD
		///         boundaries.
		///     </para>
		///     <para>
		///         In an extended dialog box template, the <see cref="DLGTEMPLATEEX" /> header and each of the <see cref="DLGITEMTEMPLATEEX" /> control
		///         definitions must be aligned on DWORD boundaries. The creation data array, if any, that follows a
		///         <see cref="DLGITEMTEMPLATEEX" /> structure must also be aligned on a DWORD boundary. All of the other variable-length arrays in the template
		///         must be aligned on WORD boundaries.
		///     </para>
		///     <para>All character strings in the dialog box template, such as titles for the dialog box and buttons, must be Unicode strings.</para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CreateDialogIndirectParam")]
		public static extern IntPtr CreateDialogIndirectParam(
			[In] IntPtr hInstance, [In] ref DLGTEMPLATE lpTemplate, [In] IntPtr hWndParent, DialogProc lpDialogFunc, [MarshalAs(UnmanagedType.SysInt)] int lParamInit);

		/// <summary>Sets information about the specified window station or desktop object.</summary>
		/// <param name="hObj">
		///     A handle to the window station or desktop object. This handle can be returned by the <see cref="CreateWindowStation" />,
		///     <see cref="OpenWindowStation" />, <see cref="CreateDesktop" />, or <see cref="OpenDesktop" /> function.
		/// </param>
		/// <param name="nIndex">
		///     <para>The object information to be set. This parameter can be the following value.</para>
		///     <list type="table">
		///         <item>
		///             <term>UOI_FLAGS 1</term>
		///             <description>
		///                 Sets the object's handle flags. The <paramref name="pvInfo" /> parameter must point to a <see cref="USEROBJECTFLAGS" /> structure.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="pvInfo">A pointer to a buffer containing the object information.</param>
		/// <param name="nLength">
		///     The size of the information contained in the buffer pointed to by <paramref name="pvInfo" />, in bytes.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetUserObjectInformation")]
		public static extern bool SetUserObjectInformation([In] IntPtr hObj, int nIndex, [In] IntPtr pvInfo, uint nLength);

		/// <summary>
		///     <para>
		///         Waits until one or all of the specified objects are in the signaled state or the time-out interval elapses. The objects can include input
		///         event objects, which you specify using the <paramref name="dwWakeMask" /> parameter.
		///     </para>
		///     <para>
		///         To enter an alertable wait state, use the <see cref="MsgWaitForMultipleObjectsEx" /> function.
		///     </para>
		/// </summary>
		/// <param name="nCount">
		///     The number of object handles in the array pointed to by <paramref name="pHandles" />. The maximum number of object handles is
		///     MAXIMUM_WAIT_OBJECTS minus one.
		/// </param>
		/// <param name="pHandles">
		///     <para>
		///         An array of object handles. For a list of the object types whose handles can be specified, see the following Remarks section. The array can
		///         contain handles of objects of different types. It may not contain multiple copies of the same handle.
		///     </para>
		///     <para>If one of these handles is closed while the wait is still pending, the function's behavior is undefined.</para>
		///     <para>
		///         The handles must have the SYNCHRONIZE access right. For more information, see Standard Access Rights.
		///     </para>
		/// </param>
		/// <param name="bWaitAll">
		///     If this parameter is TRUE, the function returns when the states of all objects in the <paramref name="pHandles" /> array have been set to
		///     signaled and an input event has been received. If this parameter is FALSE, the function returns when the state of any one of the objects is set
		///     to signaled or an input event has been received. In this case, the return value indicates the object whose state caused the function to return.
		/// </param>
		/// <param name="dwMilliseconds">
		///     The time-out interval, in milliseconds. If a nonzero value is specified, the function waits until the specified objects are signaled or the
		///     interval elapses. If <paramref name="dwMilliseconds" /> is zero, the function does not enter a wait state if the specified objects are not
		///     signaled; it always returns immediately. If <paramref name="dwMilliseconds" /> is INFINITE, the function will return only when the specified
		///     objects are signaled.
		/// </param>
		/// <param name="dwWakeMask">
		///     <para>
		///         The input types for which an input event object handle will be added to the array of object handles. This parameter can be any combination of
		///         the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>QS_ALLEVENTS 0x04BF</term>
		///             <description>
		///                 <para>
		///                     An input, <see cref="WM.WM_TIMER" />, <see cref="WM.WM_PAINT" />, <see cref="WM.WM_HOTKEY" />, or posted message is in the queue.
		///                 </para>
		///                 <para>
		///                     This value is a combination of <see cref="QS.QS_INPUT" />, <see cref="QS.QS_POSTMESSAGE" />, <see cref="QS.QS_TIMER" />,
		///                     <see cref="QS.QS_PAINT" />, and <see cref="QS.QS_HOTKEY" />.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_ALLINPUT 0x04FF</term>
		///             <description>
		///                 <para>Any message is in the queue.</para>
		///                 <para>
		///                     This value is a combination of <see cref="QS.QS_INPUT" />, <see cref="QS.QS_POSTMESSAGE" />, <see cref="QS.QS_TIMER" />,
		///                     <see cref="QS.QS_PAINT" />, <see cref="QS.QS_HOTKEY" />, and <see cref="QS.QS_SENDMESSAGE" />.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_ALLPOSTMESSAGE 0x0100</term>
		///             <description>
		///                 <para>A posted message is in the queue.</para>
		///                 <para>
		///                     This value is cleared when you call <see cref="GetMessage" /> or <see cref="PeekMessage" /> without filtering messages.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_HOTKEY 0x0080</term>
		///             <description>
		///                 A <see cref="WM.WM_HOTKEY" /> message is in the queue.
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_INPUT 0x407</term>
		///             <description>
		///                 <para>An input message is in the queue.</para>
		///                 <para>
		///                     This value is a combination of <see cref="QS.QS_MOUSE" />, <see cref="QS.QS_KEY" />, and <see cref="QS.QS_RAWINPUT" />.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_KEY 0x0001</term>
		///             <description>
		///                 A <see cref="WM.WM_KEYUP" />, <see cref="WM.WM_KEYDOWN" />, <see cref="WM.WM_SYSKEYUP" />, or <see cref="WM.WM_SYSKEYDOWN" /> message
		///                 is in the queue.
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_MOUSE 0x0006</term>
		///             <description>
		///                 <para>
		///                     A <see cref="WM.WM_MOUSEMOVE" /> message or mouse-button message (<see cref="WM.WM_LBUTTONUP" />,
		///                     <see cref="WM.WM_RBUTTONDOWN" />, and so on).
		///                 </para>
		///                 <para>
		///                     This value is a combination of <see cref="QS.QS_MOUSEMOVE" /> and <see cref="QS.QS_MOUSEBUTTON" />.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_MOUSEBUTTON 0x0004</term>
		///             <description>
		///                 A mouse-button message (<see cref="WM.WM_LBUTTONUP" />, <see cref="WM.WM_RBUTTONDOWN" />, and so on).
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_MOUSEMOVE 0x0002</term>
		///             <description>
		///                 A <see cref="WM.WM_MOUSEMOVE" /> message is in the queue.
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_PAINT 0x0020</term>
		///             <description>
		///                 A <see cref="WM.WM_PAINT" /> message is in the queue.
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_POSTMESSAGE 0x0008</term>
		///             <description>
		///                 <para>A posted message is in the queue.</para>
		///                 <para>
		///                     This value is cleared when you call <see cref="GetMessage" /> or <see cref="PeekMessage" />, whether or not you are filtering
		///                     messages.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_RAWINPUT 0x0400</term>
		///             <description>A raw input message is in the queue. For more information, see Raw Input.</description>
		///         </item>
		///         <item>
		///             <term>QS_SENDMESSAGE 0x0040</term>
		///             <description>A message sent by another thread or application is in the queue.</description>
		///         </item>
		///         <item>
		///             <term>QS_TIMER 0x0010</term>
		///             <description>
		///                 A <see cref="WM.WM_TIMER" /> message is in the queue.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     If the function succeeds, the return value indicates the event that caused the function to return. It can be one of the following values. (Note
		///     that WAIT_OBJECT_0 is defined as 0 and WAIT_ABANDONED_0 is defined as 0x00000080L.)
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="MsgWaitForMultipleObjects" /> function determines whether the wait criteria have been met. If the criteria have not been met,
		///         the calling thread enters the wait state until the conditions of the wait criteria have been met or the time-out interval elapses.
		///     </para>
		///     <para>
		///         When <paramref name="bWaitAll" /> is TRUE, the function does not modify the states of the specified objects until the states of all objects
		///         have been set to signaled. For example, a mutex can be signaled, but the thread does not get ownership until the states of the other objects
		///         have also been set to signaled. In the meantime, some other thread may get ownership of the mutex, thereby setting its state to nonsignaled.
		///     </para>
		///     <para>
		///         When <paramref name="bWaitAll" /> is TRUE, the function's wait is completed only when the states of all objects have been set to signaled and
		///         an input event has been received. Therefore, setting <paramref name="bWaitAll" /> to TRUE prevents input from being processed until the state
		///         of all objects in the <paramref name="pHandles" /> array have been set to signaled. For this reason, if you set <paramref name="bWaitAll" />
		///         to TRUE, you should use a short timeout value in <paramref name="dwMilliseconds" />. If you have a thread that creates windows waiting for
		///         all objects in the <paramref name="pHandles" /> array, including input events specified by <paramref name="dwWakeMask" />, with no timeout
		///         interval, the system will deadlock. This is because threads that create windows must process messages. DDE sends message to all windows in
		///         the system. Therefore, if a thread creates windows, do not set the <paramref name="bWaitAll" /> parameter to TRUE in calls to
		///         <see cref="MsgWaitForMultipleObjects" /> made from that thread.
		///     </para>
		///     <para>
		///         When <paramref name="bWaitAll" /> is FALSE, this function checks the handles in the array in order starting with index 0, until one of the
		///         objects is signaled. If multiple objects become signaled, the function returns the index of the first handle in the array whose object was
		///         signaled.
		///     </para>
		///     <para>
		///         <see cref="MsgWaitForMultipleObjects" /> does not return if there is unread input of the specified type in the message queue after the thread
		///         has called a function to check the queue. This is because functions such as <see cref="PeekMessage" />, <see cref="GetMessage" />,
		///         <see cref="GetQueueStatus" />, and <see cref="WaitMessage" /> check the queue and then change the state information for the queue so that the
		///         input is no longer considered new. A subsequent call to <see cref="MsgWaitForMultipleObjects" /> will not return until new input of the
		///         specified type arrives. The existing unread input (received prior to the last time the thread checked the queue) is ignored.
		///     </para>
		///     <para>
		///         The function modifies the state of some types of synchronization objects. Modification occurs only for the object or objects whose signaled
		///         state caused the function to return. For example, the count of a semaphore object is decreased by one. For more information, see the
		///         documentation for the individual synchronization objects.
		///     </para>
		///     <para>
		///         The <see cref="MsgWaitForMultipleObjects" /> function can specify handles of any of the following object types in the
		///         <paramref name="pHandles" /> array:
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "MsgWaitForMultipleObjects")]
		public static extern uint MsgWaitForMultipleObjects(
			uint nCount, ref IntPtr pHandles, [MarshalAs(UnmanagedType.Bool)] bool bWaitAll, uint dwMilliseconds, uint dwWakeMask);

		/// <summary>
		///     <para>Searches through icon or cursor data for the icon or cursor that best fits the current display device.</para>
		///     <para>
		///         To specify a desired height or width, use the <see cref="LookupIconIdFromDirectoryEx" /> function.
		///     </para>
		/// </summary>
		/// <param name="presbits">
		///     The icon or cursor directory data. Because this function does not validate the resource data, it causes a general protection (GP) fault or
		///     returns an undefined value if <paramref name="presbits" /> is not pointing to valid resource data.
		/// </param>
		/// <param name="fIcon">
		///     Indicates whether an icon or a cursor is sought. If this parameter is TRUE, the function is searching for an icon; if the parameter is FALSE, the
		///     function is searching for a cursor.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is an integer resource identifier for the icon or cursor that best fits the current display
		///         device.
		///     </para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         A resource file of type RT_GROUP_ICON (RT_GROUP_CURSOR indicates cursors) contains icon (or cursor) data in
		///         several device-dependent and device-independent formats. <see cref="LookupIconIdFromDirectory" /> searches the resource file for the icon (or
		///         cursor) that best fits the current display device and returns its integer identifier. The FindResource and
		///         FindResourceEx functions use the MAKEINTRESOURCE macro with this identifier to locate the resource in the module.
		///     </para>
		///     <para>
		///         The icon directory is loaded from a resource file with resource type RT_GROUP_ICON (or RT_GROUP_CURSOR for
		///         cursors), and an integer resource name for the specific icon to be loaded. <see cref="LookupIconIdFromDirectory" /> returns an integer
		///         identifier that is the resource name of the icon that best fits the current display device.
		///     </para>
		///     <para>
		///         The <see cref="LoadIcon" />, <see cref="LoadCursor" />, and <see cref="LoadImage" /> functions use this function to search the specified
		///         resource data for the icon or cursor that best fits the current display device.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "LookupIconIdFromDirectory")]
		public static extern int LookupIconIdFromDirectory([In] ref byte presbits, [MarshalAs(UnmanagedType.Bool)] bool fIcon);

		/// <summary>Retrieves information about the specified window station or desktop object.</summary>
		/// <param name="hObj">
		///     A handle to the window station or desktop object. This handle is returned by the <see cref="CreateWindowStation" />,
		///     <see cref="OpenWindowStation" />, <see cref="CreateDesktop" />, or <see cref="OpenDesktop" /> function.
		/// </param>
		/// <param name="nIndex">
		///     <para>The information to be retrieved. The parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>UOI_FLAGS 1</term>
		///             <description>
		///                 The handle flags. The <paramref name="pvInfo" /> parameter must point to a <see cref="USEROBJECTFLAGS" /> structure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>UOI_HEAPSIZE 5</term>
		///             <description>
		///                 <para>
		///                     The size of the desktop heap, in KB, as a ULONG value. The <paramref name="hObj" /> parameter must be a handle to a desktop
		///                     object, otherwise, the function fails.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>UOI_IO 6</term>
		///             <description>
		///                 <para>
		///                     TRUE if the <paramref name="hObj" /> parameter is a handle to the desktop object that is receiving input from the user. FALSE
		///                     otherwise.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>UOI_NAME 2</term>
		///             <description>The name of the object, as a string.</description>
		///         </item>
		///         <item>
		///             <term>UOI_TYPE 3</term>
		///             <description>The type name of the object, as a string.</description>
		///         </item>
		///         <item>
		///             <term>UOI_USER_SID 4</term>
		///             <description>
		///                 The SID structure that identifies the user that is currently associated with the specified object. If no user is
		///                 associated with the object, the value returned in the buffer pointed to by <paramref name="lpnLengthNeeded" /> is zero. Note that
		///                 SID is a variable length structure. You will usually make a call to <see cref="GetUserObjectInformation" /> to
		///                 determine the length of the SID before retrieving its value.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="pvInfo">A pointer to a buffer to receive the object information.</param>
		/// <param name="nLength">
		///     The size of the buffer pointed to by the <paramref name="pvInfo" /> parameter, in bytes.
		/// </param>
		/// <param name="lpnLengthNeeded">
		///     A pointer to a variable receiving the number of bytes required to store the requested information. If this variable's value is greater than the
		///     value of the <paramref name="nLength" /> parameter when the function returns, the function returns FALSE, and none of the information is copied
		///     to the <paramref name="pvInfo" /> buffer. If the value of the variable pointed to by <paramref name="lpnLengthNeeded" /> is less than or equal to
		///     the value of <paramref name="nLength" />, the entire information block is copied.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetUserObjectInformation")]
		public static extern bool GetUserObjectInformation([In] IntPtr hObj, int nIndex, IntPtr pvInfo, uint nLength, IntPtr lpnLengthNeeded);

		/// <summary>
		///     <para>[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]</para>
		///     <para>Unregisters a specified Shell window that is registered to receive Shell hook messages.</para>
		/// </summary>
		/// <param name="hWnd">
		///     A handle to the window to be unregistered. The window was registered with a call to the <see cref="RegisterShellHookWindow" /> function.
		/// </param>
		/// <returns>
		///     <para>TRUE if the function succeeds; FALSE if the function fails.</para>
		/// </returns>
		/// <remarks>
		///     This function was not included in the SDK headers and libraries until Windows XP with Service Pack 1 (SP1) and Windows Server 2003. If you do not
		///     have a header file and import library for this function, you can call the function using LoadLibrary and
		///     GetProcAddress.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DeregisterShellHookWindow")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool DeregisterShellHookWindow([In] IntPtr hWnd);

		/// <summary>
		///     <para>
		///         Sends a message to the specified recipients. The recipients can be applications, installable drivers, network drivers, system-level device
		///         drivers, or any combination of these system components.
		///     </para>
		///     <para>
		///         This function is similar to <see cref="BroadcastSystemMessage" /> except that this function can return more information from the recipients.
		///     </para>
		/// </summary>
		/// <param name="dwFlags">
		///     <para>The broadcast option. This parameter can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>BSF_ALLOWSFW 0x00000080</term>
		///             <description>Enables the recipient to set the foreground window while processing the message.</description>
		///         </item>
		///         <item>
		///             <term>BSF_FLUSHDISK 0x00000004</term>
		///             <description>Flushes the disk after each recipient processes the message.</description>
		///         </item>
		///         <item>
		///             <term>BSF_FORCEIFHUNG 0x00000020</term>
		///             <description>Continues to broadcast the message, even if the time-out period elapses or one of the recipients is not responding.</description>
		///         </item>
		///         <item>
		///             <term>BSF_IGNORECURRENTTASK 0x00000002</term>
		///             <description>
		///                 Does not send the message to windows that belong to the current task. This prevents an application from receiving its own
		///                 message.
		///             </description>
		///         </item>
		///         <item>
		///             <term>BSF_LUID 0x00000400</term>
		///             <description>
		///                 <para>
		///                     If <see cref="BSF.BSF_LUID" /> is set, the message is sent to the window that has the same LUID as specified in the
		///                     <see cref="BSMINFO.luid" /> member of the <see cref="BSMINFO" /> structure.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>BSF_NOHANG 0x00000008</term>
		///             <description>
		///                 Forces a nonresponsive application to time out. If one of the recipients times out, do not continue broadcasting the
		///                 message.
		///             </description>
		///         </item>
		///         <item>
		///             <term>BSF_NOTIMEOUTIFNOTHUNG 0x00000040</term>
		///             <description>Waits for a response to the message, as long as the recipient is not being unresponsive. Does not time out.</description>
		///         </item>
		///         <item>
		///             <term>BSF_POSTMESSAGE 0x00000010</term>
		///             <description>
		///                 Posts the message. Do not use in combination with <see cref="BSF.BSF_QUERY" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>BSF_RETURNHDESK 0x00000200</term>
		///             <description>
		///                 <para>
		///                     If access is denied and both this and <see cref="BSF.BSF_QUERY" /> are set, <see cref="BSMINFO" /> returns both the desktop handle
		///                     and the window handle. If access is denied and only <see cref="BSF.BSF_QUERY" /> is set, only the window handle is returned by
		///                     <see cref="BSMINFO" />.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>BSF_QUERY 0x00000001</term>
		///             <description>Sends the message to one recipient at a time, sending to a subsequent recipient only if the current recipient returns TRUE.</description>
		///         </item>
		///         <item>
		///             <term>BSF_SENDNOTIFYMESSAGE 0x00000100</term>
		///             <description>
		///                 Sends the message using <see cref="SendNotifyMessage" /> function. Do not use in combination with <see cref="BSF.BSF_QUERY" />.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="lpdwRecipients">
		///     <para>A pointer to a variable that contains and receives information about the recipients of the message.</para>
		///     <para>When the function returns, this variable receives a combination of these values identifying which recipients actually received the message.</para>
		///     <para>If this parameter is NULL, the function broadcasts to all components.</para>
		///     <para>This parameter can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>BSM_ALLCOMPONENTS 0x00000000</term>
		///             <description>Broadcast to all system components.</description>
		///         </item>
		///         <item>
		///             <term>BSM_ALLDESKTOPS 0x00000010</term>
		///             <description>
		///                 Broadcast to all desktops. Requires the SE_TCB_NAME privilege.
		///             </description>
		///         </item>
		///         <item>
		///             <term>BSM_APPLICATIONS 0x00000008</term>
		///             <description>Broadcast to applications.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="uiMessage">
		///     <para>The message to be sent.</para>
		///     <para>For lists of the system-provided messages, see System-Defined Messages.</para>
		/// </param>
		/// <param name="wParam">Additional message-specific information.</param>
		/// <param name="lParam">Additional message-specific information.</param>
		/// <param name="pBSMInfo">
		///     A pointer to a <see cref="BSMINFO" /> structure that contains additional information if the request is denied and <paramref name="dwFlags" /> is
		///     set to <see cref="BSF.BSF_QUERY" />.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a positive value.</para>
		///     <para>If the function is unable to broadcast the message, the return value is –1.</para>
		///     <para>
		///         If the <paramref name="dwFlags" /> parameter is <see cref="BSF.BSF_QUERY" /> and at least one recipient returned
		///         BROADCAST_QUERY_DENY to the corresponding message, the return value is zero. To get extended error information, call
		///         GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If <see cref="BSF.BSF_QUERY" /> is not specified, the function sends the specified message to all requested recipients, ignoring values returned
		///         by those recipients.
		///     </para>
		///     <para>
		///         If the caller's thread is on a desktop other than that of the window that denied the request, the caller must call
		///         <see cref="SetThreadDesktop" />(hdesk) to query anything on that window. Also, the caller must call
		///         <see cref="CloseDesktop" /> on the returned hdesk handle.
		///     </para>
		///     <para>
		///         The system only does marshalling for system messages (those in the range 0 to (<see cref="WM.WM_USER" />-1)). To send other messages (those
		///         >=
		///         <see cref="WM.WM_USER" />) to another process, you must do custom marshalling.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "BroadcastSystemMessageEx")]
		public static extern int BroadcastSystemMessageEx(
			BSF dwFlags, IntPtr lpdwRecipients, uint uiMessage, [MarshalAs(UnmanagedType.SysUInt)] uint wParam, [MarshalAs(UnmanagedType.SysInt)] int lParam, ref BSMINFO pBSMInfo);

		/// <summary>Registers a new clipboard format. This format can then be used as a valid clipboard format.</summary>
		/// <param name="lpszFormat">The name of the new format.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value identifies the registered clipboard format.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If a registered format with the specified name already exists, a new format is not registered and the return value identifies the existing
		///         format. This enables more than one application to copy and paste data using the same registered clipboard format. Note that the format name
		///         comparison is case-insensitive.
		///     </para>
		///     <para>Registered clipboard formats are identified by values in the range 0xC000 through 0xFFFF.</para>
		///     <para>
		///         When registered clipboard formats are placed on or retrieved from the clipboard, they must be in the form of an HGLOBAL value.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "RegisterClipboardFormat")]
		public static extern uint RegisterClipboardFormat([In] string lpszFormat);

		/// <summary>
		///     Retrieves a handle to the child window at the specified point. The search is restricted to immediate child windows; grandchildren and deeper
		///     descendant windows are not searched.
		/// </summary>
		/// <param name="hwndParent">A handle to the window whose child is to be retrieved.</param>
		/// <param name="ptParentClientCoords">
		///     A <see cref="POINT" /> structure that defines the client coordinates of the point to be checked.
		/// </param>
		/// <returns>
		///     <para>The return value is a handle to the child window that contains the specified point.</para>
		/// </returns>
		/// <remarks>
		///     <see cref="RealChildWindowFromPoint" /> treats HTTRANSPARENT areas of a standard control differently from other areas of the
		///     control; it returns the child window behind a transparent part of a control. In contrast, <see cref="ChildWindowFromPoint" /> treats
		///     HTTRANSPARENT areas of a control the same as other areas. For example, if the point is in a transparent area of a groupbox,
		///     <see cref="RealChildWindowFromPoint" /> returns the child window behind a groupbox, whereas <see cref="ChildWindowFromPoint" /> returns the
		///     groupbox. However, both APIs return a static field, even though it, too, returns HTTRANSPARENT.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "RealChildWindowFromPoint")]
		public static extern IntPtr RealChildWindowFromPoint([In] IntPtr hwndParent, POINT ptParentClientCoords);

		/// <summary>
		///     Retrieves the identifier of the thread that created the specified window and, optionally, the identifier of the process that created the
		///     window.
		/// </summary>
		/// <param name="hWnd">A handle to the window.</param>
		/// <param name="lpdwProcessId">
		///     A pointer to a variable that receives the process identifier. If this parameter is not NULL, <see cref="GetWindowThreadProcessId" /> copies the
		///     identifier of the process to the variable; otherwise, it does not.
		/// </param>
		/// <returns>
		///     <para>The return value is the identifier of the thread that created the window.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetWindowThreadProcessId")]
		public static extern uint GetWindowThreadProcessId([In] IntPtr hWnd, IntPtr lpdwProcessId);

		/// <summary>Retrieves the full path and file name of the module associated with the specified window handle.</summary>
		/// <param name="hwnd">A handle to the window whose module file name is to be retrieved.</param>
		/// <param name="lpszFileName">The path and file name.</param>
		/// <param name="cchFileNameMax">
		///     The maximum number of characters that can be copied into the <paramref name="lpszFileName" /> buffer.
		/// </param>
		/// <returns>
		///     <para>The return value is the total number of characters copied into the buffer.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetWindowModuleFileName")]
		public static extern uint GetWindowModuleFileName(
			[In] IntPtr hwnd, [Out] StringBuilder lpszFileName, uint cchFileNameMax);

		/// <summary>Creates an icon or cursor from resource bits describing the icon.</summary>
		/// <param name="pbIconBits">
		///     The icon or cursor resource bits. These bits are typically loaded by calls to the <see cref="LookupIconIdFromDirectoryEx" /> and LoadResource
		///     functions.
		/// </param>
		/// <param name="cbIconBits">
		///     The size, in bytes, of the set of bits pointed to by the <paramref name="pbIconBits" /> parameter.
		/// </param>
		/// <param name="fIcon">
		///     Indicates whether an icon or a cursor is to be created. If this parameter is TRUE, an icon is to be created. If it is FALSE, a cursor is to be
		///     created.
		/// </param>
		/// <param name="dwVersion">
		///     The version number of the icon or cursor format for the resource bits pointed to by the <paramref name="pbIconBits" /> parameter. The value must
		///     be greater than or equal to 0x00020000 and less than or equal to 0x00030000. This parameter is generally set to 0x00030000.
		/// </param>
		/// <param name="cxDesired">
		///     The desired width, in pixels, of the icon or cursor. If this parameter is zero, the function uses the <see cref="SM.SM_CXICON" /> or
		///     <see cref="SM.SM_CXCURSOR" /> system metric value to set the width.
		/// </param>
		/// <param name="cyDesired">
		///     The desired height, in pixels, of the icon or cursor. If this parameter is zero, the function uses the <see cref="SM.SM_CYICON" /> or
		///     <see cref="SM.SM_CYCURSOR" /> system metric value to set the height.
		/// </param>
		/// <param name="uFlags">
		///     <para>A combination of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>LR_DEFAULTCOLOR 0x00000000</term>
		///             <description>Uses the default color format.</description>
		///         </item>
		///         <item>
		///             <term>LR_DEFAULTSIZE 0x00000040</term>
		///             <description>
		///                 Uses the width or height specified by the system metric values for cursors or icons, if the <paramref name="cxDesired" /> or
		///                 <paramref name="cyDesired" /> values are set to zero. If this flag is not specified and <paramref name="cxDesired" /> and
		///                 <paramref name="cyDesired" /> are set to zero, the function uses the actual resource size. If the resource contains multiple images,
		///                 the function uses the size of the first image.
		///             </description>
		///         </item>
		///         <item>
		///             <term>LR_MONOCHROME 0x00000001</term>
		///             <description>Creates a monochrome icon or cursor.</description>
		///         </item>
		///         <item>
		///             <term>LR_SHARED 0x00008000</term>
		///             <description>
		///                 <para>
		///                     Shares the icon or cursor handle if the icon or cursor is created multiple times. If <see cref="LR.LR_SHARED" /> is not set, a
		///                     second call to <see cref="CreateIconFromResourceEx" /> for the same resource will create the icon or cursor again and return a
		///                     different handle.
		///                 </para>
		///                 <para>When you use this flag, the system will destroy the resource when it is no longer needed.</para>
		///                 <para>
		///                     Do not use <see cref="LR.LR_SHARED" /> for icons or cursors that have non-standard sizes, that may change after loading, or that
		///                     are loaded from a file.
		///                 </para>
		///                 <para>
		///                     When loading a system icon or cursor, you must use <see cref="LR.LR_SHARED" /> or the function will fail to load the resource.
		///                 </para>
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to the icon or cursor.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="CreateIconFromResource" />, <see cref="CreateIconFromResourceEx" />, <see cref="CreateIconIndirect" />,
		///         <see cref="GetIconInfo" />, and <see cref="LookupIconIdFromDirectoryEx" /> functions allow shell applications and icon browsers to examine
		///         and use resources throughout the system.
		///     </para>
		///     <para>
		///         You should call <see cref="DestroyIcon" /> for icons created with <see cref="CreateIconFromResourceEx" />.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CreateIconFromResourceEx")]
		public static extern IntPtr CreateIconFromResourceEx(
			[In] ref byte pbIconBits, uint cbIconBits, [MarshalAs(UnmanagedType.Bool)] bool fIcon, uint dwVersion, int cxDesired, int cyDesired, LR uFlags);

		/// <summary>
		///     <para>
		///         The <see cref="ChangeDisplaySettingsEx" /> function changes the settings of the specified display device to the specified graphics mode.
		///     </para>
		///     <para>
		///         Note:  Apps that you design to target Windows 8 and later can no longer query or set display modes that are less than 32 bits per pixel
		///         (bpp); these operations will fail. These apps have a compatibility manifest that targets Windows 8. Windows 8 still supports 8-bit and 16-bit
		///         color modes for desktop apps that were built without a Windows 8 manifest; Windows 8 emulates these modes but still runs in 32-bit color
		///         mode.
		///     </para>
		/// </summary>
		/// <param name="lpszDeviceName">
		///     <para>
		///         A pointer to a null-terminated string that specifies the display device whose graphics mode will change. Only display device names as
		///         returned by <see cref="EnumDisplayDevices" /> are valid. See <see cref="EnumDisplayDevices" /> for further information on the names
		///         associated with these display devices.
		///     </para>
		///     <para>
		///         The <paramref name="lpszDeviceName" /> parameter can be NULL. A NULL value specifies the default display device. The default device can be
		///         determined by calling <see cref="EnumDisplayDevices" /> and checking for the DISPLAY_DEVICE_PRIMARY_DEVICE flag.
		///     </para>
		/// </param>
		/// <param name="lpDevMode">
		///     <para>
		///         A pointer to a <see cref="DEVMODE" /> structure that describes the new graphics mode. If <paramref name="lpDevMode" /> is NULL, all the
		///         values currently in the registry will be used for the display setting. Passing NULL for the <paramref name="lpDevMode" /> parameter and 0 for
		///         the <paramref name="dwFlags" /> parameter is the easiest way to return to the default mode after a dynamic mode change.
		///     </para>
		///     <para>
		///         The <see cref="DEVMODE.dmSize" /> member must be initialized to the size, in bytes, of the <see cref="DEVMODE" /> structure. The
		///         <see cref="DEVMODE.dmDriverExtra" /> member must be initialized to indicate the number of bytes of private driver data following the
		///         <see cref="DEVMODE" /> structure. In addition, you can use any of the following members of the <see cref="DEVMODE" /> structure.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>dmBitsPerPel</term>
		///             <description>Bits per pixel</description>
		///         </item>
		///         <item>
		///             <term>dmPelsWidth</term>
		///             <description>Pixel width</description>
		///         </item>
		///         <item>
		///             <term>dmPelsHeight</term>
		///             <description>Pixel height</description>
		///         </item>
		///         <item>
		///             <term>dmDisplayFlags</term>
		///             <description>Mode flags</description>
		///         </item>
		///         <item>
		///             <term>dmDisplayFrequency</term>
		///             <description>Mode frequency</description>
		///         </item>
		///         <item>
		///             <term>dmPosition</term>
		///             <description>Position of the device in a multi-monitor configuration.</description>
		///         </item>
		///     </list>
		///     <para>
		///         In addition to using one or more of the preceding <see cref="DEVMODE" /> members, you must also set one or more of the following values in
		///         the <see cref="DEVMODE.dmFields" /> member to change the display settings.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>DM_BITSPERPEL</term>
		///             <description>
		///                 Use the <see cref="DEVMODE.dmBitsPerPel" /> value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DM_PELSWIDTH</term>
		///             <description>
		///                 Use the <see cref="DEVMODE.dmPelsWidth" /> value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DM_PELSHEIGHT</term>
		///             <description>
		///                 Use the <see cref="DEVMODE.dmPelsHeight" /> value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DM_DISPLAYFLAGS</term>
		///             <description>
		///                 Use the dmDisplayFlags value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DM_DISPLAYFREQUENCY</term>
		///             <description>
		///                 Use the <see cref="DEVMODE.dmDisplayFrequency" /> value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DM_POSITION</term>
		///             <description>
		///                 Use the dmPosition value.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="hwnd">Reserved; must be NULL.</param>
		/// <param name="dwFlags">
		///     <para>Indicates how the graphics mode should be changed. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>0</term>
		///             <description>The graphics mode for the current screen will be changed dynamically.</description>
		///         </item>
		///         <item>
		///             <term>CDS_FULLSCREEN</term>
		///             <description>
		///                 <para>The mode is temporary in nature.</para>
		///                 <para>If you change to and from another desktop, this mode will not be reset.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>CDS_GLOBAL</term>
		///             <description>
		///                 The settings will be saved in the global settings area so that they will affect all users on the machine. Otherwise, only the
		///                 settings for the user are modified. This flag is only valid when specified with the CDS_UPDATEREGISTRY flag.
		///             </description>
		///         </item>
		///         <item>
		///             <term>CDS_NORESET</term>
		///             <description>
		///                 The settings will be saved in the registry, but will not take effect. This flag is only valid when specified with the
		///                 CDS_UPDATEREGISTRY flag.
		///             </description>
		///         </item>
		///         <item>
		///             <term>CDS_RESET</term>
		///             <description>The settings should be changed, even if the requested settings are the same as the current settings.</description>
		///         </item>
		///         <item>
		///             <term>CDS_SET_PRIMARY</term>
		///             <description>This device will become the primary device.</description>
		///         </item>
		///         <item>
		///             <term>CDS_TEST</term>
		///             <description>The system tests if the requested graphics mode could be set.</description>
		///         </item>
		///         <item>
		///             <term>CDS_UPDATEREGISTRY</term>
		///             <description>
		///                 The graphics mode for the current screen will be changed dynamically and the graphics mode will be updated in the registry. The mode
		///                 information is stored in the USER profile.
		///             </description>
		///         </item>
		///         <item>
		///             <term>CDS_VIDEOPARAMETERS</term>
		///             <description>
		///                 When set, the <paramref name="lParam" /> parameter is a pointer to a VIDEOPARAMETERS structure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>CDS_ENABLE_UNSAFE_MODES</term>
		///             <description>Enables settings changes to unsafe graphics modes.</description>
		///         </item>
		///         <item>
		///             <term>CDS_DISABLE_UNSAFE_MODES</term>
		///             <description>Disables settings changes to unsafe graphics modes.</description>
		///         </item>
		///     </list>
		///     <para>
		///         Specifying CDS_TEST allows an application to determine which graphics modes are actually valid, without causing the system to change to
		///         them.
		///     </para>
		///     <para>
		///         If CDS_UPDATEREGISTRY is specified and it is possible to change the graphics mode dynamically, the information is stored in the registry and
		///         DISP_CHANGE_SUCCESSFUL is returned. If it is not possible to change the graphics mode dynamically, the information is stored in the registry
		///         and DISP_CHANGE_RESTART is returned.
		///     </para>
		///     <para>
		///         If CDS_UPDATEREGISTRY is specified and the information could not be stored in the registry, the graphics mode is not changed and
		///         DISP_CHANGE_NOTUPDATED is returned.
		///     </para>
		/// </param>
		/// <param name="lParam">
		///     If <paramref name="dwFlags" /> is <see cref="CDS.CDS_VIDEOPARAMETERS" />, <paramref name="lParam" /> is a pointer to a VIDEOPARAMETERS
		///     structure. Otherwise <paramref name="lParam" /> must be NULL.
		/// </param>
		/// <returns>
		///     The <see cref="ChangeDisplaySettingsEx" /> function returns one of the following values.
		/// </returns>
		/// <remarks>
		///     <para>
		///         To ensure that the <see cref="DEVMODE" /> structure passed to <see cref="ChangeDisplaySettingsEx" /> is valid and contains only values
		///         supported by the display driver, use the <see cref="DEVMODE" /> returned by the <see cref="EnumDisplaySettings" /> function.
		///     </para>
		///     <para>
		///         When adding a display monitor to a multiple-monitor system programmatically, set <see cref="DEVMODE.dmFields" /> to DM_POSITION and specify a
		///         position (in dmPosition) for the monitor you are adding that is adjacent to at least one pixel of the display area of
		///         an existing monitor. To detach the monitor, set <see cref="DEVMODE.dmFields" /> to DM_POSITION but set <see cref="DEVMODE.dmPelsWidth" /> and
		///         <see cref="DEVMODE.dmPelsHeight" /> to zero. For more information, see Multiple Display Monitors.
		///     </para>
		///     <para>
		///         When the display mode is changed dynamically, the <see cref="WM.WM_DISPLAYCHANGE" /> message is sent to all running applications with the
		///         following message parameters.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "ChangeDisplaySettingsEx")]
		public static extern int ChangeDisplaySettingsEx(
			[In] string lpszDeviceName, [In] ref DEVMODE lpDevMode, IntPtr hwnd, CDS dwFlags, [In] IntPtr lParam);

		/// <summary>
		///     Enables the specified process to set the foreground window using the <see cref="SetForegroundWindow" /> function. The calling process must
		///     already be able to set the foreground window. For more information, see Remarks later in this topic.
		/// </summary>
		/// <param name="dwProcessId">
		///     The identifier of the process that will be enabled to set the foreground window. If this parameter is ASFW_ANY, all processes will
		///     be enabled to set the foreground window.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>
		///         If the function fails, the return value is zero. The function will fail if the calling process cannot set the foreground window. To get
		///         extended error information, call GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     The system restricts which processes can set the foreground window. A process can set the foreground window only if one of the following
		///     conditions is true:
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "AllowSetForegroundWindow")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool AllowSetForegroundWindow(uint dwProcessId);

		/// <summary>
		///     Assigns the specified window station to the calling process. This enables the process to access objects in the window station such as desktops,
		///     the clipboard, and global atoms. All subsequent operations on the window station use the access rights granted to <paramref name="hWinSta" />.
		/// </summary>
		/// <param name="hWinSta">
		///     <para>
		///         A handle to the window station. This can be a handle returned by the <see cref="CreateWindowStation" />, <see cref="OpenWindowStation" />, or
		///         <see cref="GetProcessWindowStation" /> function.
		///     </para>
		///     <para>This window station must be associated with the current session.</para>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetProcessWindowStation")]
		public static extern bool SetProcessWindowStation([In] IntPtr hWinSta);

		/// <summary>Changes the default layout when windows are created with no parent or owner only for the currently running process.</summary>
		/// <param name="dwDefaultLayout">
		///     <para>The default process layout. This parameter can be 0 or the following value.</para>
		///     <list type="table">
		///         <item>
		///             <term>LAYOUT_RTL 0x00000001</term>
		///             <description>Sets the default horizontal layout to be right to left.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The layout specifies how text and graphics are laid out; the default is left to right. The <see cref="SetProcessDefaultLayout" /> function
		///         changes layout to be right to left, which is the standard in Arabic and Hebrew cultures.
		///     </para>
		///     <para>
		///         After the LAYOUT_RTL flag is selected, flags normally specifying right or left are reversed. To avoid confusion, consider
		///         defining alternate words for standard flags, such as those in the following table.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetProcessDefaultLayout")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool SetProcessDefaultLayout(uint dwDefaultLayout);

		/// <summary>
		///     <para>[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]</para>
		///     <para>Registers a specified Shell window to receive certain messages for events or notifications that are useful to Shell applications.</para>
		///     <para>
		///         The event messages received are only those sent to the Shell window associated with the specified window's desktop. Many of the messages are
		///         the same as those that can be received after calling the <see cref="SetWindowsHookEx" /> function and specifying <see cref="WH.WH_SHELL" /> for
		///         the hook type. The difference with <see cref="RegisterShellHookWindow" /> is that the messages are received through the specified window's
		///         <see cref="WindowProc" /> and not through a call back procedure.
		///     </para>
		/// </summary>
		/// <param name="hWnd">A handle to the window to register for Shell hook messages.</param>
		/// <returns>
		///     <para>TRUE if the function succeeds; otherwise, FALSE.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         As with normal window messages, the second parameter of the window procedure identifies the message as a
		///         WM_SHELLHOOKMESSAGE. However, for these Shell hook messages, the message value is not a pre-defined constant like other
		///         message IDs such as
		///         <see cref="WM.WM_COMMAND" />. The value must be obtained dynamically using a call to <see cref="RegisterWindowMessage" /> as shown here:
		///     </para>
		///     <para>RegisterWindowMessage(TEXT("SHELLHOOK"));</para>
		///     <para>
		///         This precludes handling these messages using a traditional switch statement which requires ID values that are known at compile time. For
		///         handling Shell hook messages, the normal practice is to code an If statement in the default section of your switch statement and then handle
		///         the message if the value of the message ID is the same as the value obtained from the <see cref="RegisterWindowMessage" /> call.
		///     </para>
		///     <para>
		///         The following table describes the wParam and lParam parameter values passed to the window procedure
		///         for the Shell hook messages.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "RegisterShellHookWindow")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool RegisterShellHookWindow([In] IntPtr hWnd);

		/// <summary>Registers the devices that supply the raw input data.</summary>
		/// <param name="pRawInputDevices">
		///     An array of <see cref="RAWINPUTDEVICE" /> structures that represent the devices that supply the raw input.
		/// </param>
		/// <param name="uiNumDevices">
		///     The number of <see cref="RAWINPUTDEVICE" /> structures pointed to by <paramref name="pRawInputDevices" />.
		/// </param>
		/// <param name="cbSize">
		///     The size, in bytes, of a <see cref="RAWINPUTDEVICE" /> structure.
		/// </param>
		/// <returns>TRUE if the function succeeds; otherwise, FALSE. If the function fails, call GetLastError for more information.</returns>
		/// <remarks>
		///     <para>
		///         To receive <see cref="WM.WM_INPUT" /> messages, an application must first register the raw input devices using
		///         <see cref="RegisterRawInputDevices" />. By default, an application does not receive raw input.
		///     </para>
		///     <para>
		///         To receive <see cref="WM.WM_INPUT_DEVICE_CHANGE" /> messages, an application must specify the RIDEV_DEVNOTIFY flag for each device class that
		///         is specified by the usUsagePage and usUsage fields of the <see cref="RAWINPUTDEVICE" /> structure . By default, an application does not
		///         receive
		///         <see cref="WM.WM_INPUT_DEVICE_CHANGE" /> notifications for raw input device arrival and removal.
		///     </para>
		///     <para>
		///         If a <see cref="RAWINPUTDEVICE" /> structure has the RIDEV_REMOVE flag set and the hwndTarget parameter is not set to NULL, then parameter
		///         validation will fail.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "RegisterRawInputDevices")]
		public static extern bool RegisterRawInputDevices(
			[MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.Struct, SizeParamIndex = 1)] RAWINPUTDEVICE[] pRawInputDevices, uint uiNumDevices,
			uint cbSize);

		/// <summary>
		///     The foreground process can call the <see cref="LockSetForegroundWindow" /> function to disable calls to the <see cref="SetForegroundWindow" />
		///     function.
		/// </summary>
		/// <param name="uLockCode">
		///     <para>
		///         Specifies whether to enable or disable calls to <see cref="SetForegroundWindow" />. This parameter can be one of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>LSFW_LOCK 1</term>
		///             <description>
		///                 Disables calls to <see cref="SetForegroundWindow" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>LSFW_UNLOCK 2</term>
		///             <description>
		///                 Enables calls to <see cref="SetForegroundWindow" />.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The system automatically enables calls to <see cref="SetForegroundWindow" /> if the user presses the ALT key or takes some action that causes
		///         the system itself to change the foreground window (for example, clicking a background window).
		///     </para>
		///     <para>
		///         This function is provided so applications can prevent other applications from making a foreground change that can interrupt its interaction
		///         with the user.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "LockSetForegroundWindow")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool LockSetForegroundWindow(uint uLockCode);

		/// <summary>Determines whether there is an installed WinEvent hook that might be notified of a specified event.</summary>
		/// <param name="event">
		///     The event constant that hooks might be notified of. The function checks whether there is an installed hook for this event
		///     constant.
		/// </param>
		/// <returns>
		///     <para>If there is a hook to be notified of the specified event, the return value is TRUE.</para>
		///     <para>If there are no hooks to be notified of the specified event, the return value is FALSE.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         This method is guaranteed to never return a false negative. If this method returns FALSE, it means that no hooks in the system would be
		///         notified of the event. However, this method may return a false positive. In other words, it may return TRUE even though there are no hooks
		///         that would be notified. Thus, it is safe for components to circumvent some work if this method returns FALSE.
		///     </para>
		///     <para>Event hooks can be installed at any time, so server developers should not cache the return value for long periods of time.</para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "IsWinEventHookInstalled")]
		public static extern bool IsWinEventHookInstalled(uint @event);

		/// <summary>Retrieves a handle to the current window station for the calling process.</summary>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to the window station.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The system associates a window station with a process when the process is created. A process can use the
		///         <see cref="SetProcessWindowStation" /> function to change its window station.
		///     </para>
		///     <para>
		///         The calling process can use the returned handle in calls to the <see cref="GetUserObjectInformation" />, <see cref="GetUserObjectSecurity" />
		///         , <see cref="SetUserObjectInformation" />, and <see cref="SetUserObjectSecurity" /> functions.
		///     </para>
		///     <para>Do not close the handle returned by this function.</para>
		///     <para>
		///         A service application is created with an associated window station and desktop, so there is no need to call a USER or GDI function to connect
		///         the service to a window station and desktop.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetProcessWindowStation")]
		public static extern IntPtr GetProcessWindowStation();

		/// <summary>Retrieves the default layout that is used when windows are created with no parent or owner.</summary>
		/// <param name="pdwDefaultLayout">
		///     The current default process layout. For a list of values, see <see cref="SetProcessDefaultLayout" />.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     The layout specifies how text and graphics are laid out in a window; the default is left to right. The <see cref="GetProcessDefaultLayout" />
		///     function lets you know if the default layout has changed, from using <see cref="SetProcessDefaultLayout" />.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetProcessDefaultLayout")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool GetProcessDefaultLayout([Out] out uint pdwDefaultLayout);

		/// <summary>Retrieves from the clipboard the name of the specified registered format. The function copies the name to the specified buffer.</summary>
		/// <param name="format">The type of format to be retrieved. This parameter must not specify any of the predefined clipboard formats.</param>
		/// <param name="lpszFormatName">The buffer that is to receive the format name.</param>
		/// <param name="cchMaxCount">
		///     The maximum length, in characters, of the string to be copied to the buffer. If the name exceeds this limit, it is
		///     truncated.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the length, in characters, of the string copied to the buffer.</para>
		///     <para>
		///         If the function fails, the return value is zero, indicating that the requested format does not exist or is predefined. To get extended error
		///         information, call GetLastError.
		///     </para>
		/// </returns>
		/// <remarks></remarks>
		[DllImport("user32.dll", EntryPoint = "GetClipboardFormatName")]
		public static extern int GetClipboardFormatName(uint format, [Out] StringBuilder lpszFormatName, int cchMaxCount);

		/// <summary>
		///     Retrieves the current selection from a combo box filled by using the <see cref="DlgDirListComboBox" /> function. The selection is interpreted as
		///     a drive letter, a file, or a directory name.
		/// </summary>
		/// <param name="hDlg">A handle to the dialog box that contains the combo box.</param>
		/// <param name="lpString">A pointer to the buffer that receives the selected path.</param>
		/// <param name="nCount">
		///     The length, in characters, of the buffer pointed to by the <paramref name="lpString" /> parameter.
		/// </param>
		/// <param name="nIDComboBox">The integer identifier of the combo box control in the dialog box.</param>
		/// <returns>
		///     <para>If the current selection is a directory name, the return value is nonzero.</para>
		///     <para>If the current selection is not a directory name, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If the current selection specifies a directory name or drive letter, the <see cref="DlgDirSelectComboBoxEx" /> function removes the enclosing
		///         square brackets (and hyphens for drive letters) so the name or letter is ready to be inserted into a new path or file name. If there is no
		///         selection, the contents of the buffer pointed to by <paramref name="lpString" /> do not change.
		///     </para>
		///     <para>
		///         The <see cref="DlgDirSelectComboBoxEx" /> function does not allow more than one file name to be returned from a combo box.
		///     </para>
		///     <para>If the string is as long or longer than the buffer, the buffer contains the truncated string with a terminating null character.</para>
		///     <para>
		///         <see cref="DlgDirSelectComboBoxEx" /> sends <see cref="CB.CB_GETCURSEL" /> and <see cref="CB.CB_GETLBTEXT" /> messages to the combo box.
		///     </para>
		///     <para>
		///         You can use this function with all three types of combo boxes (<see cref="CBS.CBS_SIMPLE" />, <see cref="CBS.CBS_DROPDOWN" />, and CBS_DROPDOWNLIST).
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DlgDirSelectComboBoxEx")]
		public static extern bool DlgDirSelectComboBoxEx([In] IntPtr hDlg, [Out] StringBuilder lpString, int nCount, int nIDComboBox);

		/// <summary>
		///     Creates a modal dialog box from a dialog box template in memory. Before displaying the dialog box, the function passes an application-defined
		///     value to the dialog box procedure as the lParam parameter of the <see cref="WM.WM_INITDIALOG" /> message. An application can use this value to
		///     initialize dialog box controls.
		/// </summary>
		/// <param name="hInstance">A handle to the module that creates the dialog box.</param>
		/// <param name="hDialogTemplate">
		///     <para>
		///         The template that <see cref="DialogBoxIndirectParam" /> uses to create the dialog box. A dialog box template consists of a header that
		///         describes the dialog box, followed by one or more additional blocks of data that describe each of the controls in the dialog box. The
		///         template can use either the standard format or the extended format.
		///     </para>
		///     <para>
		///         In a standard template for a dialog box, the header is a <see cref="DLGTEMPLATE" /> structure followed by additional variable-length arrays.
		///         The data for each control consists of a <see cref="DLGITEMTEMPLATE" /> structure followed by additional variable-length arrays.
		///     </para>
		///     <para>
		///         In an extended template for a dialog box, the header uses the <see cref="DLGTEMPLATEEX" /> format and the control definitions use the
		///         <see cref="DLGITEMTEMPLATEEX" /> format.
		///     </para>
		/// </param>
		/// <param name="hWndParent">A handle to the window that owns the dialog box.</param>
		/// <param name="lpDialogFunc">
		///     A pointer to the dialog box procedure. For more information about the dialog box procedure, see <see cref="DialogProc" />.
		/// </param>
		/// <param name="dwInitParam">
		///     The value to pass to the dialog box in the lParam parameter of the <see cref="WM.WM_INITDIALOG" /> message.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is the nResult parameter specified in the call to the <see cref="EndDialog" />
		///         function that was used to terminate the dialog box.
		///     </para>
		///     <para>
		///         If the function fails because the <paramref name="hWndParent" /> parameter is invalid, the return value is zero. The function returns zero in
		///         this case for compatibility with previous versions of Windows. If the function fails for any other reason, the return value is –1. To get
		///         extended error information, call GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="DialogBoxIndirectParam" /> function uses the <see cref="CreateWindowEx" /> function to create the dialog box.
		///         <see cref="DialogBoxIndirectParam" /> then sends a <see cref="WM.WM_INITDIALOG" /> message to the dialog box procedure. If the template
		///         specifies the <see cref="DS.DS_SETFONT" /> or DS_SHELLFONT style, the function also sends a <see cref="WM.WM_SETFONT" /> message to the dialog
		///         box procedure. The function displays the dialog box (regardless of whether the template specifies the <see cref="WS.WS_VISIBLE" />
		///         style), disables the owner window, and starts its own message loop to retrieve and dispatch messages for the dialog box.
		///     </para>
		///     <para>
		///         When the dialog box procedure calls the <see cref="EndDialog" /> function, <see cref="DialogBoxIndirectParam" /> destroys the dialog box,
		///         ends the message loop, enables the owner window (if previously enabled), and returns the nResult parameter specified by
		///         the dialog box procedure when it called <see cref="EndDialog" />.
		///     </para>
		///     <para>
		///         In a standard dialog box template, the <see cref="DLGTEMPLATE" /> structure and each of the <see cref="DLGITEMTEMPLATE" /> structures must be
		///         aligned on DWORD boundaries. The creation data array that follows a <see cref="DLGITEMTEMPLATE" /> structure must also be aligned on a DWORD
		///         boundary. All of the other variable-length arrays in the template must be aligned on WORD
		///         boundaries.
		///     </para>
		///     <para>
		///         In an extended dialog box template, the <see cref="DLGTEMPLATEEX" /> header and each of the <see cref="DLGITEMTEMPLATEEX" /> control
		///         definitions must be aligned on DWORD boundaries. The creation data array, if any, that follows a
		///         <see cref="DLGITEMTEMPLATEEX" /> structure must also be aligned on a DWORD boundary. All of the other variable-length arrays in the template
		///         must be aligned on WORD boundaries.
		///     </para>
		///     <para>All character strings in the dialog box template, such as titles for the dialog box and buttons, must be Unicode strings.</para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DialogBoxIndirectParam")]
		public static extern int DialogBoxIndirectParam(
			[In] IntPtr hInstance, [In] ref DLGTEMPLATE hDialogTemplate, [In] IntPtr hWndParent, DialogProc lpDialogFunc,
			[MarshalAs(UnmanagedType.SysInt)] int dwInitParam);

		/// <summary>Destroys an accelerator table.</summary>
		/// <param name="hAccel">
		///     A handle to the accelerator table to be destroyed. This handle must have been created by a call to the <see cref="CreateAcceleratorTable" /> or
		///     <see cref="LoadAccelerators" /> function.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is nonzero. However, if the table has been loaded more than one call to
		///         <see cref="LoadAccelerators" />, the function will return a nonzero value only when <see cref="DestroyAcceleratorTable" /> has been called an
		///         equal number of times.
		///     </para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DestroyAcceleratorTable")]
		public static extern bool DestroyAcceleratorTable([In] IntPtr hAccel);

		/// <summary>Creates an accelerator table.</summary>
		/// <param name="lpaccl">
		///     An array of <see cref="ACCEL" /> structures that describes the accelerator table.
		/// </param>
		/// <param name="cEntries">
		///     The number of <see cref="ACCEL" /> structures in the array. This must be within the range 1 to 32767 or the function will fail.
		/// </param>
		/// <returns>
		///     If the function succeeds, the return value is the handle to the created accelerator table; otherwise, it is NULL. To get extended error
		///     information, call GetLastError.
		/// </returns>
		/// <remarks>
		///     Before an application closes, it can use the <see cref="DestroyAcceleratorTable" /> function to destroy any accelerator tables that it created by
		///     using the <see cref="CreateAcceleratorTable" /> function.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CreateAcceleratorTable")]
		public static extern IntPtr CreateAcceleratorTable(
			[MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.Struct, SizeParamIndex = 1)] ACCEL[] lpaccl, int cEntries);

		/// <summary>
		///     <para>
		///         Sends a message to the specified recipients. The recipients can be applications, installable drivers, network drivers, system-level device
		///         drivers, or any combination of these system components.
		///     </para>
		///     <para>
		///         To receive additional information if the request is defined, use the <see cref="BroadcastSystemMessageEx" /> function.
		///     </para>
		/// </summary>
		/// <param name="dwFlags">
		///     <para>The broadcast option. This parameter can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>BSF_ALLOWSFW 0x00000080</term>
		///             <description>Enables the recipient to set the foreground window while processing the message.</description>
		///         </item>
		///         <item>
		///             <term>BSF_FLUSHDISK 0x00000004</term>
		///             <description>Flushes the disk after each recipient processes the message.</description>
		///         </item>
		///         <item>
		///             <term>BSF_FORCEIFHUNG 0x00000020</term>
		///             <description>Continues to broadcast the message, even if the time-out period elapses or one of the recipients is not responding.</description>
		///         </item>
		///         <item>
		///             <term>BSF_IGNORECURRENTTASK 0x00000002</term>
		///             <description>
		///                 Does not send the message to windows that belong to the current task. This prevents an application from receiving its own
		///                 message.
		///             </description>
		///         </item>
		///         <item>
		///             <term>BSF_NOHANG 0x00000008</term>
		///             <description>
		///                 Forces a nonresponsive application to time out. If one of the recipients times out, do not continue broadcasting the
		///                 message.
		///             </description>
		///         </item>
		///         <item>
		///             <term>BSF_NOTIMEOUTIFNOTHUNG 0x00000040</term>
		///             <description>Waits for a response to the message, as long as the recipient is not being unresponsive. Does not time out.</description>
		///         </item>
		///         <item>
		///             <term>BSF_POSTMESSAGE 0x00000010</term>
		///             <description>
		///                 Posts the message. Do not use in combination with <see cref="BSF.BSF_QUERY" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>BSF_QUERY 0x00000001</term>
		///             <description>Sends the message to one recipient at a time, sending to a subsequent recipient only if the current recipient returns TRUE.</description>
		///         </item>
		///         <item>
		///             <term>BSF_SENDNOTIFYMESSAGE 0x00000100</term>
		///             <description>
		///                 Sends the message using <see cref="SendNotifyMessage" /> function. Do not use in combination with <see cref="BSF.BSF_QUERY" />.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="lpdwRecipients">
		///     <para>A pointer to a variable that contains and receives information about the recipients of the message.</para>
		///     <para>When the function returns, this variable receives a combination of these values identifying which recipients actually received the message.</para>
		///     <para>If this parameter is NULL, the function broadcasts to all components.</para>
		///     <para>This parameter can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>BSM_ALLCOMPONENTS 0x00000000</term>
		///             <description>Broadcast to all system components.</description>
		///         </item>
		///         <item>
		///             <term>BSM_ALLDESKTOPS 0x00000010</term>
		///             <description>
		///                 Broadcast to all desktops. Requires the SE_TCB_NAME privilege.
		///             </description>
		///         </item>
		///         <item>
		///             <term>BSM_APPLICATIONS 0x00000008</term>
		///             <description>Broadcast to applications.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="uiMessage">
		///     <para>The message to be sent.</para>
		///     <para>For lists of the system-provided messages, see System-Defined Messages.</para>
		/// </param>
		/// <param name="wParam">Additional message-specific information.</param>
		/// <param name="lParam">Additional message-specific information.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a positive value.</para>
		///     <para>If the function is unable to broadcast the message, the return value is –1.</para>
		///     <para>
		///         If the <paramref name="dwFlags" /> parameter is <see cref="BSF.BSF_QUERY" /> and at least one recipient returned
		///         BROADCAST_QUERY_DENY to the corresponding message, the return value is zero. To get extended error information, call
		///         GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If <see cref="BSF.BSF_QUERY" /> is not specified, the function sends the specified message to all requested recipients, ignoring values returned
		///         by those recipients.
		///     </para>
		///     <para>
		///         The system only does marshalling for system messages (those in the range 0 to (<see cref="WM.WM_USER" />-1)). To send other messages (those
		///         >=
		///         <see cref="WM.WM_USER" />) to another process, you must do custom marshalling.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "BroadcastSystemMessage")]
		public static extern int BroadcastSystemMessage(
			BSF dwFlags, IntPtr lpdwRecipients, uint uiMessage, [MarshalAs(UnmanagedType.SysUInt)] uint wParam, [MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>Associates a Help context identifier with the specified window.</summary>
		/// <param name="hwnd">A handle to the window with which to associate the Help context identifier.</param>
		/// <param name="dwContextHelpId">The Help context identifier.</param>
		/// <returns>
		///     <para>Returns nonzero if successful, or zero otherwise.</para>
		///     <para>To retrieve extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     If a child window does not have a Help context identifier, it inherits the identifier of its parent window. Likewise, if an owned window does not
		///     have a Help context identifier, it inherits the identifier of its owner window. This inheritance of Help context identifiers allows an
		///     application to set just one identifier for a dialog box and all of its controls.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetWindowContextHelpId")]
		public static extern bool SetWindowContextHelpId([In] IntPtr hwnd, uint dwContextHelpId);

		/// <summary>
		///     Defines a new window message that is guaranteed to be unique throughout the system. The message value can be used when sending or posting
		///     messages.
		/// </summary>
		/// <param name="lpString">The message to be registered.</param>
		/// <returns>
		///     <para>If the message is successfully registered, the return value is a message identifier in the range 0xC000 through 0xFFFF.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="RegisterWindowMessage" /> function is typically used to register messages for communicating between two cooperating
		///         applications.
		///     </para>
		///     <para>
		///         If two different applications register the same message string, the applications return the same message value. The message remains
		///         registered until the session ends.
		///     </para>
		///     <para>
		///         Only use <see cref="RegisterWindowMessage" /> when more than one application must process the same message. For sending private messages
		///         within a window class, an application can use any integer in the range <see cref="WM.WM_USER" /> through 0x7FFF. (Messages in this range are
		///         private to a window class, not to an application. For example, predefined control classes such as BUTTON, EDIT,
		///         LISTBOX, and COMBOBOX may use values in this range.)
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "RegisterWindowMessage")]
		public static extern uint RegisterWindowMessage([In] string lpString);

		/// <summary>Retrieves the Help context identifier, if any, associated with the specified window.</summary>
		/// <param name="hwnd">A handle to the window for which the Help context identifier is to be retrieved.</param>
		/// <returns>Returns the Help context identifier if the window has one, or zero otherwise.</returns>
		[DllImport("user32.dll", EntryPoint = "GetWindowContextHelpId")]
		public static extern uint GetWindowContextHelpId([In] IntPtr hwnd);

		/// <summary>Retrieves information about the raw input device.</summary>
		/// <param name="hDevice">
		///     A handle to the raw input device. This comes from the lParam of the <see cref="WM.WM_INPUT" /> message, from the
		///     <see cref="hDevice" /> member of <see cref="RAWINPUTHEADER" />, or from <see cref="GetRawInputDeviceList" />. It can also be NULL if an
		///     application inserts input data, for example, by using <see cref="SendInput" />.
		/// </param>
		/// <param name="uiCommand">
		///     <para>
		///         Specifies what data will be returned in <paramref name="pData" />. This parameter can be one of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>RIDI_DEVICENAME 0x20000007</term>
		///             <description>
		///                 <para>
		///                     <paramref name="pData" /> points to a string that contains the device name.
		///                 </para>
		///                 <para>
		///                     For this <paramref name="uiCommand" /> only, the value in <paramref name="pcbSize" /> is the character count (not the byte
		///                     count).
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>RIDI_DEVICEINFO 0x2000000b</term>
		///             <description>
		///                 <paramref name="pData" /> points to an <see cref="RID_DEVICE_INFO" /> structure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>RIDI_PREPARSEDDATA 0x20000005</term>
		///             <description>
		///                 <paramref name="pData" /> points to the previously parsed data.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="pData">
		///     A pointer to a buffer that contains the information specified by <paramref name="uiCommand" />. If <paramref name="uiCommand" /> is
		///     <see cref="RIDI.RIDI_DEVICEINFO" />, set the <see cref="RID_DEVICE_INFO.cbSize" /> member of <see cref="RID_DEVICE_INFO" /> to sizeof(RID_DEVICE_INFO) before calling
		///     <see cref="GetRawInputDeviceInfo" />.
		/// </param>
		/// <param name="pcbSize">
		///     The size, in bytes, of the data in <paramref name="pData" />.
		/// </param>
		/// <returns>
		///     <para>
		///         If successful, this function returns a non-negative number indicating the number of bytes copied to <paramref name="pData" />.
		///     </para>
		///     <para>
		///         If <paramref name="pData" /> is not large enough for the data, the function returns -1. If <paramref name="pData" /> is NULL, the function
		///         returns a value of zero. In both of these cases, <paramref name="pcbSize" /> is set to the minimum size required for the
		///         <paramref name="pData" /> buffer.
		///     </para>
		///     <para>Call GetLastError to identify any other errors.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetRawInputDeviceInfo")]
		public static extern uint GetRawInputDeviceInfo([In] IntPtr hDevice, uint uiCommand, IntPtr pData, ref uint pcbSize);

		/// <summary>Retrieves the handle to the window that currently has the clipboard open.</summary>
		/// <returns>
		///     If the function succeeds, the return value is the handle to the window that has the clipboard open. If no window has the clipboard open, the
		///     return value is NULL. To get extended error information, call GetLastError.
		/// </returns>
		/// <remarks>
		///     If an application or DLL specifies a NULL window handle when calling the <see cref="OpenClipboard" /> function, the clipboard is opened but is
		///     not associated with a window. In such a case, <see cref="GetOpenClipboardWindow" /> returns NULL.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetOpenClipboardWindow")]
		public static extern IntPtr GetOpenClipboardWindow();

		/// <summary>Retrieves the name of the active input locale identifier (formerly called the keyboard layout) for the system.</summary>
		/// <param name="pwszKLID">
		///     The buffer (of at least KL_NAMELENGTH characters in length) that receives the name of the input locale identifier, including the terminating null
		///     character. This will be a copy of the string provided to the <see cref="LoadKeyboardLayout" /> function, unless layout substitution took place.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input
		///         Method Editor (IME), or any other form of input.
		///     </para>
		///     <para>
		///         Beginning in Windows 8: The preferred method to retrieve the language associated with the current keyboard layout or input method is a call
		///         to Windows.Globalization.Language.CurrentInputMethodLanguageTag. If your app passes language tags from
		///         CurrentInputMethodLanguageTag to any National Language Support functions, it must first convert the tags by calling
		///         ResolveLocaleName.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetKeyboardLayoutName")]
		public static extern bool GetKeyboardLayoutName([Out] StringBuilder pwszKLID);

		/// <summary>
		///     <para>
		///         The <see cref="EnumDisplaySettingsEx" /> function retrieves information about one of the graphics modes for a display device. To retrieve
		///         information for all the graphics modes for a display device, make a series of calls to this function.
		///     </para>
		///     <para>
		///         This function differs from <see cref="EnumDisplaySettings" /> in that there is a <paramref name="dwFlags" /> parameter.
		///     </para>
		///     <para>
		///         Note:  Apps that you design to target Windows 8 and later can no longer query or set display modes that are less than 32 bits per pixel
		///         (bpp); these operations will fail. These apps have a compatibility manifest that targets Windows 8. Windows 8 still supports 8-bit and 16-bit
		///         color modes for desktop apps that were built without a Windows 8 manifest; Windows 8 emulates these modes but still runs in 32-bit color
		///         mode.
		///     </para>
		/// </summary>
		/// <param name="lpszDeviceName">
		///     <para>A pointer to a null-terminated string that specifies the display device about which graphics mode the function will obtain information.</para>
		///     <para>
		///         This parameter is either NULL or a <see cref="DISPLAY_DEVICE" />.<see cref="DISPLAY_DEVICE.DeviceName" /> returned from
		///         <see cref="EnumDisplayDevices" />. A NULL value specifies the current display device on the computer that the calling thread is running on.
		///     </para>
		/// </param>
		/// <param name="iModeNum">
		///     <para>Indicates the type of information to be retrieved. This value can be a graphics mode index or one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>ENUM_CURRENT_SETTINGS</term>
		///             <description>Retrieve the current settings for the display device.</description>
		///         </item>
		///         <item>
		///             <term>ENUM_REGISTRY_SETTINGS</term>
		///             <description>Retrieve the settings for the display device that are currently stored in the registry.</description>
		///         </item>
		///     </list>
		///     <para>
		///         Graphics mode indexes start at zero. To obtain information for all of a display device's graphics modes, make a series of calls to
		///         <see cref="EnumDisplaySettingsEx" />, as follows: Set <paramref name="iModeNum" /> to zero for the first call, and increment
		///         <paramref name="iModeNum" /> by one for each subsequent call. Continue calling the function until the return value is zero.
		///     </para>
		///     <para>
		///         When you call <see cref="EnumDisplaySettingsEx" /> with <paramref name="iModeNum" /> set to zero, the operating system initializes and caches
		///         information about the display device. When you call <see cref="EnumDisplaySettingsEx" /> with <paramref name="iModeNum" /> set to a nonzero
		///         value, the function returns the information that was cached the last time the function was called with <paramref name="iModeNum" /> set to
		///         zero.
		///     </para>
		/// </param>
		/// <param name="lpDevMode">
		///     <para>
		///         A pointer to a <see cref="DEVMODE" /> structure into which the function stores information about the specified graphics mode. Before calling
		///         <see cref="EnumDisplaySettingsEx" />, set the <see cref="DEVMODE.dmSize" /> member to sizeof (<see cref="DEVMODE" />), and set the
		///         <see cref="DEVMODE.dmDriverExtra" /> member to indicate the size, in bytes, of the additional space available to receive private driver data.
		///     </para>
		///     <para>
		///         The <see cref="EnumDisplaySettingsEx" /> function will populate the <see cref="DEVMODE.dmFields" /> member of the <see cref="lpDevMode" />
		///         and one or more other members of the <see cref="DEVMODE" /> structure. To determine which members were set by the call to
		///         <see cref="EnumDisplaySettingsEx" />, inspect the <see cref="DEVMODE.dmFields" /> bitmask. Some of the fields typically populated by
		///         this function include:
		///     </para>
		/// </param>
		/// <param name="dwFlags">
		///     <para>This parameter can be the following value.</para>
		///     <list type="table">
		///         <item>
		///             <term>EDS_RAWMODE</term>
		///             <description>
		///                 If set, the function will return all graphics modes reported by the adapter driver, regardless of monitor capabilities. Otherwise, it
		///                 will only return modes that are compatible with current monitors.
		///             </description>
		///         </item>
		///         <item>
		///             <term>EDS_ROTATEDMODE</term>
		///             <description>
		///                 If set, the function will return graphics modes in all orientations. Otherwise, it will only return modes that have the same
		///                 orientation as the one currently set for the requested display.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		///     <para></para>
		/// </returns>
		/// <remarks>
		///     The function fails if <paramref name="iModeNum" /> is greater than the index of the display device's last graphics mode. As noted in the
		///     description of the <paramref name="iModeNum" /> parameter, you can use this behavior to enumerate all of a display device's graphics modes.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "EnumDisplaySettingsEx")]
		public static extern bool EnumDisplaySettingsEx(
			[In] [MarshalAs(UnmanagedType.LPWStr)] string lpszDeviceName, uint iModeNum, [Out] out DEVMODE lpDevMode, EDS dwFlags);

		/// <summary>
		///     Specifies the quality of service (QOS) a raw Dynamic Data Exchange (DDE) application desires for future DDE conversations it initiates. The
		///     specified QOS applies to any conversations started while those settings are in place. A DDE conversation's quality of service lasts for the
		///     duration of the conversation; calls to the <see cref="DdeSetQualityOfService" /> function during a conversation do not affect that conversation's
		///     QOS.
		/// </summary>
		/// <param name="hwndClient">
		///     A handle to the DDE client window that specifies the source of WM_DDE_INITIATE messages a client will send to start DDE
		///     conversations.
		/// </param>
		/// <param name="pqosNew">
		///     A pointer to a <see cref="SECURITY_QUALITY_OF_SERVICE" /> structure for the desired quality of service values.
		/// </param>
		/// <param name="pqosPrev">
		///     <para>
		///         A pointer to a <see cref="SECURITY_QUALITY_OF_SERVICE" /> structure that receives the previous quality of service values associated with the
		///         window identified by <paramref name="hwndClient" />.
		///     </para>
		///     <para>
		///         This parameter is optional. If an application has no interest in <paramref name="hwndClient" />'s previous QOS values, it should set
		///         <paramref name="pqosPrev" /> to NULL.
		///     </para>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     If a quality of service has not been specified for a client window, <paramref name="hwndClient" />, prior to sending a
		///     WM_DDE_INITIATE with the wParam set to <paramref name="hwndClient" />, the system uses the following default quality of service
		///     values for the client window:
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DdeSetQualityOfService")]
		public static extern bool DdeSetQualityOfService(IntPtr hwndClient, ref SECURITY_QUALITY_OF_SERVICE pqosNew, ref SECURITY_QUALITY_OF_SERVICE pqosPrev);

		/// <summary>
		///     Creates a handle that identifies the specified string. A Dynamic Data Exchange (DDE) client or server application can pass the string handle as a
		///     parameter to other Dynamic Data Exchange Management Library (DDEML) functions.
		/// </summary>
		/// <param name="idInst">
		///     The application instance identifier obtained by a previous call to the <see cref="DdeInitialize" /> function.
		/// </param>
		/// <param name="psz">
		///     The null-terminated string for which a handle is to be created. This string can be up to 255 characters. The reason for this limit is that DDEML
		///     string management functions are implemented using atoms.
		/// </param>
		/// <param name="iCodePage">
		///     The code page to be used to render the string. This value should be either CP_WINANSI (the default code page) or CP_WINUNICODE, depending on
		///     whether the ANSI or Unicode version of <see cref="DdeInitialize" /> was called by the client application.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a string handle.</para>
		///     <para>If the function fails, the return value is 0L.</para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>The value of a string handle is not related to the case of the string it identifies.</para>
		///     <para>
		///         When an application either creates a string handle or receives one in the callback function and then uses the
		///         <see cref="DdeKeepStringHandle" /> function to keep it, the application must free that string handle when it is no longer needed.
		///     </para>
		///     <para>
		///         An instance-specific string handle cannot be mapped from string handle to string and back to string handle. This is shown in the following
		///         example, in which the <see cref="DdeQueryString" /> function creates a string from a string handle and <see cref="DdeCreateStringHandle" />
		///         creates a string handle from that string, but the two handles are not the same:
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DdeCreateStringHandle")]
		public static extern IntPtr DdeCreateStringHandle(uint idInst, [In] string psz, int iCodePage);

		/// <summary>
		///     <para>Creates an icon or cursor from resource bits describing the icon.</para>
		///     <para>
		///         To specify a desired height or width, use the <see cref="CreateIconFromResourceEx" /> function.
		///     </para>
		/// </summary>
		/// <param name="presbits">
		///     The buffer containing the icon or cursor resource bits. These bits are typically loaded by calls to the <see cref="LookupIconIdFromDirectory" />,
		///     <see cref="LookupIconIdFromDirectoryEx" />, and LoadResource functions.
		/// </param>
		/// <param name="dwResSize">
		///     The size, in bytes, of the set of bits pointed to by the <paramref name="presbits" /> parameter.
		/// </param>
		/// <param name="fIcon">
		///     Indicates whether an icon or a cursor is to be created. If this parameter is TRUE, an icon is to be created. If it is FALSE, a cursor is to be
		///     created.
		/// </param>
		/// <param name="dwVer">
		///     The version number of the icon or cursor format for the resource bits pointed to by the <paramref name="presbits" /> parameter. The value must be
		///     greater than or equal to 0x00020000 and less than or equal to 0x00030000. This parameter is generally set to 0x00030000.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to the icon or cursor.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="CreateIconFromResource" />, <see cref="CreateIconFromResourceEx" />, <see cref="CreateIconIndirect" />,
		///         <see cref="GetIconInfo" />, <see cref="LookupIconIdFromDirectory" />, and <see cref="LookupIconIdFromDirectoryEx" /> functions allow shell
		///         applications and icon browsers to examine and use resources throughout the system.
		///     </para>
		///     <para>
		///         The <see cref="CreateIconFromResource" /> function calls <see cref="CreateIconFromResourceEx" /> passing LR_DEFAULTSIZE|LR_SHARED as flags.
		///     </para>
		///     <para>
		///         When you are finished using the icon, destroy it using the <see cref="DestroyIcon" /> function.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CreateIconFromResource")]
		public static extern IntPtr CreateIconFromResource([In] ref byte presbits, uint dwResSize, [MarshalAs(UnmanagedType.Bool)] bool fIcon, uint dwVer);

		/// <summary>
		///     Determines which, if any, of the child windows belonging to the specified parent window contains the specified point. The function can ignore
		///     invisible, disabled, and transparent child windows. The search is restricted to immediate child windows. Grandchildren and deeper descendants are
		///     not searched.
		/// </summary>
		/// <param name="hwndParent">A handle to the parent window.</param>
		/// <param name="pt">
		///     A structure that defines the client coordinates (relative to <paramref name="hwndParent" />) of the point to be checked.
		/// </param>
		/// <param name="uFlags">
		///     <para>The child windows to be skipped. This parameter can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>CWP_ALL 0x0000</term>
		///             <description>Does not skip any child windows</description>
		///         </item>
		///         <item>
		///             <term>CWP_SKIPDISABLED 0x0002</term>
		///             <description>Skips disabled child windows</description>
		///         </item>
		///         <item>
		///             <term>CWP_SKIPINVISIBLE 0x0001</term>
		///             <description>Skips invisible child windows</description>
		///         </item>
		///         <item>
		///             <term>CWP_SKIPTRANSPARENT 0x0004</term>
		///             <description>Skips transparent child windows</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>
		///         The return value is a handle to the first child window that contains the point and meets the criteria specified by <paramref name="uFlags" />
		///         . If the point is within the parent window but not within any child window that meets the criteria, the return value is a handle to the
		///         parent window. If the point lies outside the parent window or if the function fails, the return value is NULL.
		///     </para>
		/// </returns>
		/// <remarks>
		///     The system maintains an internal list that contains the handles of the child windows associated with a parent window. The order of the handles in
		///     the list depends on the Z order of the child windows. If more than one child window contains the specified point, the system returns a handle to
		///     the first window in the list that contains the point and meets the criteria specified by <paramref name="uFlags" />.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "ChildWindowFromPointEx")]
		public static extern IntPtr ChildWindowFromPointEx([In] IntPtr hwndParent, POINT pt, CWP uFlags);

		/// <summary>
		///     <para>
		///         The <see cref="ChangeDisplaySettings" /> function changes the settings of the default display device to the specified graphics mode.
		///     </para>
		///     <para>
		///         To change the settings of a specified display device, use the <see cref="ChangeDisplaySettingsEx" /> function.
		///     </para>
		///     <para>
		///         Note:  Apps that you design to target Windows 8 and later can no longer query or set display modes that are less than 32 bits per pixel
		///         (bpp); these operations will fail. These apps have a compatibility manifest that targets Windows 8. Windows 8 still supports 8-bit and 16-bit
		///         color modes for desktop apps that were built without a Windows 8 manifest; Windows 8 emulates these modes but still runs in 32-bit color
		///         mode.
		///     </para>
		/// </summary>
		/// <param name="lpDevMode">
		///     <para>
		///         A pointer to a <see cref="DEVMODE" /> structure that describes the new graphics mode. If <paramref name="lpDevMode" /> is NULL, all the
		///         values currently in the registry will be used for the display setting. Passing NULL for the <paramref name="lpDevMode" /> parameter and 0 for
		///         the <paramref name="dwflags" /> parameter is the easiest way to return to the default mode after a dynamic mode change.
		///     </para>
		///     <para>
		///         The <see cref="DEVMODE.dmSize" /> member of <see cref="DEVMODE" /> must be initialized to the size, in bytes, of the <see cref="DEVMODE" />
		///         structure. The <see cref="DEVMODE.dmDriverExtra" /> member of <see cref="DEVMODE" /> must be initialized to indicate the number of bytes of
		///         private driver data following the <see cref="DEVMODE" /> structure. In addition, you can use any or all of the following members of the
		///         <see cref="DEVMODE" /> structure.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>dmBitsPerPel</term>
		///             <description>Bits per pixel</description>
		///         </item>
		///         <item>
		///             <term>dmPelsWidth</term>
		///             <description>Pixel width</description>
		///         </item>
		///         <item>
		///             <term>dmPelsHeight</term>
		///             <description>Pixel height</description>
		///         </item>
		///         <item>
		///             <term>dmDisplayFlags</term>
		///             <description>Mode flags</description>
		///         </item>
		///         <item>
		///             <term>dmDisplayFrequency</term>
		///             <description>Mode frequency</description>
		///         </item>
		///         <item>
		///             <term>dmPosition</term>
		///             <description>Position of the device in a multi-monitor configuration.</description>
		///         </item>
		///     </list>
		///     <para>
		///         In addition to using one or more of the preceding <see cref="DEVMODE" /> members, you must also set one or more of the following values in
		///         the <see cref="DEVMODE.dmFields" /> member to change the display setting.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>DM_BITSPERPEL</term>
		///             <description>
		///                 Use the <see cref="DEVMODE.dmBitsPerPel" /> value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DM_PELSWIDTH</term>
		///             <description>
		///                 Use the <see cref="DEVMODE.dmPelsWidth" /> value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DM_PELSHEIGHT</term>
		///             <description>
		///                 Use the <see cref="DEVMODE.dmPelsHeight" /> value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DM_DISPLAYFLAGS</term>
		///             <description>
		///                 Use the dmDisplayFlags value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DM_DISPLAYFREQUENCY</term>
		///             <description>
		///                 Use the <see cref="DEVMODE.dmDisplayFrequency" /> value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DM_POSITION</term>
		///             <description>
		///                 Use the dmPosition value.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="dwflags">
		///     <para>Indicates how the graphics mode should be changed. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>0</term>
		///             <description>The graphics mode for the current screen will be changed dynamically.</description>
		///         </item>
		///         <item>
		///             <term>CDS_FULLSCREEN</term>
		///             <description>
		///                 <para>The mode is temporary in nature.</para>
		///                 <para>If you change to and from another desktop, this mode will not be reset.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>CDS_GLOBAL</term>
		///             <description>
		///                 The settings will be saved in the global settings area so that they will affect all users on the machine. Otherwise, only the
		///                 settings for the user are modified. This flag is only valid when specified with the CDS_UPDATEREGISTRY flag.
		///             </description>
		///         </item>
		///         <item>
		///             <term>CDS_NORESET</term>
		///             <description>
		///                 The settings will be saved in the registry, but will not take effect. This flag is only valid when specified with the
		///                 CDS_UPDATEREGISTRY flag.
		///             </description>
		///         </item>
		///         <item>
		///             <term>CDS_RESET</term>
		///             <description>The settings should be changed, even if the requested settings are the same as the current settings.</description>
		///         </item>
		///         <item>
		///             <term>CDS_SET_PRIMARY</term>
		///             <description>This device will become the primary device.</description>
		///         </item>
		///         <item>
		///             <term>CDS_TEST</term>
		///             <description>The system tests if the requested graphics mode could be set.</description>
		///         </item>
		///         <item>
		///             <term>CDS_UPDATEREGISTRY</term>
		///             <description>
		///                 The graphics mode for the current screen will be changed dynamically and the graphics mode will be updated in the registry. The mode
		///                 information is stored in the USER profile.
		///             </description>
		///         </item>
		///     </list>
		///     <para>
		///         Specifying CDS_TEST allows an application to determine which graphics modes are actually valid, without causing the system to change to that
		///         graphics mode.
		///     </para>
		///     <para>
		///         If CDS_UPDATEREGISTRY is specified and it is possible to change the graphics mode dynamically, the information is stored in the registry and
		///         DISP_CHANGE_SUCCESSFUL is returned. If it is not possible to change the graphics mode dynamically, the information is stored in the registry
		///         and DISP_CHANGE_RESTART is returned.
		///     </para>
		///     <para>
		///         If CDS_UPDATEREGISTRY is specified and the information could not be stored in the registry, the graphics mode is not changed and
		///         DISP_CHANGE_NOTUPDATED is returned.
		///     </para>
		/// </param>
		/// <returns>
		///     The <see cref="ChangeDisplaySettings" /> function returns one of the following values.
		/// </returns>
		/// <remarks>
		///     <para>
		///         To ensure that the <see cref="DEVMODE" /> structure passed to <see cref="ChangeDisplaySettings" /> is valid and contains only values
		///         supported by the display driver, use the <see cref="DEVMODE" /> returned by the <see cref="EnumDisplaySettings" /> function.
		///     </para>
		///     <para>
		///         When the display mode is changed dynamically, the <see cref="WM.WM_DISPLAYCHANGE" /> message is sent to all running applications with the
		///         following message parameters.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "ChangeDisplaySettings")]
		public static extern int ChangeDisplaySettings(ref DEVMODE lpDevMode, CDS dwflags);

		/// <summary>
		///     Sets the input locale identifier (formerly called the keyboard layout handle) for the calling thread or the current process. The input locale
		///     identifier specifies a locale as well as the physical layout of the keyboard.
		/// </summary>
		/// <param name="hkl">
		///     <para>Input locale identifier to be activated.</para>
		///     <para>
		///         The input locale identifier must have been loaded by a previous call to the <see cref="LoadKeyboardLayout" /> function. This parameter must
		///         be either the handle to a keyboard layout or one of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>HKL_NEXT 1</term>
		///             <description>Selects the next locale identifier in the circular list of loaded locale identifiers maintained by the system.</description>
		///         </item>
		///         <item>
		///             <term>HKL_PREV 0</term>
		///             <description>Selects the previous locale identifier in the circular list of loaded locale identifiers maintained by the system.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="Flags">
		///     <para>Specifies how the input locale identifier is to be activated. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>KLF_REORDER 0x00000008</term>
		///             <description>
		///                 <para>
		///                     If this bit is set, the system's circular list of loaded locale identifiers is reordered by moving the locale identifier to the
		///                     head of the list. If this bit is not set, the list is rotated without a change of order.
		///                 </para>
		///                 <para>
		///                     For example, if a user had an English locale identifier active, as well as having French, German, and Spanish locale identifiers
		///                     loaded (in that order), then activating the German locale identifier with the <see cref="KLF.KLF_REORDER" /> bit set would
		///                     produce the following order: German, English, French, Spanish. Activating the German locale identifier without the
		///                     <see cref="KLF.KLF_REORDER" /> bit set would produce the following order: German, Spanish, English, French.
		///                 </para>
		///                 <para>If less than three locale identifiers are loaded, the value of this flag is irrelevant.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>KLF_RESET 0x40000000</term>
		///             <description>
		///                 <para>
		///                     If set but <see cref="KLF.KLF_SHIFTLOCK" /> is not set, the Caps Lock state is turned off by pressing the Caps Lock key again. If
		///                     set and <see cref="KLF.KLF_SHIFTLOCK" /> is also set, the Caps Lock state is turned off by pressing either SHIFT key.
		///                 </para>
		///                 <para>These two methods are mutually exclusive, and the setting persists as part of the User's profile in the registry.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>KLF_SETFORPROCESS 0x00000100</term>
		///             <description>
		///                 Activates the specified locale identifier for the entire process and sends the <see cref="WM.WM_INPUTLANGCHANGE" /> message to the
		///                 current thread's focus or active window.
		///             </description>
		///         </item>
		///         <item>
		///             <term>KLF_SHIFTLOCK 0x00010000</term>
		///             <description>
		///                 This is used with <see cref="KLF.KLF_RESET" />. See <see cref="KLF.KLF_RESET" /> for an explanation.
		///             </description>
		///         </item>
		///         <item>
		///             <term>KLF_UNLOADPREVIOUS</term>
		///             <description>
		///                 This flag is unsupported. Use the <see cref="UnloadKeyboardLayout" /> function instead.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>
		///         The return value is of type HKL. If the function succeeds, the return value is the previous input locale identifier.
		///         Otherwise, it is zero.
		///     </para>
		///     <para>To get extended error information, use the GetLastError function.</para>
		/// </returns>
		/// <remarks>
		///     <para>This function only affects the layout for the current process or thread.</para>
		///     <para>
		///         This function is not restricted to keyboard layouts. The <paramref name="hkl" /> parameter is actually an input locale identifier. This is a
		///         broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input Method Editor (IME), or any other
		///         form of input. Several input locale identifiers can be loaded at any one time, but only one is active at a time. Loading multiple input
		///         locale identifiers makes it possible to rapidly switch between them.
		///     </para>
		///     <para>
		///         When multiple IMEs are allowed for each locale, passing an input locale identifier in which the high word (the device handle) is zero
		///         activates the first IME in the list belonging to the locale.
		///     </para>
		///     <para>
		///         The <see cref="KLF.KLF_RESET" /> and <see cref="KLF.KLF_SHIFTLOCK" /> flags alter the method by which the Caps Lock state is turned off. By
		///         default, the Caps Lock state is turned off by hitting the Caps Lock key again. If only <see cref="KLF.KLF_RESET" /> is set, the default state
		///         is reestablished. If <see cref="KLF.KLF_RESET" /> and <see cref="KLF.KLF_SHIFTLOCK" /> are set, the Caps Lock state is turned off by pressing
		///         either Caps Lock key. This feature is used to conform to local keyboard behavior standards as well as for personal preferences.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "ActivateKeyboardLayout")]
		public static extern IntPtr ActivateKeyboardLayout([In] IntPtr hkl, KLF Flags);

		/// <summary>
		///     Grants or denies access to a handle to a User object to a job that has a user-interface restriction. When access is granted, all processes
		///     associated with the job can subsequently recognize and use the handle. When access is denied, the processes can no longer use the handle. For
		///     more information see User Objects.
		/// </summary>
		/// <param name="hUserHandle">A handle to the User object.</param>
		/// <param name="hJob">
		///     A handle to the job to be granted access to the User handle. The CreateJobObject or OpenJobObject function returns
		///     this handle.
		/// </param>
		/// <param name="bGrant">
		///     If this parameter is TRUE, all processes associated with the job can recognize and use the handle. If the parameter is FALSE, the processes
		///     cannot use the handle.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="UserHandleGrantAccess" /> function can be called only from a process not associated with the job specified by the
		///         <paramref name="hJob" /> parameter. The User handle must not be owned by a process or thread associated with the job.
		///     </para>
		///     <para>
		///         To create user-interface restrictions, call the SetInformationJobObject function with the JobObjectBasicUIRestrictions job
		///         information class.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "UserHandleGrantAccess")]
		public static extern bool UserHandleGrantAccess([In] IntPtr hUserHandle, [In] IntPtr hJob, [MarshalAs(UnmanagedType.Bool)] bool bGrant);

		/// <summary>
		///     Processes accelerator keys for menu commands. The function translates a <see cref="WM.WM_KEYDOWN" /> or <see cref="WM.WM_SYSKEYDOWN" /> message
		///     to a
		///     <see cref="WM.WM_COMMAND" /> or <see cref="WM.WM_SYSCOMMAND" /> message (if there is an entry for the key in the specified accelerator table) and
		///     then sends the <see cref="WM.WM_COMMAND" /> or <see cref="WM.WM_SYSCOMMAND" /> message directly to the specified window procedure.
		///     <see cref="TranslateAccelerator" /> does not return until the window procedure has processed the message.
		/// </summary>
		/// <param name="hWnd">A handle to the window whose messages are to be translated.</param>
		/// <param name="hAccTable">
		///     A handle to the accelerator table. The accelerator table must have been loaded by a call to the <see cref="LoadAccelerators" /> function or
		///     created by a call to the <see cref="CreateAcceleratorTable" /> function.
		/// </param>
		/// <param name="lpMsg">
		///     A pointer to an <see cref="MSG" /> structure that contains message information retrieved from the calling thread's message queue using the
		///     <see cref="GetMessage" /> or <see cref="PeekMessage" /> function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         To differentiate the message that this function sends from messages sent by menus or controls, the high-order word of the wParam parameter of
		///         the <see cref="WM.WM_COMMAND" /> or <see cref="WM.WM_SYSCOMMAND" /> message contains the value 1.
		///     </para>
		///     <para>
		///         Accelerator key combinations used to select items from the window menu are translated into <see cref="WM.WM_SYSCOMMAND" />
		///         messages; all other accelerator key combinations are translated into <see cref="WM.WM_COMMAND" /> messages.
		///     </para>
		///     <para>
		///         When <see cref="TranslateAccelerator" /> returns a nonzero value and the message is translated, the application should not use the
		///         <see cref="TranslateMessage" /> function to process the message again.
		///     </para>
		///     <para>An accelerator need not correspond to a menu command.</para>
		///     <para>
		///         If the accelerator command corresponds to a menu item, the application is sent <see cref="WM.WM_INITMENU" /> and
		///         <see cref="WM.WM_INITMENUPOPUP" />
		///         messages, as if the user were trying to display the menu. However, these messages are not sent if any of the following conditions exist:
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "TranslateAccelerator")]
		public static extern int TranslateAccelerator([In] IntPtr hWnd, [In] IntPtr hAccTable, [In] ref MSG lpMsg);

		/// <summary>Retrieves or sets the value of one of the system-wide parameters. This function can also update the user profile while setting a parameter.</summary>
		/// <param name="uiAction">
		///     <para>The system-wide parameter to be retrieved or set. The possible values are organized in the following tables of related parameters:</para>
		///     <para>The following are the accessibility parameters.</para>
		///     <list type="table">
		///         <item>
		///             <term>SPI_GETACCESSTIMEOUT 0x003C</term>
		///             <description>
		///                 Retrieves information about the time-out period associated with the accessibility features. The <paramref name="pvParam" /> parameter
		///                 must point to an <see cref="ACCESSTIMEOUT" /> structure that receives the information. Set the <see cref="ACCESSTIMEOUT.cbSize" /> member of this
		///                 structure and the <paramref name="uiParam" /> parameter to sizeof(ACCESSTIMEOUT).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETAUDIODESCRIPTION 0x0074</term>
		///             <description>
		///                 <para>
		///                     Determines whether audio descriptions are enabled or disabled. The <paramref name="pvParam" /> parameter is a pointer to an
		///                     <see cref="AUDIODESCRIPTION" /> structure. Set the <see cref="AUDIODESCRIPTION.cbSize" /> member of this structure and the
		///                     <paramref name="uiParam" /> parameter to sizeof(AUDIODESCRIPTION).
		///                 </para>
		///                 <para>
		///                     While it is possible for users who have visual impairments to hear the audio in video content, there is a lot of action in video
		///                     that does not have corresponding audio. Specific audio description of what is happening in a video helps these users understand
		///                     the content better. This flag enables you to determine whether audio descriptions have been enabled and in which language.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETCLIENTAREAANIMATION 0x1042</term>
		///             <description>
		///                 <para>
		///                     Determines whether animations are enabled or disabled. The <paramref name="pvParam" /> parameter must point to a
		///                     BOOL variable that receives TRUE if animations are enabled, or FALSE otherwise.
		///                 </para>
		///                 <para>
		///                     Display features such as flashing, blinking, flickering, and moving content can cause seizures in users with photo-sensitive
		///                     epilepsy. This flag enables you to determine whether such animations have been disabled in the client area.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETDISABLEOVERLAPPEDCONTENT 0x1040</term>
		///             <description>
		///                 <para>
		///                     Determines whether overlapped content is enabled or disabled. The <paramref name="pvParam" /> parameter must point to a
		///                     BOOL variable that receives TRUE if enabled, or FALSE otherwise.
		///                 </para>
		///                 <para>
		///                     Display features such as background images, textured backgrounds, water marks on documents, alpha blending, and transparency can
		///                     reduce the contrast between the foreground and background, making it harder for users with low vision to see objects on the
		///                     screen. This flag enables you to determine whether such overlapped content has been disabled.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETFILTERKEYS 0x0032</term>
		///             <description>
		///                 Retrieves information about the FilterKeys accessibility feature. The <paramref name="pvParam" /> parameter must point to a
		///                 <see cref="FILTERKEYS" /> structure that receives the information. Set the <see cref="FILTERKEYS.cbSize" /> member of this structure and the
		///                 <paramref name="uiParam" /> parameter to sizeof(FILTERKEYS).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETFOCUSBORDERHEIGHT 0x2010</term>
		///             <description>
		///                 <para>
		///                     Retrieves the height, in pixels, of the top and bottom edges of the focus rectangle drawn with <see cref="DrawFocusRect" />. The
		///                     <paramref name="pvParam" /> parameter must point to a UINT value.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETFOCUSBORDERWIDTH 0x200E</term>
		///             <description>
		///                 <para>
		///                     Retrieves the width, in pixels, of the left and right edges of the focus rectangle drawn with <see cref="DrawFocusRect" />. The
		///                     <paramref name="pvParam" /> parameter must point to a UINT.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETHIGHCONTRAST 0x0042</term>
		///             <description>
		///                 <para>
		///                     Retrieves information about the HighContrast accessibility feature. The <paramref name="pvParam" /> parameter must point to a
		///                     <see cref="HIGHCONTRAST" /> structure that receives the information. Set the <see cref="HIGHCONTRAST.cbSize" /> member of this structure and
		///                     the <paramref name="uiParam" /> parameter to sizeof(HIGHCONTRAST).
		///                 </para>
		///                 <para>For a general discussion, see Remarks.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMESSAGEDURATION 0x2016</term>
		///             <description>
		///                 <para>
		///                     Retrieves the time that notification pop-ups should be displayed, in seconds. The <paramref name="pvParam" /> parameter must
		///                     point to a ULONG that receives the message duration.
		///                 </para>
		///                 <para>
		///                     Users with visual impairments or cognitive conditions such as ADHD and dyslexia might need a longer time to read the text in
		///                     notification messages. This flag enables you to retrieve the message duration.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMOUSECLICKLOCK 0x101E</term>
		///             <description>
		///                 <para>
		///                     Retrieves the state of the Mouse ClickLock feature. The <paramref name="pvParam" /> parameter must point to a BOOL
		///                     variable that receives TRUE if enabled, or FALSE otherwise. For more information, see About Mouse Input.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMOUSECLICKLOCKTIME 0x2008</term>
		///             <description>
		///                 <para>
		///                     Retrieves the time delay before the primary mouse button is locked. The <paramref name="pvParam" /> parameter must point to
		///                     DWORD that receives the time delay, in milliseconds. This is only enabled if <see cref="SPI.SPI_SETMOUSECLICKLOCK" />
		///                     is set to TRUE. For more information, see About Mouse Input.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMOUSEKEYS 0x0036</term>
		///             <description>
		///                 Retrieves information about the MouseKeys accessibility feature. The <paramref name="pvParam" /> parameter must point to a
		///                 <see cref="MOUSEKEYS" /> structure that receives the information. Set the <see cref="MOUSEKEYS.cbSize" /> member of this structure and the
		///                 <paramref name="uiParam" /> parameter to sizeof(MOUSEKEYS).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMOUSESONAR 0x101C</term>
		///             <description>
		///                 <para>
		///                     Retrieves the state of the Mouse Sonar feature. The <paramref name="pvParam" /> parameter must point to a BOOL
		///                     variable that receives TRUE if enabled or FALSE otherwise. For more information, see About Mouse Input.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMOUSEVANISH 0x1020</term>
		///             <description>
		///                 <para>
		///                     Retrieves the state of the Mouse Vanish feature. The <paramref name="pvParam" /> parameter must point to a BOOL
		///                     variable that receives TRUE if enabled or FALSE otherwise. For more information, see About Mouse Input.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETSCREENREADER 0x0046</term>
		///             <description>
		///                 <para>
		///                     Determines whether a screen reviewer utility is running. A screen reviewer utility directs textual information to an output
		///                     device, such as a speech synthesizer or Braille display. When this flag is set, an application should provide textual information
		///                     in situations where it would otherwise present the information graphically.
		///                 </para>
		///                 <para>
		///                     The <paramref name="pvParam" /> parameter is a pointer to a BOOL variable that receives TRUE if a screen reviewer
		///                     utility is running, or FALSE otherwise.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETSERIALKEYS 0x003E</term>
		///             <description>
		///                 <para>This parameter is not supported.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETSHOWSOUNDS 0x0038</term>
		///             <description>
		///                 <para>
		///                     Determines whether the Show Sounds accessibility flag is on or off. If it is on, the user requires an application to present
		///                     information visually in situations where it would otherwise present the information only in audible form. The
		///                     <paramref name="pvParam" /> parameter must point to a BOOL variable that receives TRUE if the feature is on, or
		///                     FALSE if it is off.
		///                 </para>
		///                 <para>
		///                     Using this value is equivalent to calling <see cref="GetSystemMetrics" /> with <see cref="SM.SM_SHOWSOUNDS" />. That is the
		///                     recommended call.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETSOUNDSENTRY 0x0040</term>
		///             <description>
		///                 Retrieves information about the SoundSentry accessibility feature. The <paramref name="pvParam" /> parameter must point to a
		///                 <see cref="SOUNDSENTRY" /> structure that receives the information. Set the <see cref="SOUNDSENTRY.cbSize" /> member of this structure and the
		///                 <paramref name="uiParam" /> parameter to sizeof(SOUNDSENTRY).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETSTICKYKEYS 0x003A</term>
		///             <description>
		///                 Retrieves information about the StickyKeys accessibility feature. The <paramref name="pvParam" /> parameter must point to a
		///                 <see cref="STICKYKEYS" /> structure that receives the information. Set the <see cref="STICKYKEYS.cbSize" /> member of this structure and the
		///                 <paramref name="uiParam" /> parameter to sizeof(STICKYKEYS).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETTOGGLEKEYS 0x0034</term>
		///             <description>
		///                 Retrieves information about the ToggleKeys accessibility feature. The <paramref name="pvParam" /> parameter must point to a
		///                 <see cref="TOGGLEKEYS" /> structure that receives the information. Set the <see cref="TOGGLEKEYS.cbSize" /> member of this structure and the
		///                 <paramref name="uiParam" /> parameter to sizeof(TOGGLEKEYS).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETACCESSTIMEOUT 0x003D</term>
		///             <description>
		///                 Sets the time-out period associated with the accessibility features. The <paramref name="pvParam" /> parameter must point to an
		///                 <see cref="ACCESSTIMEOUT" /> structure that contains the new parameters. Set the <see cref="ACCESSTIMEOUT.cbSize" /> member of this structure and
		///                 the <paramref name="uiParam" /> parameter to sizeof(ACCESSTIMEOUT).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETAUDIODESCRIPTION 0x0075</term>
		///             <description>
		///                 <para>
		///                     Turns the audio descriptions feature on or off. The <paramref name="pvParam" /> parameter is a pointer to an
		///                     <see cref="AUDIODESCRIPTION" /> structure.
		///                 </para>
		///                 <para>
		///                     While it is possible for users who are visually impaired to hear the audio in video content, there is a lot of action in video
		///                     that does not have corresponding audio. Specific audio description of what is happening in a video helps these users understand
		///                     the content better. This flag enables you to enable or disable audio descriptions in the languages they are provided in.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETCLIENTAREAANIMATION 0x1043</term>
		///             <description>
		///                 <para>
		///                     Turns client area animations on or off. The <paramref name="pvParam" /> parameter is a BOOL variable. Set
		///                     <paramref name="pvParam" /> to TRUE to enable animations and other transient effects in the client area, or FALSE to disable
		///                     them.
		///                 </para>
		///                 <para>
		///                     Display features such as flashing, blinking, flickering, and moving content can cause seizures in users with photo-sensitive
		///                     epilepsy. This flag enables you to enable or disable all such animations.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETDISABLEOVERLAPPEDCONTENT 0x1041</term>
		///             <description>
		///                 <para>
		///                     Turns overlapped content (such as background images and watermarks) on or off. The <paramref name="pvParam" /> parameter is a
		///                     BOOL variable. Set <paramref name="pvParam" /> to TRUE to disable overlapped content, or FALSE to enable
		///                     overlapped content.
		///                 </para>
		///                 <para>
		///                     Display features such as background images, textured backgrounds, water marks on documents, alpha blending, and transparency can
		///                     reduce the contrast between the foreground and background, making it harder for users with low vision to see objects on the
		///                     screen. This flag enables you to enable or disable all such overlapped content.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETFILTERKEYS 0x0033</term>
		///             <description>
		///                 Sets the parameters of the FilterKeys accessibility feature. The <paramref name="pvParam" /> parameter must point to a
		///                 <see cref="FILTERKEYS" /> structure that contains the new parameters. Set the <see cref="FILTERKEYS.cbSize" /> member of this structure and the
		///                 <paramref name="uiParam" /> parameter to sizeof(FILTERKEYS).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETFOCUSBORDERHEIGHT 0x2011</term>
		///             <description>
		///                 <para>
		///                     Sets the height of the top and bottom edges of the focus rectangle drawn with <see cref="DrawFocusRect" /> to the value of the
		///                     <paramref name="pvParam" /> parameter.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETFOCUSBORDERWIDTH 0x200F</term>
		///             <description>
		///                 <para>
		///                     Sets the height of the left and right edges of the focus rectangle drawn with <see cref="DrawFocusRect" /> to the value of the
		///                     <paramref name="pvParam" /> parameter.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETHIGHCONTRAST 0x0043</term>
		///             <description>
		///                 Sets the parameters of the HighContrast accessibility feature. The <paramref name="pvParam" /> parameter must point to a
		///                 <see cref="HIGHCONTRAST" /> structure that contains the new parameters. Set the <see cref="HIGHCONTRAST.cbSize" /> member of this structure and
		///                 the <paramref name="uiParam" /> parameter to sizeof(HIGHCONTRAST).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMESSAGEDURATION 0x2017</term>
		///             <description>
		///                 <para>
		///                     Sets the time that notification pop-ups should be displayed, in seconds. The <paramref name="pvParam" /> parameter specifies the
		///                     message duration.
		///                 </para>
		///                 <para>
		///                     Users with visual impairments or cognitive conditions such as ADHD and dyslexia might need a longer time to read the text in
		///                     notification messages. This flag enables you to set the message duration.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMOUSECLICKLOCK 0x101F</term>
		///             <description>
		///                 <para>
		///                     Turns the Mouse ClickLock accessibility feature on or off. This feature temporarily locks down the primary mouse button when that
		///                     button is clicked and held down for the time specified by <see cref="SPI.SPI_SETMOUSECLICKLOCKTIME" />. The
		///                     <paramref name="pvParam" /> parameter specifies TRUE for on, or FALSE for off. The default is off. For more information, see
		///                     Remarks and AboutMouse Input.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMOUSECLICKLOCKTIME 0x2009</term>
		///             <description>
		///                 <para>
		///                     Adjusts the time delay before the primary mouse button is locked. The <paramref name="uiParam" /> parameter should be set to 0.
		///                     The <paramref name="pvParam" /> parameter points to a DWORD that specifies the time delay in milliseconds. For
		///                     example, specify 1000 for a 1 second delay. The default is 1200. For more information, see About Mouse Input.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMOUSEKEYS 0x0037</term>
		///             <description>
		///                 Sets the parameters of the MouseKeys accessibility feature. The <paramref name="pvParam" /> parameter must point to a
		///                 <see cref="MOUSEKEYS" /> structure that contains the new parameters. Set the <see cref="MOUSEKEYS.cbSize" /> member of this structure and the
		///                 <paramref name="uiParam" /> parameter to sizeof(MOUSEKEYS).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMOUSESONAR 0x101D</term>
		///             <description>
		///                 <para>
		///                     Turns the Sonar accessibility feature on or off. This feature briefly shows several concentric circles around the mouse pointer
		///                     when the user presses and releases the CTRL key. The <paramref name="pvParam" /> parameter specifies TRUE for on and FALSE for
		///                     off. The default is off. For more information, see About Mouse Input.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMOUSEVANISH 0x1021</term>
		///             <description>
		///                 <para>
		///                     Turns the Vanish feature on or off. This feature hides the mouse pointer when the user types; the pointer reappears when the user
		///                     moves the mouse. The <paramref name="pvParam" /> parameter specifies TRUE for on and FALSE for off. The default is off. For more
		///                     information, see About Mouse Input.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETSCREENREADER 0x0047</term>
		///             <description>
		///                 Determines whether a screen review utility is running. The <paramref name="uiParam" /> parameter specifies TRUE for on, or FALSE for
		///                 off.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETSERIALKEYS 0x003F</term>
		///             <description>
		///                 <para>This parameter is not supported.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETSHOWSOUNDS 0x0039</term>
		///             <description>
		///                 Turns the ShowSounds accessibility feature on or off. The <paramref name="uiParam" /> parameter specifies TRUE for on, or FALSE for
		///                 off.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETSOUNDSENTRY 0x0041</term>
		///             <description>
		///                 Sets the parameters of the SoundSentry accessibility feature. The <paramref name="pvParam" /> parameter must point to
		///                 a <see cref="SOUNDSENTRY" /> structure that contains the new parameters. Set the <see cref="SOUNDSENTRY.cbSize" /> member of this structure and
		///                 the <paramref name="uiParam" /> parameter to sizeof(SOUNDSENTRY).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETSTICKYKEYS 0x003B</term>
		///             <description>
		///                 Sets the parameters of the StickyKeys accessibility feature. The <paramref name="pvParam" /> parameter must point to a
		///                 <see cref="STICKYKEYS" /> structure that contains the new parameters. Set the <see cref="STICKYKEYS.cbSize" /> member of this structure and the
		///                 <paramref name="uiParam" /> parameter to sizeof(STICKYKEYS).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETTOGGLEKEYS 0x0035</term>
		///             <description>
		///                 Sets the parameters of the ToggleKeys accessibility feature. The <paramref name="pvParam" /> parameter must point to a
		///                 <see cref="TOGGLEKEYS" /> structure that contains the new parameters. Set the <see cref="TOGGLEKEYS.cbSize" /> member of this structure and the
		///                 <paramref name="uiParam" /> parameter to sizeof(TOGGLEKEYS).
		///             </description>
		///         </item>
		///     </list>
		///     <para>The following are the desktop parameters.</para>
		///     <list type="table">
		///         <item>
		///             <term>SPI_GETCLEARTYPE 0x1048</term>
		///             <description>
		///                 <para>
		///                     Determines whether ClearType is enabled. The <paramref name="pvParam" /> parameter must point to a BOOL variable
		///                     that receives TRUE if ClearType is enabled, or FALSE otherwise.
		///                 </para>
		///                 <para>ClearType is a software technology that improves the readability of text on liquid crystal display (LCD) monitors.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETDESKWALLPAPER 0x0073</term>
		///             <description>
		///                 Retrieves the full path of the bitmap file for the desktop wallpaper. The <paramref name="pvParam" /> parameter must point to a
		///                 buffer to receive the null-terminated path string. Set the <paramref name="uiParam" /> parameter to the size, in characters, of the
		///                 <paramref name="pvParam" /> buffer. The returned string will not exceed MAX_PATH characters. If there is no desktop
		///                 wallpaper, the returned string is empty.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETDROPSHADOW 0x1024</term>
		///             <description>
		///                 <para>
		///                     Determines whether the drop shadow effect is enabled. The <paramref name="pvParam" /> parameter must point to a
		///                     BOOL variable that returns TRUE if enabled or FALSE if disabled.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETFLATMENU 0x1022</term>
		///             <description>
		///                 <para>
		///                     Determines whether native User menus have flat menu appearance. The <paramref name="pvParam" /> parameter must point to a
		///                     BOOL variable that returns TRUE if the flat menu appearance is set, or FALSE otherwise.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETFONTSMOOTHING 0x004A</term>
		///             <description>
		///                 <para>
		///                     Determines whether the font smoothing feature is enabled. This feature uses font antialiasing to make font curves appear smoother
		///                     by painting pixels at different gray levels.
		///                 </para>
		///                 <para>
		///                     The <paramref name="pvParam" /> parameter must point to a BOOL variable that receives TRUE if the feature is
		///                     enabled, or FALSE if it is not.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETFONTSMOOTHINGCONTRAST 0x200C</term>
		///             <description>
		///                 <para>
		///                     Retrieves a contrast value that is used in "ClearType smoothing. The <paramref name="pvParam" /> parameter must
		///                     point to a UINT that receives the information. Valid contrast values are from 1000 to 2200. The default value is
		///                     1400.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETFONTSMOOTHINGORIENTATION 0x2012</term>
		///             <description>
		///                 <para>
		///                     Retrieves the font smoothing orientation. The <paramref name="pvParam" /> parameter must point to a UINT that
		///                     receives the information. The possible values are <see cref="FE.FE_FONTSMOOTHINGORIENTATIONBGR" /> (blue-green-red) and
		///                     <see cref="FE.FE_FONTSMOOTHINGORIENTATIONRGB" /> (red-green-blue).
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETFONTSMOOTHINGTYPE 0x200A</term>
		///             <description>
		///                 <para>
		///                     Retrieves the type of font smoothing. The <paramref name="pvParam" /> parameter must point to a UINT that receives
		///                     the information. The possible values are <see cref="FE.FE_FONTSMOOTHINGSTANDARD" /> and <see cref="FE.FE_FONTSMOOTHINGCLEARTYPE" />.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETWORKAREA 0x0030</term>
		///             <description>
		///                 <para>
		///                     Retrieves the size of the work area on the primary display monitor. The work area is the portion of the screen not obscured by
		///                     the system taskbar or by application desktop toolbars. The <paramref name="pvParam" /> parameter must point to a
		///                     <see cref="RECT" /> structure that receives the coordinates of the work area, expressed in virtual screen coordinates.
		///                 </para>
		///                 <para>
		///                     To get the work area of a monitor other than the primary display monitor, call the <see cref="GetMonitorInfo" /> function.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETCLEARTYPE 0x1049</term>
		///             <description>
		///                 <para>
		///                     Turns ClearType on or off. The <paramref name="pvParam" /> parameter is a BOOL variable. Set
		///                     <paramref name="pvParam" /> to TRUE to enable ClearType, or FALSE to disable it.
		///                 </para>
		///                 <para>ClearType is a software technology that improves the readability of text on LCD monitors.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETCURSORS 0x0057</term>
		///             <description>
		///                 Reloads the system cursors. Set the <paramref name="uiParam" /> parameter to zero and the <paramref name="pvParam" /> parameter to
		///                 NULL.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETDESKPATTERN 0x0015</term>
		///             <description>
		///                 Sets the current desktop pattern by causing Windows to read the Pattern= setting from the WIN.INI file.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETDESKWALLPAPER 0x0014</term>
		///             <description>
		///                 <para>
		///                     Note:  When the <see cref="SPI.SPI_SETDESKWALLPAPER" /> flag is used, <see cref="SystemParametersInfo" /> always
		///                     returns TRUE.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETDROPSHADOW 0x1025</term>
		///             <description>
		///                 <para>
		///                     Enables or disables the drop shadow effect. Set <paramref name="pvParam" /> to TRUE to enable the drop shadow effect or FALSE to
		///                     disable it. You must also have <see cref="CS.CS_DROPSHADOW" /> in the window class style.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETFLATMENU 0x1023</term>
		///             <description>
		///                 <para>
		///                     Enables or disables flat menu appearance for native User menus. Set <paramref name="pvParam" /> to TRUE to enable flat menu
		///                     appearance or FALSE to disable it.
		///                 </para>
		///                 <para>
		///                     When enabled, the menu bar uses <see cref="COLOR.COLOR_MENUBAR" /> for the menubar background, <see cref="COLOR.COLOR_MENU" /> for the
		///                     menu-popup background, <see cref="COLOR.COLOR_MENUHILIGHT" /> for the fill of the current menu selection, and
		///                     <see cref="COLOR.COLOR_HIGHLIGHT" /> for the outline of the current menu selection. If disabled, menus are drawn using the same metrics
		///                     and colors as in Windows 2000.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETFONTSMOOTHING 0x004B</term>
		///             <description>
		///                 <para>
		///                     Enables or disables the font smoothing feature, which uses font antialiasing to make font curves appear smoother by painting
		///                     pixels at different gray levels.
		///                 </para>
		///                 <para>
		///                     To enable the feature, set the <paramref name="uiParam" /> parameter to TRUE. To disable the feature, set
		///                     <paramref name="uiParam" /> to FALSE.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETFONTSMOOTHINGCONTRAST 0x200D</term>
		///             <description>
		///                 <para>
		///                     Sets the contrast value used in ClearType smoothing. The <paramref name="pvParam" /> parameter is the contrast
		///                     value. Valid contrast values are from 1000 to 2200. The default value is 1400.
		///                 </para>
		///                 <para>
		///                     <see cref="SPI.SPI_SETFONTSMOOTHINGTYPE" /> must also be set to <see cref="FE.FE_FONTSMOOTHINGCLEARTYPE" />.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETFONTSMOOTHINGORIENTATION 0x2013</term>
		///             <description>
		///                 <para>
		///                     Sets the font smoothing orientation. The <paramref name="pvParam" /> parameter is either
		///                     <see cref="FE.FE_FONTSMOOTHINGORIENTATIONBGR" /> (blue-green-red) or <see cref="FE.FE_FONTSMOOTHINGORIENTATIONRGB" /> (red-green-blue).
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETFONTSMOOTHINGTYPE 0x200B</term>
		///             <description>
		///                 <para>
		///                     Sets the font smoothing type. The <paramref name="pvParam" /> parameter is either <see cref="FE.FE_FONTSMOOTHINGSTANDARD" />, if
		///                     standard anti-aliasing is used, or <see cref="FE.FE_FONTSMOOTHINGCLEARTYPE" />, if ClearType is used. The default is
		///                     <see cref="FE.FE_FONTSMOOTHINGSTANDARD" />.
		///                 </para>
		///                 <para>
		///                     <see cref="SPI.SPI_SETFONTSMOOTHING" /> must also be set.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETWORKAREA 0x002F</term>
		///             <description>
		///                 Sets the size of the work area. The work area is the portion of the screen not obscured by the system taskbar or by application
		///                 desktop toolbars. The <paramref name="pvParam" /> parameter is a pointer to a <see cref="RECT" /> structure that specifies the new
		///                 work area rectangle, expressed in virtual screen coordinates. In a system with multiple display monitors, the function sets the work
		///                 area of the monitor that contains the specified rectangle.
		///             </description>
		///         </item>
		///     </list>
		///     <para>The following are the icon parameters.</para>
		///     <list type="table">
		///         <item>
		///             <term>SPI_GETICONMETRICS 0x002D</term>
		///             <description>
		///                 Retrieves the metrics associated with icons. The <paramref name="pvParam" /> parameter must point to an <see cref="ICONMETRICS" />
		///                 structure that receives the information. Set the <see cref="ICONMETRICS.cbSize" /> member of this structure and the <paramref name="uiParam" />
		///                 parameter to sizeof(ICONMETRICS).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETICONTITLELOGFONT 0x001F</term>
		///             <description>
		///                 Retrieves the logical font information for the current icon-title font. The <paramref name="uiParam" /> parameter specifies the size
		///                 of a <see cref="LOGFONT" /> structure, and the <paramref name="pvParam" /> parameter must point to the <see cref="LOGFONT" />
		///                 structure to fill in.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETICONTITLEWRAP 0x0019</term>
		///             <description>
		///                 Determines whether icon-title wrapping is enabled. The <paramref name="pvParam" /> parameter must point to a BOOL
		///                 variable that receives TRUE if enabled, or FALSE otherwise.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_ICONHORIZONTALSPACING 0x000D</term>
		///             <description>
		///                 <para>Sets or retrieves the width, in pixels, of an icon cell. The system uses this rectangle to arrange icons in large icon view.</para>
		///                 <para>
		///                     To set this value, set <paramref name="uiParam" /> to the new value and set <paramref name="pvParam" /> to NULL. You cannot set
		///                     this value to less than <see cref="SM.SM_CXICON" />.
		///                 </para>
		///                 <para>
		///                     To retrieve this value, <paramref name="pvParam" /> must point to an integer that receives the current value.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_ICONVERTICALSPACING 0x0018</term>
		///             <description>
		///                 <para>Sets or retrieves the height, in pixels, of an icon cell.</para>
		///                 <para>
		///                     To set this value, set <paramref name="uiParam" /> to the new value and set <paramref name="pvParam" /> to NULL. You cannot set
		///                     this value to less than <see cref="SM.SM_CYICON" />.
		///                 </para>
		///                 <para>
		///                     To retrieve this value, <paramref name="pvParam" /> must point to an integer that receives the current value.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETICONMETRICS 0x002E</term>
		///             <description>
		///                 Sets the metrics associated with icons. The <paramref name="pvParam" /> parameter must point to an <see cref="ICONMETRICS" />
		///                 structure that contains the new parameters. Set the <see cref="ICONMETRICS.cbSize" /> member of this structure and the
		///                 <paramref name="uiParam" /> parameter to sizeof(ICONMETRICS).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETICONS 0x0058</term>
		///             <description>
		///                 Reloads the system icons. Set the <paramref name="uiParam" /> parameter to zero and the <paramref name="pvParam" /> parameter to
		///                 NULL.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETICONTITLELOGFONT 0x0022</term>
		///             <description>
		///                 Sets the font that is used for icon titles. The <paramref name="uiParam" /> parameter specifies the size of a <see cref="LOGFONT" />
		///                 structure, and the <paramref name="pvParam" /> parameter must point to a <see cref="LOGFONT" /> structure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETICONTITLEWRAP 0x001A</term>
		///             <description>
		///                 Turns icon-title wrapping on or off. The <paramref name="uiParam" /> parameter specifies TRUE for on, or FALSE for off.
		///             </description>
		///         </item>
		///     </list>
		///     <para>The following are the input parameters. They include parameters related to the keyboard, mouse, input language, and the warning beeper.</para>
		///     <list type="table">
		///         <item>
		///             <term>SPI_GETBEEP 0x0001</term>
		///             <description>
		///                 <para>Determines whether the warning beeper is on.</para>
		///                 <para>
		///                     The <paramref name="pvParam" /> parameter must point to a BOOL variable that receives TRUE if the beeper is on, or
		///                     FALSE if it is off.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETBLOCKSENDINPUTRESETS 0x1026</term>
		///             <description>
		///                 Retrieves a BOOL indicating whether an application can reset the screensaver's timer by calling the
		///                 <see cref="SendInput" /> function to simulate keyboard or mouse input. The <paramref name="pvParam" /> parameter must point to a
		///                 BOOL variable that receives TRUE if the simulated input will be blocked, or FALSE otherwise.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETCONTACTVISUALIZATION 0x2018</term>
		///             <description>
		///                 Retrieves the current contact visualization setting. The <paramref name="pvParam" /> parameter must point to a ULONG
		///                 variable that receives the setting. For more information, see Contact Visualization.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETDEFAULTINPUTLANG 0x0059</term>
		///             <description>
		///                 Retrieves the input locale identifier for the system default input language. The <paramref name="pvParam" /> parameter must point to
		///                 an <see cref="HKL" /> variable that receives this value. For more information, see Languages, Locales, and Keyboard Layouts.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETGESTUREVISUALIZATION 0x201A</term>
		///             <description>
		///                 Retrieves the current gesture visualization setting. The <paramref name="pvParam" /> parameter must point to a ULONG
		///                 variable that receives the setting. For more information, see Gesture Visualization.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETKEYBOARDCUES 0x100A</term>
		///             <description>
		///                 Determines whether menu access keys are always underlined. The <paramref name="pvParam" /> parameter must point to a
		///                 BOOL variable that receives TRUE if menu access keys are always underlined, and FALSE if they are underlined only when
		///                 the menu is activated by the keyboard.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETKEYBOARDDELAY 0x0016</term>
		///             <description>
		///                 Retrieves the keyboard repeat-delay setting, which is a value in the range from 0 (approximately 250 ms delay) through 3
		///                 (approximately 1 second delay). The actual delay associated with each value may vary depending on the hardware. The
		///                 <paramref name="pvParam" /> parameter must point to an integer variable that receives the setting.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETKEYBOARDPREF 0x0044</term>
		///             <description>
		///                 Determines whether the user relies on the keyboard instead of the mouse, and wants applications to display keyboard interfaces that
		///                 would otherwise be hidden. The <paramref name="pvParam" /> parameter must point to a BOOL variable that receives TRUE
		///                 if the user relies on the keyboard; or FALSE otherwise.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETKEYBOARDSPEED 0x000A</term>
		///             <description>
		///                 Retrieves the keyboard repeat-speed setting, which is a value in the range from 0 (approximately 2.5 repetitions per second) through
		///                 31 (approximately 30 repetitions per second). The actual repeat rates are hardware-dependent and may vary from a linear scale by as
		///                 much as 20%. The <paramref name="pvParam" /> parameter must point to a DWORD variable that receives the setting.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMOUSE 0x0003</term>
		///             <description>
		///                 Retrieves the two mouse threshold values and the mouse acceleration. The <paramref name="pvParam" /> parameter must point to an array
		///                 of three integers that receives these values. See <see cref="mouse_event" /> for further information.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMOUSEHOVERHEIGHT 0x0064</term>
		///             <description>
		///                 Retrieves the height, in pixels, of the rectangle within which the mouse pointer has to stay for <see cref="TrackMouseEvent" /> to
		///                 generate a <see cref="WM.WM_MOUSEHOVER" /> message. The <paramref name="pvParam" /> parameter must point to a UINT
		///                 variable that receives the height.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMOUSEHOVERTIME 0x0066</term>
		///             <description>
		///                 Retrieves the time, in milliseconds, that the mouse pointer has to stay in the hover rectangle for <see cref="TrackMouseEvent" /> to
		///                 generate a <see cref="WM.WM_MOUSEHOVER" /> message. The <paramref name="pvParam" /> parameter must point to a UINT
		///                 variable that receives the time.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMOUSEHOVERWIDTH 0x0062</term>
		///             <description>
		///                 Retrieves the width, in pixels, of the rectangle within which the mouse pointer has to stay for <see cref="TrackMouseEvent" /> to
		///                 generate a <see cref="WM.WM_MOUSEHOVER" /> message. The <paramref name="pvParam" /> parameter must point to a UINT
		///                 variable that receives the width.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMOUSESPEED 0x0070</term>
		///             <description>
		///                 Retrieves the current mouse speed. The mouse speed determines how far the pointer will move based on the distance the mouse moves.
		///                 The <paramref name="pvParam" /> parameter must point to an integer that receives a value which ranges between 1 (slowest) and 20
		///                 (fastest). A value of 10 is the default. The value can be set by an end-user using the mouse control panel application or by an
		///                 application using <see cref="SPI.SPI_SETMOUSESPEED" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMOUSETRAILS 0x005E</term>
		///             <description>
		///                 <para>
		///                     Determines whether the Mouse Trails feature is enabled. This feature improves the visibility of mouse cursor movements by briefly
		///                     showing a trail of cursors and quickly erasing them.
		///                 </para>
		///                 <para>
		///                     The <paramref name="pvParam" /> parameter must point to an integer variable that receives a value. If the value is zero or 1, the
		///                     feature is disabled. If the value is greater than 1, the feature is enabled and the value indicates the number of cursors drawn
		///                     in the trail. The <paramref name="uiParam" /> parameter is not used.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETSNAPTODEFBUTTON 0x005F</term>
		///             <description>
		///                 Determines whether the snap-to-default-button feature is enabled. If enabled, the mouse cursor automatically moves to the default
		///                 button, such as OK or Apply, of a dialog box. The <paramref name="pvParam" /> parameter must point to a
		///                 BOOL variable that receives TRUE if the feature is on, or FALSE if it is off.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETSYSTEMLANGUAGEBAR 0x1050</term>
		///             <description>
		///                 Starting with Windows 8: Determines whether the system language bar is enabled or disabled. The <paramref name="pvParam" /> parameter
		///                 must point to a BOOL variable that receives TRUE if the language bar is enabled, or FALSE otherwise.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETTHREADLOCALINPUTSETTINGS 0x104E</term>
		///             <description>
		///                 Starting with Windows 8: Determines whether the active input settings have Local (per-thread, TRUE) or Global (session, FALSE) scope.
		///                 The <paramref name="pvParam" /> parameter must point to a BOOL variable.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETWHEELSCROLLCHARS 0x006C</term>
		///             <description>
		///                 Retrieves the number of characters to scroll when the horizontal mouse wheel is moved. The <paramref name="pvParam" /> parameter must
		///                 point to a UINT variable that receives the number of lines. The default value is 3.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETWHEELSCROLLLINES 0x0068</term>
		///             <description>
		///                 Retrieves the number of lines to scroll when the vertical mouse wheel is moved. The <paramref name="pvParam" /> parameter must point
		///                 to a UINT variable that receives the number of lines. The default value is 3.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETBEEP 0x0002</term>
		///             <description>
		///                 Turns the warning beeper on or off. The <paramref name="uiParam" /> parameter specifies TRUE for on, or FALSE for off.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETBLOCKSENDINPUTRESETS 0x1027</term>
		///             <description>
		///                 Determines whether an application can reset the screensaver's timer by calling the <see cref="SendInput" /> function to simulate
		///                 keyboard or mouse input. The <paramref name="uiParam" /> parameter specifies TRUE if the screensaver will not be deactivated by
		///                 simulated input, or FALSE if the screensaver will be deactivated by simulated input.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETCONTACTVISUALIZATION 0x2019</term>
		///             <description>
		///                 <para>
		///                     Sets the current contact visualization setting. The <paramref name="pvParam" /> parameter must point to a ULONG
		///                     variable that identifies the setting. For more information, see Contact Visualization.
		///                 </para>
		///                 <para>
		///                     Note:
		///                 </para>
		///                 <para>If contact visualizations are disabled, gesture visualizations cannot be enabled.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETDEFAULTINPUTLANG 0x005A</term>
		///             <description>
		///                 Sets the default input language for the system shell and applications. The specified language must be displayable using the current
		///                 system character set. The <paramref name="pvParam" /> parameter must point to an <see cref="HKL" /> variable that contains the input
		///                 locale identifier for the default language. For more information, see Languages, Locales, and Keyboard Layouts.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETDOUBLECLICKTIME 0x0020</term>
		///             <description>
		///                 <para>
		///                     Sets the double-click time for the mouse to the value of the <paramref name="uiParam" /> parameter. If the
		///                     <paramref name="uiParam" /> value is greater than 5000 milliseconds, the system sets the double-click time to 5000 milliseconds.
		///                 </para>
		///                 <para>
		///                     The double-click time is the maximum number of milliseconds that can occur between the first and second clicks of a double-click.
		///                     You can also call the <see cref="SetDoubleClickTime" /> function to set the double-click time. To get the current double-click
		///                     time, call the <see cref="GetDoubleClickTime" /> function.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETDOUBLECLKHEIGHT 0x001E</term>
		///             <description>
		///                 <para>
		///                     Sets the height of the double-click rectangle to the value of the <paramref name="uiParam" /> parameter.
		///                 </para>
		///                 <para>
		///                     The double-click rectangle is the rectangle within which the second click of a double-click must fall for it to be registered
		///                     as a double-click.
		///                 </para>
		///                 <para>
		///                     To retrieve the height of the double-click rectangle, call <see cref="GetSystemMetrics" /> with the <see cref="SM.SM_CYDOUBLECLK" />
		///                     flag.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETDOUBLECLKWIDTH 0x001D</term>
		///             <description>
		///                 <para>
		///                     Sets the width of the double-click rectangle to the value of the <paramref name="uiParam" /> parameter.
		///                 </para>
		///                 <para>
		///                     The double-click rectangle is the rectangle within which the second click of a double-click must fall for it to be registered
		///                     as a double-click.
		///                 </para>
		///                 <para>
		///                     To retrieve the width of the double-click rectangle, call <see cref="GetSystemMetrics" /> with the <see cref="SM.SM_CXDOUBLECLK" />
		///                     flag.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETGESTUREVISUALIZATION 0x201B</term>
		///             <description>
		///                 <para>
		///                     Sets the current gesture visualization setting. The <paramref name="pvParam" /> parameter must point to a ULONG
		///                     variable that identifies the setting. For more information, see Gesture Visualization.
		///                 </para>
		///                 <para>
		///                     Note:
		///                 </para>
		///                 <para>If contact visualizations are disabled, gesture visualizations cannot be enabled.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETKEYBOARDCUES 0x100B</term>
		///             <description>
		///                 Sets the underlining of menu access key letters. The <paramref name="pvParam" /> parameter is a BOOL variable. Set
		///                 <paramref name="pvParam" /> to TRUE to always underline menu access keys, or FALSE to underline menu access keys only when the menu
		///                 is activated from the keyboard.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETKEYBOARDDELAY 0x0017</term>
		///             <description>
		///                 Sets the keyboard repeat-delay setting. The <paramref name="uiParam" /> parameter must specify 0, 1, 2, or 3, where zero sets the
		///                 shortest delay approximately 250 ms) and 3 sets the longest delay (approximately 1 second). The actual delay associated with each
		///                 value may vary depending on the hardware.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETKEYBOARDPREF 0x0045</term>
		///             <description>
		///                 Sets the keyboard preference. The <paramref name="uiParam" /> parameter specifies TRUE if the user relies on the keyboard instead of
		///                 the mouse, and wants applications to display keyboard interfaces that would otherwise be hidden; <paramref name="uiParam" /> is FALSE
		///                 otherwise.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETKEYBOARDSPEED 0x000B</term>
		///             <description>
		///                 Sets the keyboard repeat-speed setting. The <paramref name="uiParam" /> parameter must specify a value in the range from 0
		///                 (approximately 2.5 repetitions per second) through 31 (approximately 30 repetitions per second). The actual repeat rates are
		///                 hardware-dependent and may vary from a linear scale by as much as 20%. If <paramref name="uiParam" /> is greater than 31, the
		///                 parameter is set to 31.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETLANGTOGGLE 0x005B</term>
		///             <description>
		///                 <para>
		///                     Sets the hot key set for switching between input languages. The <paramref name="uiParam" /> and <paramref name="pvParam" />
		///                     parameters are not used. The value sets the shortcut keys in the keyboard property sheets by reading the registry again. The
		///                     registry must be set before this flag is used. the path in the registry is
		///                 </para>
		///                 <para>
		///                     HKEY_CURRENT_USER\Keyboard Layout\Toggle
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMOUSE 0x0004</term>
		///             <description>
		///                 Sets the two mouse threshold values and the mouse acceleration. The <paramref name="pvParam" /> parameter must point to an array of
		///                 three integers that specifies these values. See <see cref="mouse_event" /> for further information.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMOUSEBUTTONSWAP 0x0021</term>
		///             <description>
		///                 <para>
		///                     Swaps or restores the meaning of the left and right mouse buttons. The <paramref name="uiParam" /> parameter specifies TRUE to
		///                     swap the meanings of the buttons, or FALSE to restore their original meanings.
		///                 </para>
		///                 <para>
		///                     To retrieve the current setting, call <see cref="GetSystemMetrics" /> with the <see cref="SM.SM_SWAPBUTTON" /> flag.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMOUSEHOVERHEIGHT 0x0065</term>
		///             <description>
		///                 Sets the height, in pixels, of the rectangle within which the mouse pointer has to stay for <see cref="TrackMouseEvent" /> to
		///                 generate a <see cref="WM.WM_MOUSEHOVER" /> message. Set the <paramref name="uiParam" /> parameter to the new height.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMOUSEHOVERTIME 0x0067</term>
		///             <description>
		///                 <para>
		///                     Sets the time, in milliseconds, that the mouse pointer has to stay in the hover rectangle for <see cref="TrackMouseEvent" /> to
		///                     generate a <see cref="WM.WM_MOUSEHOVER" /> message. This is used only if you pass HOVER_DEFAULT in the
		///                     dwHoverTime parameter in the call to <see cref="TrackMouseEvent" />. Set the <paramref name="uiParam" />
		///                     parameter to the new time.
		///                 </para>
		///                 <para>
		///                     The time specified should be between USER_TIMER_MAXIMUM and USER_TIMER_MINIMUM. If
		///                     <paramref name="uiParam" /> is less than USER_TIMER_MINIMUM, the function will use
		///                     USER_TIMER_MINIMUM. If <paramref name="uiParam" /> is greater than USER_TIMER_MAXIMUM, the function
		///                     will be USER_TIMER_MAXIMUM.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMOUSEHOVERWIDTH 0x0063</term>
		///             <description>
		///                 Sets the width, in pixels, of the rectangle within which the mouse pointer has to stay for <see cref="TrackMouseEvent" /> to generate
		///                 a <see cref="WM.WM_MOUSEHOVER" /> message. Set the <paramref name="uiParam" /> parameter to the new width.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMOUSESPEED 0x0071</term>
		///             <description>
		///                 Sets the current mouse speed. The <paramref name="pvParam" /> parameter is an integer between 1 (slowest) and 20 (fastest). A value
		///                 of 10 is the default. This value is typically set using the mouse control panel application.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMOUSETRAILS 0x005D</term>
		///             <description>
		///                 <para>
		///                     Enables or disables the Mouse Trails feature, which improves the visibility of mouse cursor movements by briefly showing a trail
		///                     of cursors and quickly erasing them.
		///                 </para>
		///                 <para>
		///                     To disable the feature, set the <paramref name="uiParam" /> parameter to zero or 1. To enable the feature, set
		///                     <paramref name="uiParam" /> to a value greater than 1 to indicate the number of cursors drawn in the trail.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETSNAPTODEFBUTTON 0x0060</term>
		///             <description>
		///                 Enables or disables the snap-to-default-button feature. If enabled, the mouse cursor automatically moves to the default button, such
		///                 as OK or Apply, of a dialog box. Set the <paramref name="uiParam" /> parameter to TRUE to enable the
		///                 feature, or FALSE to disable it. Applications should use the <see cref="ShowWindow" /> function when displaying a dialog box so the
		///                 dialog manager can position the mouse cursor.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETSYSTEMLANGUAGEBAR 0x1051</term>
		///             <description>
		///                 Starting with Windows 8: Turns the legacy language bar feature on or off. The <paramref name="pvParam" /> parameter is a pointer to a
		///                 BOOL variable. Set <paramref name="pvParam" /> to TRUE to enable the legacy language bar, or FALSE to disable it. The
		///                 flag is supported on Windows 8 where the legacy language bar is replaced by Input Switcher and therefore turned off by default.
		///                 Turning the legacy language bar on is provided for compatibility reasons and has no effect on the Input Switcher.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETTHREADLOCALINPUTSETTINGS 0x104F</term>
		///             <description>
		///                 Starting with Windows 8: Determines whether the active input settings have Local (per-thread, TRUE) or Global (session, FALSE) scope.
		///                 The <paramref name="pvParam" /> parameter must point to a BOOL variable, casted by PVOID.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETWHEELSCROLLCHARS 0x006D</term>
		///             <description>
		///                 Sets the number of characters to scroll when the horizontal mouse wheel is moved. The number of characters is set from the
		///                 <paramref name="uiParam" /> parameter.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETWHEELSCROLLLINES 0x0069</term>
		///             <description>
		///                 <para>
		///                     Sets the number of lines to scroll when the vertical mouse wheel is moved. The number of lines is set from the
		///                     <paramref name="uiParam" /> parameter.
		///                 </para>
		///                 <para>
		///                     The number of lines is the suggested number of lines to scroll when the mouse wheel is rolled without using modifier keys. If the
		///                     number is 0, then no scrolling should occur. If the number of lines to scroll is greater than the number of lines viewable, and
		///                     in particular if it is WHEEL_PAGESCROLL (#defined as UINT_MAX), the scroll operation should be
		///                     interpreted as clicking once in the page down or page up regions of the scroll bar.
		///                 </para>
		///             </description>
		///         </item>
		///     </list>
		///     <para>The following are the menu parameters.</para>
		///     <list type="table">
		///         <item>
		///             <term>SPI_GETMENUDROPALIGNMENT 0x001B</term>
		///             <description>
		///                 Determines whether pop-up menus are left-aligned or right-aligned, relative to the corresponding menu-bar item. The
		///                 <paramref name="pvParam" /> parameter must point to a BOOL variable that receives TRUE if right-aligned, or FALSE
		///                 otherwise.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMENUFADE 0x1012</term>
		///             <description>
		///                 Determines whether menu fade animation is enabled. The <paramref name="pvParam" /> parameter must point to a BOOL
		///                 variable that receives TRUE when fade animation is enabled and FALSE when it isdisabled. If fade animation is disabled, menus use
		///                 slide animation. This flag is ignored unless menu animation is enabled, which you can do using the
		///                 <see cref="SPI.SPI_SETMENUANIMATION" /> flag. For more information, see <see cref="AnimateWindow" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMENUSHOWDELAY 0x006A</term>
		///             <description>
		///                 Retrieves the time, in milliseconds, that the system waits before displaying a shortcut menu when the mouse cursor is over a submenu
		///                 item. The <paramref name="pvParam" /> parameter must point to a DWORD variable that receives the time of the delay.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMENUDROPALIGNMENT 0x001C</term>
		///             <description>
		///                 Sets the alignment value of pop-up menus. The <paramref name="uiParam" /> parameter specifies TRUE for right alignment, or FALSE for
		///                 left alignment.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMENUFADE 0x1013</term>
		///             <description>
		///                 Enables or disables menu fade animation. Set <paramref name="pvParam" /> to TRUE to enable the menu fade effect or FALSE to disable
		///                 it. If fade animation is disabled, menus use slide animation. he The menu fade effect is possible only if the system has a color
		///                 depth of more than 256 colors. This flag is ignored unless <see cref="SPI.SPI_SETMENUANIMATION" /> is also set. For more information, see
		///                 <see cref="AnimateWindow" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMENUSHOWDELAY 0x006B</term>
		///             <description>
		///                 Sets <paramref name="uiParam" /> to the time, in milliseconds, that the system waits before displaying a shortcut menu when the mouse
		///                 cursor is over a submenu item.
		///             </description>
		///         </item>
		///     </list>
		///     <para>The following are the power parameters.</para>
		///     <para>
		///         Beginning with Windows Server 2008 and Windows Vista, these power parameters are not supported. Instead, to determine the current display
		///         power state, an application should register for GUID_MONITOR_POWER_STATE notifications. To determine the current display power
		///         down time-out, an application should register for notification of changes to the GUID_VIDEO_POWERDOWN_TIMEOUT power setting.
		///         For more information, see Registering for Power Events.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>SPI_GETLOWPOWERACTIVE 0x0053</term>
		///             <description>
		///                 <para>This parameter is not supported.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETLOWPOWERTIMEOUT 0x004F</term>
		///             <description>
		///                 <para>This parameter is not supported.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETPOWEROFFACTIVE 0x0054</term>
		///             <description>
		///                 <para>
		///                     This parameter is not supported. When the power-off phase of screen saving is enabled, the
		///                     GUID_VIDEO_POWERDOWN_TIMEOUT power setting is greater than zero.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETPOWEROFFTIMEOUT 0x0050</term>
		///             <description>
		///                 <para>
		///                     This parameter is not supported. Instead, check the GUID_VIDEO_POWERDOWN_TIMEOUT power setting.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETLOWPOWERACTIVE 0x0055</term>
		///             <description>
		///                 <para>This parameter is not supported.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETLOWPOWERTIMEOUT 0x0051</term>
		///             <description>
		///                 <para>This parameter is not supported.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETPOWEROFFACTIVE 0x0056</term>
		///             <description>
		///                 <para>
		///                     This parameter is not supported. Instead, set the GUID_VIDEO_POWERDOWN_TIMEOUT power setting.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETPOWEROFFTIMEOUT 0x0052</term>
		///             <description>
		///                 <para>
		///                     This parameter is not supported. Instead, set the GUID_VIDEO_POWERDOWN_TIMEOUT power setting to a time-out value.
		///                 </para>
		///             </description>
		///         </item>
		///     </list>
		///     <para>The following are the screen saver parameters.</para>
		///     <list type="table">
		///         <item>
		///             <term>SPI_GETSCREENSAVEACTIVE 0x0010</term>
		///             <description>
		///                 <para>
		///                     Determines whether screen saving is enabled. The <paramref name="pvParam" /> parameter must point to a BOOL
		///                     variable that receives TRUE if screen saving is enabled, or FALSE otherwise.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETSCREENSAVERRUNNING 0x0072</term>
		///             <description>
		///                 Determines whether a screen saver is currently running on the window station of the calling process. The <paramref name="pvParam" />
		///                 parameter must point to a BOOL variable that receives TRUE if a screen saver is currently running, or FALSE otherwise.
		///                 Note that only the interactive window station, WinSta0, can have a screen saver running.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETSCREENSAVESECURE 0x0076</term>
		///             <description>
		///                 <para>
		///                     Determines whether the screen saver requires a password to display the Windows desktop. The <paramref name="pvParam" /> parameter
		///                     must point to a BOOL variable that receives TRUE if the screen saver requires a password, or FALSE otherwise. The
		///                     <paramref name="uiParam" /> parameter is ignored.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETSCREENSAVETIMEOUT 0x000E</term>
		///             <description>
		///                 Retrieves the screen saver time-out value, in seconds. The <paramref name="pvParam" /> parameter must point to an integer variable
		///                 that receives the value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETSCREENSAVEACTIVE 0x0011</term>
		///             <description>
		///                 <para>
		///                     Sets the state of the screen saver. The <paramref name="uiParam" /> parameter specifies TRUE to activate screen saving, or FALSE
		///                     to deactivate it.
		///                 </para>
		///                 <para>If the machine has entered power saving mode or system lock state, an ERROR_OPERATION_IN_PROGRESS exception occurs.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETSCREENSAVESECURE 0x0077</term>
		///             <description>
		///                 <para>
		///                     Sets whether the screen saver requires the user to enter a password to display the Windows desktop. The
		///                     <paramref name="uiParam" /> parameter is a BOOL variable. The <paramref name="pvParam" /> parameter is ignored.
		///                     Set <paramref name="uiParam" /> to TRUE to require a password, or FALSE to not require a password.
		///                 </para>
		///                 <para>If the machine has entered power saving mode or system lock state, an ERROR_OPERATION_IN_PROGRESS exception occurs.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETSCREENSAVETIMEOUT 0x000F</term>
		///             <description>
		///                 <para>
		///                     Sets the screen saver time-out value to the value of the <paramref name="uiParam" /> parameter. This value is the amount of time,
		///                     in seconds, that the system must be idle before the screen saver activates.
		///                 </para>
		///                 <para>If the machine has entered power saving mode or system lock state, an ERROR_OPERATION_IN_PROGRESS exception occurs.</para>
		///             </description>
		///         </item>
		///     </list>
		///     <para>The following are the time-out parameters for applications and services.</para>
		///     <list type="table">
		///         <item>
		///             <term>SPI_GETHUNGAPPTIMEOUT 0x0078</term>
		///             <description>
		///                 <para>
		///                     Retrieves the number of milliseconds that a thread can go without dispatching a message before the system considers it
		///                     unresponsive. The <paramref name="pvParam" /> parameter must point to an integer variable that receives the value.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETWAITTOKILLTIMEOUT 0x007A</term>
		///             <description>
		///                 <para>
		///                     Retrieves the number of milliseconds that the system waits before terminating an application that does not respond to a shutdown
		///                     request. The <paramref name="pvParam" /> parameter must point to an integer variable that receives the value.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETWAITTOKILLSERVICETIMEOUT 0x007C</term>
		///             <description>
		///                 <para>
		///                     Retrieves the number of milliseconds that the service control manager waits before terminating a service that does not respond to
		///                     a shutdown request. The <paramref name="pvParam" /> parameter must point to an integer variable that receives the value.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETHUNGAPPTIMEOUT 0x0079</term>
		///             <description>
		///                 <para>
		///                     Sets the hung application time-out to the value of the <paramref name="uiParam" /> parameter. This value is the number of
		///                     milliseconds that a thread can go without dispatching a message before the system considers it unresponsive.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETWAITTOKILLTIMEOUT 0x007B</term>
		///             <description>
		///                 <para>
		///                     Sets the application shutdown request time-out to the value of the <paramref name="uiParam" /> parameter. This value is the
		///                     number of milliseconds that the system waits before terminating an application that does not respond to a shutdown request.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETWAITTOKILLSERVICETIMEOUT 0x007D</term>
		///             <description>
		///                 <para>
		///                     Sets the service shutdown request time-out to the value of the <paramref name="uiParam" /> parameter. This value is the number of
		///                     milliseconds that the system waits before terminating a service that does not respond to a shutdown request.
		///                 </para>
		///             </description>
		///         </item>
		///     </list>
		///     <para>
		///         The following are the UI effects. The <see cref="SPI.SPI_SETUIEFFECTS" /> value is used to enable or disable all UI effects at once. This table
		///         contains the complete list of UI effect values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>SPI_GETCOMBOBOXANIMATION 0x1004</term>
		///             <description>
		///                 Determines whether the slide-open effect for combo boxes is enabled. The <paramref name="pvParam" /> parameter must point to a
		///                 BOOL variable that receives TRUE for enabled, or FALSE for disabled.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETCURSORSHADOW 0x101A</term>
		///             <description>
		///                 Determines whether the cursor has a shadow around it. The <paramref name="pvParam" /> parameter must point to a BOOL
		///                 variable that receives TRUE if the shadow is enabled, FALSE if it is disabled. This effect appears only if the system has a color
		///                 depth of more than 256 colors.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETGRADIENTCAPTIONS 0x1008</term>
		///             <description>
		///                 Determines whether the gradient effect for window title bars is enabled. The <paramref name="pvParam" /> parameter must point to a
		///                 BOOL variable that receives TRUE for enabled, or FALSE for disabled. For more information about the gradient effect,
		///                 see the <see cref="GetSysColor" /> function.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETHOTTRACKING 0x100E</term>
		///             <description>
		///                 <para>
		///                     Determines whether hot tracking of user-interface elements, such as menu names on menu bars, is enabled. The
		///                     <paramref name="pvParam" /> parameter must point to a BOOL variable that receives TRUE for enabled, or FALSE for
		///                     disabled.
		///                 </para>
		///                 <para>
		///                     Hot tracking means that when the cursor moves over an item, it is highlighted but not selected. You can query this value to
		///                     decide whether to use hot tracking in the user interface of your application.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETLISTBOXSMOOTHSCROLLING 0x1006</term>
		///             <description>
		///                 Determines whether the smooth-scrolling effect for list boxes is enabled. The <paramref name="pvParam" /> parameter must point to a
		///                 BOOL variable that receives TRUE for enabled, or FALSE for disabled.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMENUANIMATION 0x1002</term>
		///             <description>
		///                 <para>
		///                     Determines whether the menu animation feature is enabled. This master switch must be on to enable menu animation effects. The
		///                     <paramref name="pvParam" /> parameter must point to a BOOL variable that receives TRUE if animation is enabled and
		///                     FALSE if it is disabled.
		///                 </para>
		///                 <para>
		///                     If animation is enabled, <see cref="SPI.SPI_GETMENUFADE" /> indicates whether menus use fade or slide animation.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMENUUNDERLINES 0x100A</term>
		///             <description>
		///                 Same as <see cref="SPI.SPI_GETKEYBOARDCUES" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETSELECTIONFADE 0x1014</term>
		///             <description>
		///                 <para>
		///                     Determines whether the selection fade effect is enabled. The <paramref name="pvParam" /> parameter must point to a
		///                     BOOL variable that receives TRUE if enabled or FALSE if disabled.
		///                 </para>
		///                 <para>
		///                     The selection fade effect causes the menu item selected by the user to remain on the screen briefly while fading out after the
		///                     menu is dismissed.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETTOOLTIPANIMATION 0x1016</term>
		///             <description>
		///                 Determines whether ToolTip animation is enabled. The <paramref name="pvParam" /> parameter must point to a BOOL
		///                 variable that receives TRUE if enabled or FALSE if disabled. If ToolTip animation is enabled, <see cref="SPI.SPI_GETTOOLTIPFADE" />
		///                 indicates whether ToolTips use fade or slide animation.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETTOOLTIPFADE 0x1018</term>
		///             <description>
		///                 If <see cref="SPI.SPI_SETTOOLTIPANIMATION" /> is enabled, <see cref="SPI.SPI_GETTOOLTIPFADE" /> indicates whether ToolTip animation uses a
		///                 fade effect or a slide effect. The <paramref name="pvParam" /> parameter must point to a BOOL variable that receives
		///                 TRUE for fade animation or FALSE for slide animation. For more information on slide and fade effects, see
		///                 <see cref="AnimateWindow" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETUIEFFECTS 0x103E</term>
		///             <description>
		///                 Determines whether UI effects are enabled or disabled. The <paramref name="pvParam" /> parameter must point to a BOOL
		///                 variable that receives TRUE if all UI effects are enabled, or FALSE if they are disabled.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETCOMBOBOXANIMATION 0x1005</term>
		///             <description>
		///                 Enables or disables the slide-open effect for combo boxes. Set the <paramref name="pvParam" /> parameter to TRUE to enable the
		///                 gradient effect, or FALSE to disable it.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETCURSORSHADOW 0x101B</term>
		///             <description>
		///                 Enables or disables a shadow around the cursor. The <paramref name="pvParam" /> parameter is a BOOL variable. Set
		///                 <paramref name="pvParam" /> to TRUE to enable the shadow or FALSE to disable the shadow. This effect appears only if the system has a
		///                 color depth of more than 256 colors.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETGRADIENTCAPTIONS 0x1009</term>
		///             <description>
		///                 Enables or disables the gradient effect for window title bars. Set the <paramref name="pvParam" /> parameter to TRUE to enable it, or
		///                 FALSE to disable it. The gradient effect is possible only if the system has a color depth of more than 256 colors. For more
		///                 information about the gradient effect, see the <see cref="GetSysColor" /> function.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETHOTTRACKING 0x100F</term>
		///             <description>
		///                 <para>
		///                     Enables or disables hot tracking of user-interface elements such as menu names on menu bars. Set the <paramref name="pvParam" />
		///                     parameter to TRUE to enable it, or FALSE to disable it.
		///                 </para>
		///                 <para>Hot-tracking means that when the cursor moves over an item, it is highlighted but not selected.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETLISTBOXSMOOTHSCROLLING 0x1007</term>
		///             <description>
		///                 Enables or disables the smooth-scrolling effect for list boxes. Set the <paramref name="pvParam" /> parameter to TRUE to enable the
		///                 smooth-scrolling effect, or FALSE to disable it.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMENUANIMATION 0x1003</term>
		///             <description>
		///                 <para>
		///                     Enables or disables menu animation. This master switch must be on for any menu animation to occur. The
		///                     <paramref name="pvParam" /> parameter is a BOOL variable; set <paramref name="pvParam" /> to TRUE to enable
		///                     animation and FALSE to disable animation.
		///                 </para>
		///                 <para>
		///                     If animation is enabled, <see cref="SPI.SPI_GETMENUFADE" /> indicates whether menus use fade or slide animation.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMENUUNDERLINES 0x100B</term>
		///             <description>
		///                 Same as <see cref="SPI.SPI_SETKEYBOARDCUES" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETSELECTIONFADE 0x1015</term>
		///             <description>
		///                 <para>
		///                     Set <paramref name="pvParam" /> to TRUE to enable the selection fade effect or FALSE to disable it.
		///                 </para>
		///                 <para>
		///                     The selection fade effect causes the menu item selected by the user to remain on the screen briefly while fading out after the
		///                     menu is dismissed. The selection fade effect is possible only if the system has a color depth of more than 256 colors.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETTOOLTIPANIMATION 0x1017</term>
		///             <description>
		///                 Set <paramref name="pvParam" /> to TRUE to enable ToolTip animation or FALSE to disable it. If enabled, you can use
		///                 <see cref="SPI.SPI_SETTOOLTIPFADE" /> to specify fade or slide animation.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETTOOLTIPFADE 0x1019</term>
		///             <description>
		///                 If the <see cref="SPI.SPI_SETTOOLTIPANIMATION" /> flag is enabled, use <see cref="SPI.SPI_SETTOOLTIPFADE" /> to indicate whether ToolTip
		///                 animation uses a fade effect or a slide effect. Set <paramref name="pvParam" /> to TRUE for fade animation or FALSE for slide
		///                 animation. The tooltip fade effect is possible only if the system has a color depth of more than 256 colors. For more information on
		///                 the slide and fade effects, see the <see cref="AnimateWindow" />function.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETUIEFFECTS 0x103F</term>
		///             <description>
		///                 Enables or disables UI effects. Set the <paramref name="pvParam" /> parameter to TRUE to enable all UI effects or FALSE to disable
		///                 all UI effects.
		///             </description>
		///         </item>
		///     </list>
		///     <para>The following are the window parameters.</para>
		///     <list type="table">
		///         <item>
		///             <term>SPI_GETACTIVEWINDOWTRACKING 0x1000</term>
		///             <description>
		///                 Determines whether active window tracking (activating the window the mouse is on) is on or off. The <paramref name="pvParam" />
		///                 parameter must point to a BOOL variable that receives TRUE for on, or FALSE for off.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETACTIVEWNDTRKZORDER 0x100C</term>
		///             <description>
		///                 Determines whether windows activated through active window tracking will be brought to the top. The <paramref name="pvParam" />
		///                 parameter must point to a BOOL variable that receives TRUE for on, or FALSE for off.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETACTIVEWNDTRKTIMEOUT 0x2002</term>
		///             <description>
		///                 Retrieves the active window tracking delay, in milliseconds. The <paramref name="pvParam" /> parameter must point to a
		///                 DWORD variable that receives the time.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETANIMATION 0x0048</term>
		///             <description>
		///                 Retrieves the animation effects associated with user actions. The <paramref name="pvParam" /> parameter must point to an
		///                 <see cref="ANIMATIONINFO" /> structure that receives the information. Set the <see cref="ANIMATIONINFO.cbSize" /> member of this structure and the
		///                 <paramref name="uiParam" /> parameter to sizeof(ANIMATIONINFO).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETBORDER 0x0005</term>
		///             <description>
		///                 Retrieves the border multiplier factor that determines the width of a window's sizing border. The <paramref name="pvParam" />
		///                 parameter must point to an integer variable that receives this value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETCARETWIDTH 0x2006</term>
		///             <description>
		///                 Retrieves the caret width in edit controls, in pixels. The <paramref name="pvParam" /> parameter must point to a DWORD
		///                 variable that receives this value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETDOCKMOVING 0x0090</term>
		///             <description>
		///                 <para>
		///                     Determines whether a window is docked when it is moved to the top, left, or right edges of a monitor or monitor array. The
		///                     <paramref name="pvParam" /> parameter must point to a BOOL variable that receives TRUE if enabled, or FALSE
		///                     otherwise.
		///                 </para>
		///                 <para>
		///                     Use <see cref="SPI.SPI_GETWINARRANGING" /> to determine whether this behavior is enabled.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETDRAGFROMMAXIMIZE 0x008C</term>
		///             <description>
		///                 <para>
		///                     Determines whether a maximized window is restored when its caption bar is dragged. The <paramref name="pvParam" /> parameter must
		///                     point to a BOOL variable that receives TRUE if enabled, or FALSE otherwise.
		///                 </para>
		///                 <para>
		///                     Use <see cref="SPI.SPI_GETWINARRANGING" /> to determine whether this behavior is enabled.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETDRAGFULLWINDOWS 0x0026</term>
		///             <description>
		///                 Determines whether dragging of full windows is enabled. The <paramref name="pvParam" /> parameter must point to a BOOL
		///                 variable that receives TRUE if enabled, or FALSE otherwise.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETFOREGROUNDFLASHCOUNT 0x2004</term>
		///             <description>
		///                 Retrieves the number of times <see cref="SetForegroundWindow" /> will flash the taskbar button when rejecting a foreground switch
		///                 request. The <paramref name="pvParam" /> parameter must point to a DWORD variable that receives the value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETFOREGROUNDLOCKTIMEOUT 0x2000</term>
		///             <description>
		///                 Retrieves the amount of time following user input, in milliseconds, during which the system will not allow applications to force
		///                 themselves into the foreground. The <paramref name="pvParam" /> parameter must point to a DWORD variable that receives
		///                 the time.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMINIMIZEDMETRICS 0x002B</term>
		///             <description>
		///                 Retrieves the metrics associated with minimized windows. The <paramref name="pvParam" /> parameter must point to a
		///                 <see cref="MINIMIZEDMETRICS" /> structure that receives the information. Set the <see cref="MINIMIZEDMETRICS.cbSize" /> member of this structure and
		///                 the <paramref name="uiParam" /> parameter to sizeof(MINIMIZEDMETRICS).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMOUSEDOCKTHRESHOLD 0x007E</term>
		///             <description>
		///                 <para>
		///                     Retrieves the threshold in pixels where docking behavior is triggered by using a mouse to drag a window to the edge of a monitor
		///                     or monitor array. The default threshold is 1. The <paramref name="pvParam" /> parameter must point to a DWORD
		///                     variable that receives the value.
		///                 </para>
		///                 <para>
		///                     Use <see cref="SPI.SPI_GETWINARRANGING" /> to determine whether this behavior is enabled.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMOUSEDRAGOUTTHRESHOLD 0x0084</term>
		///             <description>
		///                 <para>
		///                     Retrieves the threshold in pixels where undocking behavior is triggered by using a mouse to drag a window from the edge of a
		///                     monitor or a monitor array toward the center. The default threshold is 20.
		///                 </para>
		///                 <para>
		///                     Use <see cref="SPI.SPI_GETWINARRANGING" /> to determine whether this behavior is enabled.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETMOUSESIDEMOVETHRESHOLD 0x0088</term>
		///             <description>
		///                 <para>
		///                     Retrieves the threshold in pixels from the top of a monitor or a monitor array where a vertically maximized window is restored
		///                     when dragged with the mouse. The default threshold is 50.
		///                 </para>
		///                 <para>
		///                     Use <see cref="SPI.SPI_GETWINARRANGING" /> to determine whether this behavior is enabled.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETNONCLIENTMETRICS 0x0029</term>
		///             <description>
		///                 Retrieves the metrics associated with the nonclient area of nonminimized windows. The <paramref name="pvParam" /> parameter must
		///                 point to a <see cref="NONCLIENTMETRICS" /> structure that receives the information. Set the <see cref="NONCLIENTMETRICS.cbSize" /> member of this
		///                 structure and the <paramref name="uiParam" /> parameter to sizeof(NONCLIENTMETRICS).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETPENDOCKTHRESHOLD 0x0080</term>
		///             <description>
		///                 <para>
		///                     Retrieves the threshold in pixels where docking behavior is triggered by using a pen to drag a window to the edge of a monitor or
		///                     monitor array. The default is 30.
		///                 </para>
		///                 <para>
		///                     Use <see cref="SPI.SPI_GETWINARRANGING" /> to determine whether this behavior is enabled.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETPENDRAGOUTTHRESHOLD 0x0086</term>
		///             <description>
		///                 <para>
		///                     Retrieves the threshold in pixels where undocking behavior is triggered by using a pen to drag a window from the edge of a
		///                     monitor or monitor array toward its center. The default threshold is 30.
		///                 </para>
		///                 <para>
		///                     Use <see cref="SPI.SPI_GETWINARRANGING" /> to determine whether this behavior is enabled.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETPENSIDEMOVETHRESHOLD 0x008A</term>
		///             <description>
		///                 <para>
		///                     Retrieves the threshold in pixels from the top of a monitor or monitor array where a vertically maximized window is restored when
		///                     dragged with the mouse. The default threshold is 50.
		///                 </para>
		///                 <para>
		///                     Use <see cref="SPI.SPI_GETWINARRANGING" /> to determine whether this behavior is enabled.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETSHOWIMEUI 0x006E</term>
		///             <description>
		///                 Determines whether the IME status window is visible (on a per-user basis). The <paramref name="pvParam" /> parameter must point to a
		///                 BOOL variable that receives TRUE if the status window is visible, or FALSE if it is not.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETSNAPSIZING 0x008E</term>
		///             <description>
		///                 <para>
		///                     Determines whether a window is vertically maximized when it is sized to the top or bottom of a monitor or monitor array. The
		///                     <paramref name="pvParam" /> parameter must point to a BOOL variable that receives TRUE if enabled, or FALSE
		///                     otherwise.
		///                 </para>
		///                 <para>
		///                     Use <see cref="SPI.SPI_GETWINARRANGING" /> to determine whether this behavior is enabled.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_GETWINARRANGING 0x0082</term>
		///             <description>
		///                 <para>
		///                     Determines whether window arrangement is enabled. The <paramref name="pvParam" /> parameter must point to a BOOL
		///                     variable that receives TRUE if enabled, or FALSE otherwise.
		///                 </para>
		///                 <para>
		///                     Window arrangement reduces the number of mouse, pen, or touch interactions needed to move and size top-level windows by
		///                     simplifying the default behavior of a window when it is dragged or sized.
		///                 </para>
		///                 <para>The following parameters retrieve individual window arrangement settings:</para>
		///                 <list type="table"></list>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETACTIVEWINDOWTRACKING 0x1001</term>
		///             <description>
		///                 Sets active window tracking (activating the window the mouse is on) either on or off. Set <paramref name="pvParam" /> to TRUE for on
		///                 or FALSE for off.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETACTIVEWNDTRKZORDER 0x100D</term>
		///             <description>
		///                 Determines whether or not windows activated through active window tracking should be brought to the top. Set
		///                 <paramref name="pvParam" /> to TRUE for on or FALSE for off.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETACTIVEWNDTRKTIMEOUT 0x2003</term>
		///             <description>
		///                 Sets the active window tracking delay. Set <paramref name="pvParam" /> to the number of milliseconds to delay before activating the
		///                 window under the mouse pointer.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETANIMATION 0x0049</term>
		///             <description>
		///                 Sets the animation effects associated with user actions. The <paramref name="pvParam" /> parameter must point to an
		///                 <see cref="ANIMATIONINFO" /> structure that contains the new parameters. Set the <see cref="ANIMATIONINFO.cbSize" /> member of this structure and
		///                 the <paramref name="uiParam" /> parameter to sizeof(ANIMATIONINFO).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETBORDER 0x0006</term>
		///             <description>
		///                 Sets the border multiplier factor that determines the width of a window's sizing border. The <paramref name="uiParam" /> parameter
		///                 specifies the new value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETCARETWIDTH 0x2007</term>
		///             <description>
		///                 Sets the caret width in edit controls. Set <paramref name="pvParam" /> to the desired width, in pixels. The default and minimum value
		///                 is 1.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETDOCKMOVING 0x0091</term>
		///             <description>
		///                 <para>
		///                     Sets whether a window is docked when it is moved to the top, left, or right docking targets on a monitor or monitor array. Set
		///                     <paramref name="pvParam" /> to TRUE for on or FALSE for off.
		///                 </para>
		///                 <para>
		///                     <see cref="SPI.SPI_GETWINARRANGING" /> must be TRUE to enable this behavior.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETDRAGFROMMAXIMIZE 0x008D</term>
		///             <description>
		///                 <para>
		///                     Sets whether a maximized window is restored when its caption bar is dragged. Set <paramref name="pvParam" /> to TRUE for on or
		///                     FALSE for off.
		///                 </para>
		///                 <para>
		///                     <see cref="SPI.SPI_GETWINARRANGING" /> must be TRUE to enable this behavior.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETDRAGFULLWINDOWS 0x0025</term>
		///             <description>
		///                 Sets dragging of full windows either on or off. The <paramref name="uiParam" /> parameter specifies TRUE for on, or FALSE for off.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETDRAGHEIGHT 0x004D</term>
		///             <description>
		///                 Sets the height, in pixels, of the rectangle used to detect the start of a drag operation. Set <paramref name="uiParam" /> to the new
		///                 value. To retrieve the drag height, call <see cref="GetSystemMetrics" /> with the <see cref="SM.SM_CYDRAG" /> flag.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETDRAGWIDTH 0x004C</term>
		///             <description>
		///                 Sets the width, in pixels, of the rectangle used to detect the start of a drag operation. Set <paramref name="uiParam" /> to the new
		///                 value. To retrieve the drag width, call <see cref="GetSystemMetrics" /> with the <see cref="SM.SM_CXDRAG" /> flag.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETFOREGROUNDFLASHCOUNT 0x2005</term>
		///             <description>
		///                 Sets the number of times <see cref="SetForegroundWindow" /> will flash the taskbar button when rejecting a foreground switch request.
		///                 Set <paramref name="pvParam" /> to the number of times to flash.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETFOREGROUNDLOCKTIMEOUT 0x2001</term>
		///             <description>
		///                 <para>
		///                     Sets the amount of time following user input, in milliseconds, during which the system does not allow applications to force
		///                     themselves into the foreground. Set <paramref name="pvParam" /> to the new time-out value.
		///                 </para>
		///                 <para>The calling thread must be able to change the foreground window, otherwise the call fails.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMINIMIZEDMETRICS 0x002C</term>
		///             <description>
		///                 Sets the metrics associated with minimized windows. The <paramref name="pvParam" /> parameter must point to a
		///                 <see cref="MINIMIZEDMETRICS" /> structure that contains the new parameters. Set the <see cref="MINIMIZEDMETRICS.cbSize" /> member of this structure
		///                 and the <paramref name="uiParam" /> parameter to sizeof(MINIMIZEDMETRICS).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMOUSEDOCKTHRESHOLD 0x007F</term>
		///             <description>
		///                 <para>
		///                     Sets the threshold in pixels where docking behavior is triggered by using a mouse to drag a window to the edge of a monitor or
		///                     monitor array. The default threshold is 1. The <paramref name="pvParam" /> parameter must point to a DWORD
		///                     variable that contains the new value.
		///                 </para>
		///                 <para>
		///                     <see cref="SPI.SPI_GETWINARRANGING" /> must be TRUE to enable this behavior.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMOUSEDRAGOUTTHRESHOLD 0x0085</term>
		///             <description>
		///                 <para>
		///                     Sets the threshold in pixels where undocking behavior is triggered by using a mouse to drag a window from the edge of a monitor
		///                     or monitor array to its center. The default threshold is 20. The <paramref name="pvParam" /> parameter must point to a
		///                     DWORD variable that contains the new value.
		///                 </para>
		///                 <para>
		///                     <see cref="SPI.SPI_GETWINARRANGING" /> must be TRUE to enable this behavior.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETMOUSESIDEMOVETHRESHOLD 0x0089</term>
		///             <description>
		///                 <para>
		///                     Sets the threshold in pixels from the top of the monitor where a vertically maximized window is restored when dragged with the
		///                     mouse. The default threshold is 50. The <paramref name="pvParam" /> parameter must point to a DWORD variable that
		///                     contains the new value.
		///                 </para>
		///                 <para>
		///                     <see cref="SPI.SPI_GETWINARRANGING" /> must be TRUE to enable this behavior.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETNONCLIENTMETRICS 0x002A</term>
		///             <description>
		///                 Sets the metrics associated with the nonclient area of nonminimized windows. The <paramref name="pvParam" /> parameter must point to
		///                 a <see cref="NONCLIENTMETRICS" /> structure that contains the new parameters. Set the <see cref="NONCLIENTMETRICS.cbSize" /> member of this structure
		///                 and the <paramref name="uiParam" /> parameter to sizeof(NONCLIENTMETRICS). Also, the <see cref="LOGFONT.lfHeight" /> member of the
		///                 <see cref="LOGFONT" /> structure must be a negative value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETPENDOCKTHRESHOLD 0x0081</term>
		///             <description>
		///                 <para>
		///                     Sets the threshold in pixels where docking behavior is triggered by using a pen to drag a window to the edge of a monitor or
		///                     monitor array. The default threshold is 30. The <paramref name="pvParam" /> parameter must point to a DWORD
		///                     variable that contains the new value.
		///                 </para>
		///                 <para>
		///                     <see cref="SPI.SPI_GETWINARRANGING" /> must be TRUE to enable this behavior.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETPENDRAGOUTTHRESHOLD 0x0087</term>
		///             <description>
		///                 <para>
		///                     Sets the threshold in pixels where undocking behavior is triggered by using a pen to drag a window from the edge of a monitor or
		///                     monitor array to its center. The default threshold is 30. The <paramref name="pvParam" /> parameter must point to a
		///                     DWORD variable that contains the new value.
		///                 </para>
		///                 <para>
		///                     <see cref="SPI.SPI_GETWINARRANGING" /> must be TRUE to enable this behavior.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETPENSIDEMOVETHRESHOLD 0x008B</term>
		///             <description>
		///                 <para>
		///                     Sets the threshold in pixels from the top of the monitor where a vertically maximized window is restored when dragged with a pen.
		///                     The default threshold is 50. The <paramref name="pvParam" /> parameter must point to a DWORD variable that
		///                     contains the new value.
		///                 </para>
		///                 <para>
		///                     <see cref="SPI.SPI_GETWINARRANGING" /> must be TRUE to enable this behavior.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETSHOWIMEUI 0x006F</term>
		///             <description>
		///                 Sets whether the IME status window is visible or not on a per-user basis. The <paramref name="uiParam" /> parameter specifies TRUE
		///                 for on or FALSE for off.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETSNAPSIZING 0x008F</term>
		///             <description>
		///                 <para>
		///                     Sets whether a window is vertically maximized when it is sized to the top or bottom of the monitor. Set
		///                     <paramref name="pvParam" /> to TRUE for on or FALSE for off.
		///                 </para>
		///                 <para>
		///                     <see cref="SPI.SPI_GETWINARRANGING" /> must be TRUE to enable this behavior.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPI_SETWINARRANGING 0x0083</term>
		///             <description>
		///                 <para>
		///                     Sets whether window arrangement is enabled. Set <paramref name="pvParam" /> to TRUE for on or FALSE for off.
		///                 </para>
		///                 <para>
		///                     Window arrangement reduces the number of mouse, pen, or touch interactions needed to move and size top-level windows by
		///                     simplifying the default behavior of a window when it is dragged or sized.
		///                 </para>
		///                 <para>The following parameters set individual window arrangement settings:</para>
		///                 <list type="table"></list>
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="uiParam">
		///     A parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide parameters, see
		///     the <paramref name="uiAction" /> parameter. If not otherwise indicated, you must specify zero for this parameter.
		/// </param>
		/// <param name="pvParam">
		///     A parameter whose usage and format depends on the system parameter being queried or set. For more information about system-wide parameters, see
		///     the <paramref name="uiAction" /> parameter. If not otherwise indicated, you must specify NULL for this parameter. For information on the
		///     PVOID datatype, see Windows Data Types.
		/// </param>
		/// <param name="fWinIni">
		///     <para>
		///         If a system parameter is being set, specifies whether the user profile is to be updated, and if so, whether the
		///         <see cref="WM.WM_SETTINGCHANGE" /> message is to be broadcast to all top-level windows to notify them of the change.
		///     </para>
		///     <para>
		///         This parameter can be zero if you do not want to update the user profile or broadcast the <see cref="WM.WM_SETTINGCHANGE" /> message, or it
		///         can be one or more of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>SPIF_UPDATEINIFILE</term>
		///             <description>Writes the new system-wide parameter setting to the user profile.</description>
		///         </item>
		///         <item>
		///             <term>SPIF_SENDCHANGE</term>
		///             <description>
		///                 Broadcasts the <see cref="WM.WM_SETTINGCHANGE" /> message after updating the user profile.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SPIF_SENDWININICHANGE</term>
		///             <description>
		///                 Same as SPIF_SENDCHANGE.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a nonzero value.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>This function is intended for use with applications that allow the user to customize the environment.</para>
		///     <para>
		///         A keyboard layout name should be derived from the hexadecimal value of the language identifier corresponding to the layout. For example, U.S.
		///         English has a language identifier of 0x0409, so the primary U.S. English layout is named "00000409". Variants of U.S. English layout, such as
		///         the Dvorak layout, are named "00010409", "00020409" and so on. For a list of the primary language identifiers and sublanguage identifiers
		///         that make up a language identifier, see the MAKELANGID macro.
		///     </para>
		///     <para>
		///         There is a difference between the High Contrast color scheme and the High Contrast Mode. The High Contrast color scheme changes the system
		///         colors to colors that have obvious contrast; you switch to this color scheme by using the Display Options in the control panel. The High
		///         Contrast Mode, which uses <see cref="SPI.SPI_GETHIGHCONTRAST" /> and <see cref="SPI.SPI_SETHIGHCONTRAST" />, advises applications to modify their
		///         appearance for visually-impaired users. It involves such things as audible warning to users and customized color scheme (using the
		///         Accessibility Options in the control panel). For more information, see <see cref="HIGHCONTRAST" />. For more information on general
		///         accessibility features, see Accessibility.
		///     </para>
		///     <para>
		///         During the time that the primary button is held down to activate the Mouse ClickLock feature, the user can move the mouse. After the primary
		///         button is locked down, releasing the primary button does not result in a <see cref="WM.WM_LBUTTONUP" /> message. Thus, it will appear to an
		///         application that the primary button is still down. Any subsequent button message releases the primary button, sending a
		///         <see cref="WM.WM_LBUTTONUP" /> message to the application, thus the button can be unlocked programmatically or through the user clicking any
		///         button.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SystemParametersInfo")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool SystemParametersInfo(uint uiAction, uint uiParam, IntPtr pvParam, uint fWinIni);

		/// <summary>
		///     The <see cref="SetUserObjectSecurity" /> function sets the security of a user object. This can be, for example, a window or a DDE conversation.
		/// </summary>
		/// <param name="hObj">A handle to a user object for which security information is set.</param>
		/// <param name="pSIRequested">
		///     <para>
		///         A pointer to a value that indicates the components of the security descriptor to set. This parameter can be a combination of the following
		///         values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>DACL_SECURITY_INFORMATION</term>
		///             <description>
		///                 Sets the discretionary access control list (DACL) of the object. The handle specified by <paramref name="hObj" /> must have WRITE_DAC
		///                 access, or the calling process must be the owner of the object.
		///             </description>
		///         </item>
		///         <item>
		///             <term>GROUP_SECURITY_INFORMATION</term>
		///             <description>Sets the primary group security identifier (SID) of the object.</description>
		///         </item>
		///         <item>
		///             <term>OWNER_SECURITY_INFORMATION</term>
		///             <description>
		///                 Sets the SID of the owner of the object. The handle specified by <paramref name="hObj" /> must have WRITE_OWNER access, or the
		///                 calling process must be the owner of the object or have the SE_TAKE_OWNERSHIP_NAME privilege enabled.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SACL_SECURITY_INFORMATION</term>
		///             <description>
		///                 <para>
		///                     Sets the system access control list (SACL) of the object. The handle specified by <paramref name="hObj" /> must have
		///                     ACCESS_SYSTEM_SECURITY access.
		///                 </para>
		///                 <para>To obtain ACCESS_SYSTEM_SECURITY access</para>
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="pSID">
		///     <para>
		///         A pointer to a <see cref="SECURITY_DESCRIPTOR" /> structure that contains the new security information.
		///     </para>
		///     <para>This buffer must be aligned on a 4-byte boundary.</para>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the function returns nonzero.</para>
		///     <para>If the function fails, it returns zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     The <see cref="SetUserObjectSecurity" /> function applies changes specified in a security descriptor to the security descriptor assigned to a
		///     user object. The security descriptor of the object must be in self-relative form. If necessary, this function allocates additional memory to
		///     increase the size of the security descriptor.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetUserObjectSecurity")]
		public static extern bool SetUserObjectSecurity([In] IntPtr hObj, [In] ref uint pSIRequested, [MarshalAs(UnmanagedType.LPStruct)] SECURITY_DESCRIPTOR pSID);

		/// <summary>
		///     <para>[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]</para>
		///     <para>Copies the text of the specified window's title bar (if it has one) into a buffer.</para>
		///     <para>
		///         This function is similar to the <see cref="GetWindowText" /> function. However, it obtains the window text directly from the window structure
		///         associated with the specified window's handle and then always provides the text as a Unicode string. This is unlike
		///         <see cref="GetWindowText" /> which obtains the text by sending the window a <see cref="WM.WM_GETTEXT" /> message. If the specified window is
		///         a control, the text of the control is obtained.
		///     </para>
		/// </summary>
		/// <param name="hWnd">A handle to the window or control containing the text.</param>
		/// <param name="lpString">
		///     The buffer that is to receive the text. If the string is as long or longer than the buffer, the string is truncated and terminated with a null
		///     character.
		/// </param>
		/// <param name="nMaxCount">
		///     The maximum number of characters to be copied to the buffer, including the null character. If the text exceeds this limit, it
		///     is truncated.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is the length, in characters, of the copied string, not including the terminating null character.
		///         If the window has no title bar or text, if the title bar is empty, or if the window or control handle is invalid, the return value is zero.
		///         To get extended error information, call GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     This function was not included in the SDK headers and libraries until Windows XP with Service Pack 1 (SP1) and Windows Server 2003. If you do not
		///     have a header file and import library for this function, you can call the function using LoadLibrary and
		///     GetProcAddress.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "InternalGetWindowText")]
		public static extern int InternalGetWindowText([In] IntPtr hWnd, [Out] [MarshalAs(UnmanagedType.LPWStr)] StringBuilder lpString, int nMaxCount);

		/// <summary>
		///     The <see cref="GetUserObjectSecurity" /> function retrieves security information for the specified user object.
		/// </summary>
		/// <param name="hObj">A handle to the user object for which to return security information.</param>
		/// <param name="pSIRequested">
		///     A pointer to a SECURITY_INFORMATION value that specifies the security information being requested.
		/// </param>
		/// <param name="pSD">
		///     A pointer to a <see cref="SECURITY_DESCRIPTOR"/> structure in self-relative format that contains the requested information when
		///     the function returns. This buffer must be aligned on a 4-byte boundary.
		/// </param>
		/// <param name="nLength">
		///     The length, in bytes, of the buffer pointed to by the <paramref name="pSD" /> parameter.
		/// </param>
		/// <param name="lpnLengthNeeded">
		///     A pointer to a variable to receive the number of bytes required to store the complete security descriptor. If this variable's value is greater
		///     than the value of the <paramref name="nLength" /> parameter when the function returns, the function returns FALSE and none of the security
		///     descriptor is copied to the buffer. Otherwise, the entire security descriptor is copied.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the function returns nonzero.</para>
		///     <para>If the function fails, it returns zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         To read the owner, group, or discretionary access control list (DACL) from the user object's security descriptor, the calling process must
		///         have been granted READ_CONTROL access when the handle was opened.
		///     </para>
		///     <para>
		///         To read the system access control list (SACL) from the security descriptor, the calling process must have been granted ACCESS_SYSTEM_SECURITY
		///         access when the handle was opened. The correct way to get this access is to enable the SE_SECURITY_NAME privilege in the caller's current
		///         token, open the handle for ACCESS_SYSTEM_SECURITY access, and then disable the privilege.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetUserObjectSecurity")]
		public static extern bool GetUserObjectSecurity([In] IntPtr hObj, [In] ref uint pSIRequested, ref SECURITY_DESCRIPTOR pSD, uint nLength, [Out] out uint lpnLengthNeeded);

		/// <summary>Enumerates the raw input devices attached to the system.</summary>
		/// <param name="pRawInputDeviceList">
		///     An array of <see cref="RAWINPUTDEVICELIST" /> structures for the devices attached to the system. If NULL, the number of devices are returned in *
		///     <paramref name="puiNumDevices" />.
		/// </param>
		/// <param name="puiNumDevices">
		///     If <paramref name="pRawInputDeviceList" /> is NULL, the function populates this variable with the number of devices attached to the system;
		///     otherwise, this variable specifies the number of <see cref="RAWINPUTDEVICELIST" /> structures that can be contained in the buffer to which
		///     <paramref name="pRawInputDeviceList" /> points. If this value is less than the number of devices attached to the system, the function returns the
		///     actual number of devices in this variable and fails with ERROR_INSUFFICIENT_BUFFER.
		/// </param>
		/// <param name="cbSize">
		///     The size of a <see cref="RAWINPUTDEVICELIST" /> structure, in bytes.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function is successful, the return value is the number of devices stored in the buffer pointed to by
		///         <paramref name="pRawInputDeviceList" />.
		///     </para>
		///     <para>On any other error, the function returns (UINT) -1 and GetLastError returns the error indication.</para>
		/// </returns>
		/// <remarks>
		///     <para>The devices returned from this function are the mouse, the keyboard, and other Human Interface Device (HID) devices.</para>
		///     <para>
		///         To get more detailed information about the attached devices, call <see cref="GetRawInputDeviceInfo" /> using the hDevice from
		///         <see cref="RAWINPUTDEVICELIST" />.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetRawInputDeviceList")]
		public static extern uint GetRawInputDeviceList(ref RAWINPUTDEVICELIST[] pRawInputDeviceList, ref uint puiNumDevices, uint cbSize);

		/// <summary>
		///     Retrieves the input locale identifiers (formerly called keyboard layout handles) corresponding to the current set of input locales in the system.
		///     The function copies the identifiers to the specified buffer.
		/// </summary>
		/// <param name="nBuff">The maximum number of handles that the buffer can hold.</param>
		/// <param name="lpList">A pointer to the buffer that receives the array of input locale identifiers.</param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is the number of input locale identifiers copied to the buffer or, if <paramref name="nBuff" /> is
		///         zero, the return value is the size, in array elements, of the buffer needed to receive all current input locale identifiers.
		///     </para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input
		///         Method Editor (IME), or any other form of input.
		///     </para>
		///     <para>
		///         Beginning in Windows 8: The preferred method to retrieve the language associated with the current keyboard layout or input method is a call
		///         to Windows.Globalization.Language.CurrentInputMethodLanguageTag. If your app passes language tags from
		///         CurrentInputMethodLanguageTag to any National Language Support functions, it must first convert the tags by calling
		///         ResolveLocaleName.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetKeyboardLayoutList")]
		public static extern int GetKeyboardLayoutList(int nBuff, ref IntPtr lpList);

		/// <summary>Abandons the specified asynchronous transaction and releases all resources associated with the transaction.</summary>
		/// <param name="idInst">
		///     The application instance identifier obtained by a previous call to the <see cref="DdeInitialize" /> function.
		/// </param>
		/// <param name="hConv">
		///     A handle to the conversation in which the transaction was initiated. If this parameter is 0L, all transactions are abandoned (that is, the
		///     <paramref name="idTransaction" /> parameter is ignored).
		/// </param>
		/// <param name="idTransaction">
		///     The identifier of the transaction to be abandoned. If this parameter is 0L, all active transactions in the specified
		///     conversation are abandoned.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		/// <remarks>
		///     Only a Dynamic Data Exchange (DDE) client application should call <see cref="DdeAbandonTransaction" />. If the server application responds to the
		///     transaction after the client has called <see cref="DdeAbandonTransaction" />, the system discards the transaction results. This function has no
		///     effect on synchronous transactions.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DdeAbandonTransaction")]
		public static extern bool DdeAbandonTransaction(uint idInst, IntPtr hConv, uint idTransaction);

		/// <summary>Retrieves the number of different data formats currently on the clipboard.</summary>
		/// <returns>
		///     <para>If the function succeeds, the return value is the number of different data formats currently on the clipboard.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "CountClipboardFormats")]
		public static extern int CountClipboardFormats();

		/// <summary>
		///     Copies the specified accelerator table. This function is used to obtain the accelerator-table data that corresponds to an accelerator-table
		///     handle, or to determine the size of the accelerator-table data.
		/// </summary>
		/// <param name="hAccelSrc">A handle to the accelerator table to copy.</param>
		/// <param name="lpAccelDst">
		///     An array of <see cref="ACCEL" /> structures that receives the accelerator-table information.
		/// </param>
		/// <param name="cAccelEntries">
		///     The number of <see cref="ACCEL" /> structures to copy to the buffer pointed to by the <paramref name="lpAccelDst" /> parameter.
		/// </param>
		/// <returns>
		///     If <paramref name="lpAccelDst" /> is NULL, the return value specifies the number of accelerator-table entries in the original table. Otherwise,
		///     it specifies the number of accelerator-table entries that were copied.
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "CopyAcceleratorTable")]
		public static extern int CopyAcceleratorTable([In] IntPtr hAccelSrc, IntPtr lpAccelDst, int cAccelEntries);

		/// <summary>Unloads an input locale identifier (formerly called a keyboard layout).</summary>
		/// <param name="hkl">The input locale identifier to be unloaded.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. The function can fail for the following reasons:</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input
		///         Method Editor (IME), or any other form of input.
		///     </para>
		///     <para>
		///         <see cref="UnloadKeyboardLayout" /> cannot unload the system default input locale identifier if it is the only keyboard layout loaded. You
		///         must first load another input locale identifier before unloading the default input locale identifier.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "UnloadKeyboardLayout")]
		public static extern bool UnloadKeyboardLayout([In] IntPtr hkl);

		/// <summary>
		///     Processes accelerator keystrokes for window menu commands of the multiple-document interface (MDI) child windows associated with the specified
		///     MDI client window. The function translates <see cref="WM.WM_KEYUP" /> and <see cref="WM.WM_KEYDOWN" /> messages to
		///     <see cref="WM.WM_SYSCOMMAND" />
		///     messages and sends them to the appropriate MDI child windows.
		/// </summary>
		/// <param name="hWndClient">A handle to the MDI client window.</param>
		/// <param name="lpMsg">
		///     A pointer to a message retrieved by using the <see cref="GetMessage" /> or <see cref="PeekMessage" /> function. The message must be an
		///     <see cref="MSG" /> structure and contain message information from the application's message queue.
		/// </param>
		/// <returns>
		///     <para>If the message is translated into a system command, the return value is nonzero.</para>
		///     <para>If the message is not translated into a system command, the return value is zero.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "TranslateMDISysAccel")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool TranslateMDISysAccel([In] IntPtr hWndClient, [In] ref MSG lpMsg);

		/// <summary>Associates a Help context identifier with a menu.</summary>
		/// <param name="hmenu">A handle to the menu with which to associate the Help context identifier.</param>
		/// <param name="dwContextHelpId">The help context identifier.</param>
		/// <returns>
		///     <para>Returns nonzero if successful, or zero otherwise.</para>
		///     <para>To retrieve extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>All items in the menu share this identifier. Help context identifiers can't be attached to individual menu items.</remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetMenuContextHelpId")]
		public static extern bool SetMenuContextHelpId([In] IntPtr hmenu, uint dwContextHelpId);

		/// <summary>
		///     Sends the specified message to a window or windows. It calls the window procedure for the specified window and returns immediately if the window
		///     belongs to another thread. After the window procedure processes the message, the system calls the specified callback function, passing the result
		///     of the message processing and an application-defined value to the callback function.
		/// </summary>
		/// <param name="hWnd">
		///     A handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the
		///     message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows;
		///     but the message is not sent to child windows.
		/// </param>
		/// <param name="Msg">
		///     <para>The message to be sent.</para>
		///     <para>For lists of the system-provided messages, see System-Defined Messages.</para>
		/// </param>
		/// <param name="wParam">Additional message-specific information.</param>
		/// <param name="lParam">Additional message-specific information.</param>
		/// <param name="lpCallBack">
		///     <para>
		///         A pointer to a callback function that the system calls after the window procedure processes the message. For more information, see
		///         <see cref="SendAsyncProc" />.
		///     </para>
		///     <para>
		///         If <paramref name="hWnd" /> is HWND_BROADCAST ((HWND)0xffff), the system calls the <see cref="SendAsyncProc" /> callback
		///         function once for each top-level window.
		///     </para>
		/// </param>
		/// <param name="dwData">
		///     An application-defined value to be sent to the callback function pointed to by the <paramref name="lpCallBack" /> parameter.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If the target window belongs to the same thread as the caller, then the window procedure is called synchronously, and the callback function
		///         is called immediately after the window procedure returns. If the target window belongs to a different thread from the caller, then the
		///         callback function is called only when the thread that called <see cref="SendMessageCallback" /> also calls <see cref="GetMessage" />,
		///         <see cref="PeekMessage" />, or <see cref="WaitMessage" />.
		///     </para>
		///     <para>
		///         If you send a message in the range below <see cref="WM.WM_USER" /> to the asynchronous message functions (<see cref="PostMessage" />,
		///         <see cref="SendNotifyMessage" />, and <see cref="SendMessageCallback" />), its message parameters cannot include pointers. Otherwise, the
		///         operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free
		///         the memory before it is used.
		///     </para>
		///     <para>
		///         Applications that need to communicate using HWND_BROADCAST should use the <see cref="RegisterWindowMessage" /> function to
		///         obtain a unique message for inter-application communication.
		///     </para>
		///     <para>
		///         The system only does marshalling for system messages (those in the range 0 to (<see cref="WM.WM_USER" />-1)). To send other messages (those
		///         >=
		///         <see cref="WM.WM_USER" />) to another process, you must do custom marshalling.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SendMessageCallback")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool SendMessageCallback(
			[In] IntPtr hWnd, uint Msg, [MarshalAs(UnmanagedType.SysUInt)] uint wParam, [MarshalAs(UnmanagedType.SysInt)] int lParam,
			SendAsyncProc lpCallBack, uint dwData);

		/// <summary>
		///     <para>[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]</para>
		///     <para>Creates an array of handles to icons that are extracted from a specified file.</para>
		/// </summary>
		/// <param name="lpszFile">The path and name of the file from which the icon(s) are to be extracted.</param>
		/// <param name="nIconIndex">
		///     The zero-based index of the first icon to extract. For example, if this value is zero, the function extracts the first icon
		///     in the specified file.
		/// </param>
		/// <param name="cxIcon">The horizontal icon size wanted. See Remarks.</param>
		/// <param name="cyIcon">The vertical icon size wanted. See Remarks.</param>
		/// <param name="phicon">A pointer to the returned array of icon handles.</param>
		/// <param name="piconid">
		///     A pointer to a returned resource identifier for the icon that best fits the current display device. The returned identifier is 0xFFFFFFFF if the
		///     identifier is not available for this format. The returned identifier is 0 if the identifier cannot otherwise be obtained.
		/// </param>
		/// <param name="nIcons">The number of icons to extract from the file. This parameter is only valid when extracting from .exe and .dll files.</param>
		/// <param name="flags">
		///     Specifies flags that control this function. These flags are the LR_* flags used by the <see cref="LoadImage" /> function.
		/// </param>
		/// <returns>
		///     <para>
		///         If the <paramref name="phicon" /> parameter is NULL and this function succeeds, then the return value is the number of icons in the file. If
		///         the function fails then the return value is 0.
		///     </para>
		///     <para>
		///         If the <paramref name="phicon" /> parameter is not NULL and the function succeeds, then the return value is the number of icons extracted.
		///         Otherwise, the return value is 0xFFFFFFFF if the file is not found.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         This function extracts from executable (.exe), DLL (.dll), icon (.ico), cursor (.cur), animated cursor (.ani), and bitmap (.bmp) files.
		///         Extractions from Windows 3.x 16-bit executables (.exe or .dll) are also supported.
		///     </para>
		///     <para>
		///         The <paramref name="cxIcon" /> and <paramref name="cyIcon" /> parameters specify the size of the icons to extract. Two sizes can be extracted
		///         by putting the first size in the LOWORD of the parameter and the second size in the HIWORD. For example, MAKELONG(24, 48) for both the cxIcon
		///         and cyIcon parameters would extract both 24 and 48 size icons.
		///     </para>
		///     <para>
		///         You must destroy all icons extracted by <see cref="PrivateExtractIcons" /> by calling the <see cref="DestroyIcon" /> function.
		///     </para>
		///     <para>
		///         This function was not included in the SDK headers and libraries until Windows XP Service Pack 1 (SP1) and Windows Server 2003. If you do not
		///         have a header file and import library for this function, you can call the function using LoadLibrary and GetProcAddress.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "PrivateExtractIcons")]
		public static extern uint PrivateExtractIcons(
			[In] string lpszFile, int nIconIndex, int cxIcon, int cyIcon, ref IntPtr phicon, IntPtr piconid, uint nIcons, LR flags);

		/// <summary>
		///     Retrieves the length, in characters, of the specified window's title bar text (if the window has a title bar). If the specified window is a
		///     control, the function retrieves the length of the text within the control. However, <see cref="GetWindowTextLength" /> cannot retrieve the length
		///     of the text of an edit control in another application.
		/// </summary>
		/// <param name="hWnd">A handle to the window or control.</param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is the length, in characters, of the text. Under certain conditions, this value may actually be
		///         greater than the length of the text. For more information, see the following Remarks section.
		///     </para>
		///     <para>If the window has no text, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If the target window is owned by the current process, <see cref="GetWindowTextLength" /> causes a <see cref="WM.WM_GETTEXTLENGTH" /> message
		///         to be sent to the specified window or control.
		///     </para>
		///     <para>
		///         Under certain conditions, the <see cref="GetWindowTextLength" /> function may return a value that is larger than the actual length of the
		///         text. This occurs with certain mixtures of ANSI and Unicode, and is due to the system allowing for the possible existence of double-byte
		///         character set (DBCS) characters within the text. The return value, however, will always be at least as large as the actual length of the
		///         text; you can thus always use it to guide buffer allocation. This behavior can occur when an application uses both ANSI functions and common
		///         dialogs, which use Unicode. It can also occur when an application uses the ANSI version of <see cref="GetWindowTextLength" /> with a window
		///         whose window procedure is Unicode, or the Unicode version of <see cref="GetWindowTextLength" /> with a window whose window procedure is ANSI.
		///         For more information on ANSI and ANSI functions, see Conventions for Function Prototypes.
		///     </para>
		///     <para>
		///         To obtain the exact length of the text, use the <see cref="WM.WM_GETTEXT" />, <see cref="LB.LB_GETTEXT" />, or <see cref="CB.CB_GETLBTEXT" />
		///         messages, or the <see cref="GetWindowText" /> function.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetWindowTextLength")]
		public static extern int GetWindowTextLength([In] IntPtr hWnd);

		/// <summary>
		///     The <see cref="GetTabbedTextExtent" /> function computes the width and height of a character string. If the string contains one or more tab
		///     characters, the width of the string is based upon the specified tab stops. The <see cref="GetTabbedTextExtent" /> function uses the currently
		///     selected font to compute the dimensions of the string.
		/// </summary>
		/// <param name="hDC">A handle to the device context.</param>
		/// <param name="lpString">A pointer to a character string.</param>
		/// <param name="nCount">
		///     The length of the text string. For the ANSI function it is a BYTE count and for the Unicode function it is a WORD count. Note that for the ANSI
		///     function, characters in SBCS code pages take one byte each, while most characters in DBCS code pages take two bytes; for the Unicode function,
		///     most currently defined Unicode characters (those in the Basic Multilingual Plane (BMP)) are one WORD while Unicode surrogates are two WORDs.
		/// </param>
		/// <param name="nTabPositions">
		///     The number of tab-stop positions in the array pointed to by the <paramref name="lpnTabStopPositions" /> parameter.
		/// </param>
		/// <param name="lpnTabStopPositions">
		///     A pointer to an array containing the tab-stop positions, in device units. The tab stops must be sorted in increasing order; the smallest x-value
		///     should be the first item in the array.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is the dimensions of the string in logical units. The height is in the high-order word and the
		///         width is in the low-order word.
		///     </para>
		///     <para>
		///         If the function fails, the return value is 0. <see cref="GetTabbedTextExtent" /> will fail if <paramref name="hDC" /> is invalid and if
		///         <paramref name="nTabPositions" /> is less than 0.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The current clipping region does not affect the width and height returned by the <see cref="GetTabbedTextExtent" /> function.
		///     </para>
		///     <para>
		///         Because some devices do not place characters in regular cell arrays (that is, they kern the characters), the sum of the extents of the
		///         characters in a string may not be equal to the extent of the string.
		///     </para>
		///     <para>
		///         If the <paramref name="nTabPositions" /> parameter is zero and the <paramref name="lpnTabStopPositions" /> parameter is NULL, tabs are
		///         expanded to eight times the average character width.
		///     </para>
		///     <para>
		///         If <paramref name="nTabPositions" /> is 1, the tab stops are separated by the distance specified by the first value in the array to which
		///         <paramref name="lpnTabStopPositions" /> points.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetTabbedTextExtent")]
		public static extern uint GetTabbedTextExtent([In] IntPtr hDC, [In] string lpString, int nCount, int nTabPositions, [In] IntPtr lpnTabStopPositions);

		/// <summary>Retrieves a history of up to 64 previous coordinates of the mouse or pen.</summary>
		/// <param name="cbSize">
		///     The size, in bytes, of the <see cref="MOUSEMOVEPOINT" /> structure.
		/// </param>
		/// <param name="lppt">
		///     <para>
		///         A pointer to a <see cref="MOUSEMOVEPOINT" /> structure containing valid mouse coordinates (in screen coordinates). It may also contain a time
		///         stamp.
		///     </para>
		///     <para>
		///         The <see cref="GetMouseMovePointsEx" /> function searches for the point in the mouse coordinates history. If the function finds the point, it
		///         returns the last <paramref name="nBufPoints" /> prior to and including the supplied point.
		///     </para>
		///     <para>
		///         If your application supplies a time stamp, the <see cref="GetMouseMovePointsEx" /> function will use it to differentiate between two equal
		///         points that were recorded at different times.
		///     </para>
		///     <para>
		///         An application should call this function using the mouse coordinates received from the <see cref="WM.WM_MOUSEMOVE" /> message and convert
		///         them to screen coordinates.
		///     </para>
		/// </param>
		/// <param name="lpptBuf">
		///     A pointer to a buffer that will receive the points. It should be at least <paramref name="cbSize" />* <paramref name="nBufPoints" /> in size.
		/// </param>
		/// <param name="nBufPoints">The number of points to be retrieved.</param>
		/// <param name="resolution">
		///     <para>The resolution desired. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>GMMP_USE_DISPLAY_POINTS 1</term>
		///             <description>Retrieves the points using the display resolution.</description>
		///         </item>
		///         <item>
		///             <term>GMMP_USE_HIGH_RESOLUTION_POINTS 2</term>
		///             <description>
		///                 Retrieves high resolution points. Points can range from zero to 65,535 (0xFFFF) in both x- and y-coordinates. This is the resolution
		///                 provided by absolute coordinate pointing devices such as drawing tablets.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     If the function succeeds, the return value is the number of points in the buffer. Otherwise, the function returns –1. For extended error
		///     information, your application can call GetLastError.
		/// </returns>
		/// <remarks>
		///     <para>
		///         The system retains the last 64 mouse coordinates and their time stamps. If your application supplies a mouse coordinate to
		///         <see cref="GetMouseMovePointsEx" /> and the coordinate exists in the system's mouse coordinate history, the function retrieves the specified
		///         number of coordinates from the systems' history. You can also supply a time stamp, which will be used to differentiate between identical
		///         points in the history.
		///     </para>
		///     <para>
		///         The <see cref="GetMouseMovePointsEx" /> function will return points that eventually were dispatched not only to the calling thread but also
		///         to other threads.
		///     </para>
		///     <para>
		///         <see cref="GetMouseMovePointsEx" /> may fail or return erroneous values in the following cases:
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetMouseMovePointsEx")]
		public static extern int GetMouseMovePointsEx(uint cbSize, [In] ref MOUSEMOVEPOINT lppt, IntPtr lpptBuf, int nBufPoints, uint resolution);

		/// <summary>Retrieves the Help context identifier associated with the specified menu.</summary>
		/// <param name="hmenu">A handle to the menu for which the Help context identifier is to be retrieved.</param>
		/// <returns>Returns the Help context identifier if the menu has one, or zero otherwise.</returns>
		[DllImport("user32.dll", EntryPoint = "GetMenuContextHelpId")]
		public static extern uint GetMenuContextHelpId([In] IntPtr hmenu);

		/// <summary>
		///     <para>
		///         The <see cref="EnumDisplaySettings" /> function retrieves information about one of the graphics modes for a display device. To retrieve
		///         information for all the graphics modes of a display device, make a series of calls to this function.
		///     </para>
		///     <para>
		///         Note:  Apps that you design to target Windows 8 and later can no longer query or set display modes that are less than 32 bits per pixel
		///         (bpp); these operations will fail. These apps have a compatibility manifest that targets Windows 8. Windows 8 still supports 8-bit and 16-bit
		///         color modes for desktop apps that were built without a Windows 8 manifest; Windows 8 emulates these modes but still runs in 32-bit color
		///         mode.
		///     </para>
		/// </summary>
		/// <param name="lpszDeviceName">
		///     <para>A pointer to a null-terminated string that specifies the display device about whose graphics mode the function will obtain information.</para>
		///     <para>
		///         This parameter is either NULL or a <see cref="DISPLAY_DEVICE" />.<see cref="DISPLAY_DEVICE.DeviceName" /> returned from <see cref="EnumDisplayDevices" />. A
		///         NULL value specifies the current display device on the computer on which the calling thread is running.
		///     </para>
		/// </param>
		/// <param name="iModeNum">
		///     <para>The type of information to be retrieved. This value can be a graphics mode index or one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>ENUM_CURRENT_SETTINGS</term>
		///             <description>Retrieve the current settings for the display device.</description>
		///         </item>
		///         <item>
		///             <term>ENUM_REGISTRY_SETTINGS</term>
		///             <description>Retrieve the settings for the display device that are currently stored in the registry.</description>
		///         </item>
		///     </list>
		///     <para>
		///         Graphics mode indexes start at zero. To obtain information for all of a display device's graphics modes, make a series of calls to
		///         <see cref="EnumDisplaySettings" />, as follows: Set <paramref name="iModeNum" /> to zero for the first call, and increment
		///         <paramref name="iModeNum" /> by one for each subsequent call. Continue calling the function until the return value is zero.
		///     </para>
		///     <para>
		///         When you call <see cref="EnumDisplaySettings" /> with <paramref name="iModeNum" /> set to zero, the operating system initializes and caches
		///         information about the display device. When you call <see cref="EnumDisplaySettings" /> with <paramref name="iModeNum" /> set to a nonzero
		///         value, the function returns the information that was cached the last time the function was called with <paramref name="iModeNum" /> set to
		///         zero.
		///     </para>
		/// </param>
		/// <param name="lpDevMode">
		///     <para>
		///         A pointer to a <see cref="DEVMODE" /> structure into which the function stores information about the specified graphics mode. Before calling
		///         <see cref="EnumDisplaySettings" />, set the <see cref="DEVMODE.dmSize" /> member to sizeof(DEVMODE), and set the <see cref="DEVMODE.dmDriverExtra" /> member
		///         to indicate the size, in bytes, of the additional space available to receive private driver data.
		///     </para>
		///     <para>
		///         The <see cref="EnumDisplaySettings" /> function sets values for the following five <see cref="DEVMODE" /> members:
		///     </para>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     The function fails if <paramref name="iModeNum" /> is greater than the index of the display device's last graphics mode. As noted in the
		///     description of the <paramref name="iModeNum" /> parameter, you can use this behavior to enumerate all of a display device's graphics modes.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "EnumDisplaySettings")]
		public static extern bool EnumDisplaySettings(
			[In] [MarshalAs(UnmanagedType.LPWStr)] string lpszDeviceName, int iModeNum, ref DEVMODE lpDevMode);

		/// <summary>
		///     <para>Enumerates the data formats currently available on the clipboard.</para>
		///     <para>
		///         Clipboard data formats are stored in an ordered list. To perform an enumeration of clipboard data formats, you make a series of calls to the
		///         <see cref="EnumClipboardFormats" /> function. For each call, the <paramref name="format" /> parameter specifies an available clipboard
		///         format, and the function returns the next available clipboard format.
		///     </para>
		/// </summary>
		/// <param name="format">
		///     <para>A clipboard format that is known to be available.</para>
		///     <para>
		///         To start an enumeration of clipboard formats, set <paramref name="format" /> to zero. When <paramref name="format" /> is zero, the function
		///         retrieves the first available clipboard format. For subsequent calls during an enumeration, set <paramref name="format" /> to the result of
		///         the previous <see cref="EnumClipboardFormats" /> call.
		///     </para>
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is the clipboard format that follows the specified format, namely the next available clipboard
		///         format.
		///     </para>
		///     <para>
		///         If the function fails, the return value is zero. To get extended error information, call GetLastError. If the clipboard is not open, the
		///         function fails.
		///     </para>
		///     <para>
		///         If there are no more clipboard formats to enumerate, the return value is zero. In this case, the GetLastError function returns the value
		///         ERROR_SUCCESS. This lets you distinguish between function failure and the end of enumeration.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         You must open the clipboard before enumerating its formats. Use the <see cref="OpenClipboard" /> function to open the clipboard. The
		///         <see cref="EnumClipboardFormats" /> function fails if the clipboard is not open.
		///     </para>
		///     <para>
		///         The <see cref="EnumClipboardFormats" /> function enumerates formats in the order that they were placed on the clipboard. If you are copying
		///         information to the clipboard, add clipboard objects in order from the most descriptive clipboard format to the least descriptive clipboard
		///         format. If you are pasting information from the clipboard, retrieve the first clipboard format that you can handle. That will be the most
		///         descriptive clipboard format that you can handle.
		///     </para>
		///     <para>
		///         The system provides automatic type conversions for certain clipboard formats. In the case of such a format, this function enumerates the
		///         specified format, then enumerates the formats to which it can be converted. For more information, see Standard Clipboard Formats and
		///         Synthesized Clipboard Formats.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "EnumClipboardFormats")]
		public static extern uint EnumClipboardFormats(uint format);

		/// <summary>Impersonates a Dynamic Data Exchange (DDE) client application in a DDE client conversation.</summary>
		/// <param name="hConv">A handle to the DDE client conversation to be impersonated.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Impersonation is the ability of a process to take on the security attributes of another process. When a client in a DDE conversation requests
		///         information from a DDE server, the server impersonates the client. When the server requests access to an object, the system verifies the
		///         access against the client's security attributes.
		///     </para>
		///     <para>
		///         When the impersonation is complete, the server normally calls the RevertToSelf function.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DdeImpersonateClient")]
		public static extern bool DdeImpersonateClient(IntPtr hConv);

		/// <summary>
		///     Begins a data transaction between a client and a server. Only a Dynamic Data Exchange (DDE) client application can call this function, and the
		///     application can use it only after establishing a conversation with the server.
		/// </summary>
		/// <param name="pData">
		///     <para>The beginning of the data the client must pass to the server.</para>
		///     <para>
		///         Optionally, an application can specify the data handle (HDDEDATA) to pass to the server and in that case the
		///         <paramref name="cbData" /> parameter should be set to -1. This parameter is required only if the <paramref name="wType" /> parameter is
		///         XTYP_EXECUTE or XTYP_POKE. Otherwise, this parameter should be NULL.
		///     </para>
		///     <para>
		///         For the optional usage of this parameter, XTYP_POKE transactions where <paramref name="pData" /> is a data handle, the handle
		///         must have been created by a previous call to the <see cref="DdeCreateDataHandle" /> function, employing the same data format specified in the
		///         <paramref name="wFmt" /> parameter.
		///     </para>
		/// </param>
		/// <param name="cbData">
		///     The length, in bytes, of the data pointed to by the <paramref name="pData" /> parameter, including the terminating NULL, if the data is a string.
		///     A value of -1 indicates that <paramref name="pData" /> is a data handle that identifies the data being sent.
		/// </param>
		/// <param name="hConv">A handle to the conversation in which the transaction is to take place.</param>
		/// <param name="hszItem">
		///     A handle to the data item for which data is being exchanged during the transaction. This handle must have been created by a previous call to the
		///     <see cref="DdeCreateStringHandle" /> function. This parameter is ignored (and should be set to 0L) if the <paramref name="wType" /> parameter is
		///     XTYP_EXECUTE.
		/// </param>
		/// <param name="wFmt">
		///     <para>The standard clipboard format in which the data item is being submitted or requested.</para>
		///     <para>
		///         If the transaction specified by the <paramref name="wType" /> parameter does not pass data or is XTYP_EXECUTE, this parameter
		///         should be zero.
		///     </para>
		///     <para>
		///         If the transaction specified by the <paramref name="wType" /> parameter references non-execute DDE data (XTYP_POKE,
		///         XTYP_ADVSTART, XTYP_ADVSTOP, XTYP_REQUEST), the <paramref name="wFmt" /> value must be either a
		///         valid predefined (CF_) DDE format or a valid registered clipboard format.
		///     </para>
		/// </param>
		/// <param name="wType">
		///     <para>The transaction type. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>XTYP_ADVSTART 0x1030</term>
		///             <description>
		///                 <para>
		///                     Begins an advise loop. Any number of distinct advise loops can exist within a conversation. An application can alter the advise
		///                     loop type by combining the XTYP_ADVSTART transaction type with one or more of the following flags:
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>XTYP_ADVSTOP 0x8040</term>
		///             <description>Ends an advise loop.</description>
		///         </item>
		///         <item>
		///             <term>XTYP_EXECUTE 0x4050</term>
		///             <description>Begins an execute transaction.</description>
		///         </item>
		///         <item>
		///             <term>XTYP_POKE 0x4090</term>
		///             <description>Begins a poke transaction.</description>
		///         </item>
		///         <item>
		///             <term>XTYP_REQUEST 0x20B0</term>
		///             <description>Begins a request transaction.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="dwTimeout">
		///     The maximum amount of time, in milliseconds, that the client will wait for a response from the server application in a synchronous transaction.
		///     This parameter should be TIMEOUT_ASYNC for asynchronous transactions.
		/// </param>
		/// <param name="pdwResult">
		///     A pointer to a variable that receives the result of the transaction. An application that does not check the result can use NULL for this value.
		///     For synchronous transactions, the low-order word of this variable contains any applicable DDE_ flags resulting from the transaction. This
		///     provides support for applications dependent on DDE_APPSTATUS bits. It is, however, recommended that applications no longer use
		///     these bits because they may not be supported in future versions of the Dynamic Data Exchange Management Library (DDEML). For asynchronous
		///     transactions, this variable is filled with a unique transaction identifier for use with the <see cref="DdeAbandonTransaction" /> function and the
		///     XTYP_XACT_COMPLETE transaction.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is a data handle that identifies the data for successful synchronous transactions in which the
		///         client expects data from the server. The return value is nonzero for successful asynchronous transactions and for synchronous transactions in
		///         which the client does not expect data. The return value is zero for all unsuccessful transactions.
		///     </para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         When an application has finished using the data handle returned by <see cref="DdeClientTransaction" />, the application should free the
		///         handle by calling the <see cref="DdeFreeDataHandle" /> function.
		///     </para>
		///     <para>
		///         Transactions can be synchronous or asynchronous. During a synchronous transaction, <see cref="DdeClientTransaction" /> does not return until
		///         the transaction either completes successfully or fails. Synchronous transactions cause a client to enter a modal loop while waiting for
		///         various asynchronous events. Because of this, a client application can still respond to user input while waiting on a synchronous
		///         transaction, but the application cannot begin a second synchronous transaction because of the activity associated with the first.
		///         <see cref="DdeClientTransaction" /> fails if any instance of the same task has a synchronous transaction already in progress.
		///     </para>
		///     <para>
		///         During an asynchronous transaction, <see cref="DdeClientTransaction" /> returns after the transaction has begun, passing a transaction
		///         identifier for reference. When the server's DDE callback function finishes processing an asynchronous transaction, the system sends an
		///         XTYP_XACT_COMPLETE transaction to the client. This transaction provides the client with the results of the asynchronous
		///         transaction that it initiated by calling <see cref="DdeClientTransaction" />. A client application can choose to abandon an asynchronous
		///         transaction by calling the <see cref="DdeAbandonTransaction" /> function.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DdeClientTransaction")]
		public static extern IntPtr DdeClientTransaction(
			ref byte pData, uint cbData, IntPtr hConv, IntPtr hszItem, uint wFmt, uint wType, uint dwTimeout, ref uint pdwResult);

		/// <summary>Creates a window station object, associates it with the calling process, and assigns it to the current session.</summary>
		/// <param name="lpwinsta">
		///     The name of the window station to be created. Window station names are case-insensitive and cannot contain backslash characters (\). Only members
		///     of the Administrators group are allowed to specify a name. If <paramref name="lpwinsta" /> is NULL or an empty string, the system forms a window
		///     station name using the logon session identifier for the calling process. To get this name, call the <see cref="GetUserObjectInformation" />
		///     function.
		/// </param>
		/// <param name="dwFlags">
		///     <para>
		///         If this parameter is CWF_CREATE_ONLY and the window station already exists, the call fails. If this flag is not specified and the window
		///         station already exists, the function succeeds and returns a new handle to the existing window station.
		///     </para>
		/// </param>
		/// <param name="dwDesiredAccess">
		///     The type of access the returned handle has to the window station. In addition, you can specify any of the standard access rights, such as
		///     READ_CONTROL or WRITE_DAC, and a combination of the window station-specific access rights. For more information, see Window Station Security and
		///     Access Rights.
		/// </param>
		/// <param name="lpsa">
		///     <para>
		///         A pointer to a <see cref="SECURITY_ATTRIBUTES" /> structure that determines whether the returned handle can be inherited by child processes.
		///         If <paramref name="lpsa" /> is NULL, the handle cannot be inherited.
		///     </para>
		///     <para>
		///         The <see cref="SECURITY_ATTRIBUTES.lpSecurityDescriptor" /> member of the structure specifies a security descriptor for the new window station. If
		///         <paramref name="lpsa" /> is NULL, the window station (and any desktops created within the window) gets a security descriptor that grants
		///         GENERIC_ALL access to all users.
		///     </para>
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is a handle to the newly created window station. If the specified window station already exists,
		///         the function succeeds and returns a handle to the existing window station.
		///     </para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     After you are done with the handle, you must call <see cref="CloseWindowStation" /> to free the handle.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CreateWindowStation")]
		public static extern IntPtr CreateWindowStation([In] string lpwinsta, CWF dwFlags, uint dwDesiredAccess, [In] ref SECURITY_ATTRIBUTES lpsa);

		/// <summary>
		///     <para>
		///         Determines which, if any, of the child windows belonging to a parent window contains the specified point. The search is restricted to
		///         immediate child windows. Grandchildren, and deeper descendant windows are not searched.
		///     </para>
		///     <para>
		///         To skip certain child windows, use the <see cref="ChildWindowFromPointEx" /> function.
		///     </para>
		/// </summary>
		/// <param name="hWndParent">A handle to the parent window.</param>
		/// <param name="Point">
		///     A structure that defines the client coordinates, relative to <paramref name="hWndParent" />, of the point to be checked.
		/// </param>
		/// <returns>
		///     <para>
		///         The return value is a handle to the child window that contains the point, even if the child window is hidden or disabled. If the point lies
		///         outside the parent window, the return value is NULL. If the point is within the parent window but not within any child window, the return
		///         value is a handle to the parent window.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The system maintains an internal list, containing the handles of the child windows associated with a parent window. The order of the handles
		///         in the list depends on the Z order of the child windows. If more than one child window contains the specified point, the system returns a
		///         handle to the first window in the list that contains the point.
		///     </para>
		///     <para>
		///         <see cref="ChildWindowFromPoint" /> treats an HTTRANSPARENT area of a standard control the same as other parts of the control.
		///         In contrast, <see cref="RealChildWindowFromPoint" /> treats an HTTRANSPARENT area differently; it returns the child window
		///         behind a transparent area of a control. For example, if the point is in a transparent area of a groupbox, <see cref="ChildWindowFromPoint" />
		///         returns the groupbox while <see cref="RealChildWindowFromPoint" /> returns the child window behind the groupbox. However, both APIs return a
		///         static field, even though it, too, returns HTTRANSPARENT.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "ChildWindowFromPoint")]
		public static extern IntPtr ChildWindowFromPoint([In] IntPtr hWndParent, POINT Point);

		/// <summary>Removes a specified window from the chain of clipboard viewers.</summary>
		/// <param name="hWndRemove">
		///     A handle to the window to be removed from the chain. The handle must have been passed to the <see cref="SetClipboardViewer" /> function.
		/// </param>
		/// <param name="hWndNewNext">
		///     A handle to the window that follows the <paramref name="hWndRemove" /> window in the clipboard viewer chain. (This is the handle returned by
		///     <see cref="SetClipboardViewer" />, unless the sequence was changed in response to a <see cref="WM.WM_CHANGECBCHAIN" /> message.)
		/// </param>
		/// <returns>
		///     The return value indicates the result of passing the <see cref="WM.WM_CHANGECBCHAIN" /> message to the windows in the clipboard viewer chain.
		///     Because a window in the chain typically returns FALSE when it processes <see cref="WM.WM_CHANGECBCHAIN" />, the return value from
		///     <see cref="ChangeClipboardChain" /> is typically FALSE. If there is only one window in the chain, the return value is typically TRUE.
		/// </returns>
		/// <remarks>
		///     <para>
		///         The window identified by <paramref name="hWndNewNext" /> replaces the <paramref name="hWndRemove" /> window in the chain. The
		///         <see cref="SetClipboardViewer" /> function sends a <see cref="WM.WM_CHANGECBCHAIN" /> message to the first window in the clipboard viewer
		///         chain.
		///     </para>
		///     <para>For an example, see Removing a Window from the Clipboard Viewer Chain.</para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "ChangeClipboardChain")]
		public static extern bool ChangeClipboardChain([In] IntPtr hWndRemove, [In] IntPtr hWndNewNext);

		/// <summary>Arranges all the minimized (iconic) child windows of the specified parent window.</summary>
		/// <param name="hWnd">A handle to the parent window.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the height of one row of icons.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         An application that maintains its own minimized child windows can use the <see cref="ArrangeIconicWindows" /> function to arrange icons in a
		///         parent window. This function can also arrange icons on the desktop. To retrieve the window handle to the desktop window, use the
		///         <see cref="GetDesktopWindow" /> function.
		///     </para>
		///     <para>
		///         An application sends the <see cref="WM.WM_MDIICONARRANGE" /> message to the multiple-document interface (MDI) client window to prompt the
		///         client window to arrange its minimized MDI child windows.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "ArrangeIconicWindows")]
		public static extern uint ArrangeIconicWindows([In] IntPtr hWnd);

		/// <summary>Updates the position, size, shape, content, and translucency of a layered window.</summary>
		/// <param name="hwnd">
		///     <para>
		///         A handle to a layered window. A layered window is created by specifying <see cref="WS_EX.WS_EX_LAYERED" /> when creating the window with the
		///         <see cref="CreateWindowEx" /> function.
		///     </para>
		/// </param>
		/// <param name="hdcDst">
		///     <para>
		///         A handle to a DC for the screen. This handle is obtained by specifying NULL when calling the function. It is used for palette color matching
		///         when the window contents are updated. If <paramref name="hdcDst" /> isNULL, the default palette will be used.
		///     </para>
		///     <para>
		///         If <paramref name="hdcSrc" /> is NULL, <paramref name="hdcDst" /> must be NULL.
		///     </para>
		/// </param>
		/// <param name="pptDst">
		///     A pointer to a structure that specifies the new screen position of the layered window. If the current position is not changing,
		///     <paramref name="pptDst" /> can be NULL.
		/// </param>
		/// <param name="psize">
		///     A pointer to a structure that specifies the new size of the layered window. If the size of the window is not changing, <paramref name="psize" />
		///     can be NULL. If <paramref name="hdcSrc" /> is NULL, <paramref name="psize" /> must be NULL.
		/// </param>
		/// <param name="hdcSrc">
		///     A handle to a DC for the surface that defines the layered window. This handle can be obtained by calling the CreateCompatibleDC
		///     function. If the shape and visual context of the window are not changing, <paramref name="hdcSrc" /> can be NULL.
		/// </param>
		/// <param name="pptSrc">
		///     A pointer to a structure that specifies the location of the layer in the device context. If <paramref name="hdcSrc" /> is NULL,
		///     <paramref name="pptSrc" /> should be NULL.
		/// </param>
		/// <param name="crKey">
		///     A structure that specifies the color key to be used when composing the layered window. To generate a <see cref="COLORREF" />, use the
		///     RGB macro.
		/// </param>
		/// <param name="pblend">A pointer to a structure that specifies the transparency value to be used when composing the layered window.</param>
		/// <param name="dwFlags">
		///     <para>This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>ULW_ALPHA 0x00000002</term>
		///             <description>
		///                 Use <paramref name="pblend" /> as the blend function. If the display mode is 256 colors or less, the effect of this value is the same
		///                 as the effect of <see cref="ULW.ULW_OPAQUE" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>ULW_COLORKEY 0x00000001</term>
		///             <description>
		///                 Use <paramref name="crKey" /> as the transparency color.
		///             </description>
		///         </item>
		///         <item>
		///             <term>ULW_OPAQUE 0x00000004</term>
		///             <description>Draw an opaque layered window.</description>
		///         </item>
		///     </list>
		///     <para>
		///         If <paramref name="hdcSrc" /> is NULL, <paramref name="dwFlags" /> should be zero.
		///     </para>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The source DC should contain the surface that defines the visible contents of the layered window. For example, you can select a bitmap into a
		///         device context obtained by calling the CreateCompatibleDC function.
		///     </para>
		///     <para>
		///         An application should call SetLayout on the <paramref name="hdcSrc" /> device context to properly set the mirroring mode.
		///         SetLayout will properly mirror all drawing into an HDC while properly preserving text glyph and (optionally)
		///         bitmap direction order. It cannot modify drawing directly into the bits of a device-independent bitmap (DIB). For more information, see
		///         Window Layout and Mirroring.
		///     </para>
		///     <para>
		///         The <see cref="UpdateLayeredWindow" /> function maintains the window's appearance on the screen. The windows underneath a layered window do
		///         not need to be repainted when they are uncovered due to a call to <see cref="UpdateLayeredWindow" />, because the system will automatically
		///         repaint them. This permits seamless animation of the layered window.
		///     </para>
		///     <para>
		///         <see cref="UpdateLayeredWindow" /> always updates the entire window. To update part of a window, use the traditional
		///         <see cref="WM.WM_PAINT" />
		///         and set the blend value using <see cref="SetLayeredWindowAttributes" />.
		///     </para>
		///     <para>
		///         For best drawing performance by the layered window and any underlying windows, the layered window should be as small as possible. An
		///         application should also process the message and re-create its layered windows when the display's color depth changes.
		///     </para>
		///     <para>For more information, see Layered Windows.</para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "UpdateLayeredWindow")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool UpdateLayeredWindow(
			[In] IntPtr hwnd, [In] IntPtr hdcDst, ref POINT pptDst, ref SIZE psize, [In] IntPtr hdcSrc, ref POINT pptSrc, uint crKey, ref BLENDFUNCTION pblend,
			ULW dwFlags);

		/// <summary>
		///     Removes a hook procedure installed in a hook chain by the <see cref="SetWindowsHookEx" /> function.
		/// </summary>
		/// <param name="hhk">
		///     A handle to the hook to be removed. This parameter is a hook handle obtained by a previous call to <see cref="SetWindowsHookEx" />.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     The hook procedure can be in the state of being called by another thread even after <see cref="UnhookWindowsHookEx" /> returns. If the hook
		///     procedure is not being called concurrently, the hook procedure is removed immediately before <see cref="UnhookWindowsHookEx" /> returns.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "UnhookWindowsHookEx")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool UnhookWindowsHookEx([In] IntPtr hhk);

		/// <summary>
		///     Sets the extra message information for the current thread. Extra message information is an application- or driver-defined value associated with
		///     the current thread's message queue. An application can use the <see cref="GetMessageExtraInfo" /> function to retrieve a thread's extra message
		///     information.
		/// </summary>
		/// <param name="lParam">The value to be associated with the current thread.</param>
		/// <returns>
		///     <para>The return value is the previous value associated with the current thread.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "SetMessageExtraInfo")]
		[return: MarshalAs(UnmanagedType.SysInt)]
		public static extern int SetMessageExtraInfo([MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>
		///     Brings the thread that created the specified window into the foreground and activates the window. Keyboard input is directed to the window, and
		///     various visual cues are changed for the user. The system assigns a slightly higher priority to the thread that created the foreground window than
		///     it does to other threads.
		/// </summary>
		/// <param name="hWnd">A handle to the window that should be activated and brought to the foreground.</param>
		/// <returns>
		///     <para>If the window was brought to the foreground, the return value is nonzero.</para>
		///     <para>If the window was not brought to the foreground, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     The system restricts which processes can set the foreground window. A process can set the foreground window only if one of the following
		///     conditions is true:
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetForegroundWindow")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool SetForegroundWindow([In] IntPtr hWnd);

		/// <summary>Sends the specified message to one or more windows.</summary>
		/// <param name="hWnd">
		///     <para>A handle to the window whose window procedure will receive the message.</para>
		///     <para>
		///         If this parameter is HWND_BROADCAST ((HWND)0xffff), the message is sent to all top-level windows in the system, including
		///         disabled or invisible unowned windows. The function does not return until each window has timed out. Therefore, the total wait time can be up
		///         to the value of <paramref name="uTimeout" /> multiplied by the number of top-level windows.
		///     </para>
		/// </param>
		/// <param name="Msg">
		///     <para>The message to be sent.</para>
		///     <para>For lists of the system-provided messages, see System-Defined Messages.</para>
		/// </param>
		/// <param name="wParam">Any additional message-specific information.</param>
		/// <param name="lParam">Any additional message-specific information.</param>
		/// <param name="fuFlags">
		///     <para>The behavior of this function. This parameter can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>SMTO_ABORTIFHUNG 0x0002</term>
		///             <description>
		///                 The function returns without waiting for the time-out period to elapse if the receiving thread appears to not respond or
		///                 "hangs."
		///             </description>
		///         </item>
		///         <item>
		///             <term>SMTO_BLOCK 0x0001</term>
		///             <description>Prevents the calling thread from processing any other requests until the function returns.</description>
		///         </item>
		///         <item>
		///             <term>SMTO_NORMAL 0x0000</term>
		///             <description>The calling thread is not prevented from processing other requests while waiting for the function to return.</description>
		///         </item>
		///         <item>
		///             <term>SMTO_NOTIMEOUTIFNOTHUNG 0x0008</term>
		///             <description>The function does not enforce the time-out period as long as the receiving thread is processing messages.</description>
		///         </item>
		///         <item>
		///             <term>SMTO_ERRORONEXIT 0x0020</term>
		///             <description>
		///                 The function should return 0 if the receiving window is destroyed or its owning thread dies while the message is being
		///                 processed.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="uTimeout">
		///     The duration of the time-out period, in milliseconds. If the message is a broadcast message, each window can use the full time-out period. For
		///     example, if you specify a five second time-out period and there are three top-level windows that fail to process the message, you could have up
		///     to a 15 second delay.
		/// </param>
		/// <param name="lpdwResult">The result of the message processing. The value of this parameter depends on the message that is specified.</param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is nonzero. <see cref="SendMessageTimeout" /> does not provide information about individual
		///         windows timing out if HWND_BROADCAST is used.
		///     </para>
		///     <para>
		///         If the function fails or times out, the return value is 0. To get extended error information, call GetLastError. If GetLastError returns
		///         ERROR_TIMEOUT, then the function timed out.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The function calls the window procedure for the specified window and, if the specified window belongs to a different thread, does not return
		///         until the window procedure has processed the message or the specified time-out period has elapsed. If the window receiving the message
		///         belongs to the same queue as the current thread, the window procedure is called directly—the time-out value is ignored.
		///     </para>
		///     <para>
		///         This function considers that a thread is not responding if it has not called <see cref="GetMessage" /> or a similar function within five
		///         seconds.
		///     </para>
		///     <para>
		///         The system only does marshalling for system messages (those in the range 0 to (<see cref="WM.WM_USER" />-1)). To send other messages (those
		///         >=
		///         <see cref="WM.WM_USER" />) to another process, you must do custom marshalling.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SendMessageTimeout")]
		[return: MarshalAs(UnmanagedType.SysInt)]
		public static extern int SendMessageTimeout(
			[In] IntPtr hWnd, uint Msg, [MarshalAs(UnmanagedType.SysUInt)] uint wParam, [MarshalAs(UnmanagedType.SysInt)] int lParam, SMTO fuFlags,
			uint uTimeout, IntPtr lpdwResult);

		/// <summary>Sends a message to the specified control in a dialog box.</summary>
		/// <param name="hDlg">A handle to the dialog box that contains the control.</param>
		/// <param name="nIDDlgItem">The identifier of the control that receives the message.</param>
		/// <param name="Msg">
		///     <para>The message to be sent.</para>
		///     <para>For lists of the system-provided messages, see System-Defined Messages.</para>
		/// </param>
		/// <param name="wParam">Additional message-specific information.</param>
		/// <param name="lParam">Additional message-specific information.</param>
		/// <returns>The return value specifies the result of the message processing and depends on the message sent.</returns>
		/// <remarks>
		///     <para>
		///         The <see cref="SendDlgItemMessage" /> function does not return until the message has been processed.
		///     </para>
		///     <para>
		///         Using <see cref="SendDlgItemMessage" /> is identical to retrieving a handle to the specified control and calling the
		///         <see cref="SendMessage" /> function.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.SysInt)]
		[DllImport("user32.dll", EntryPoint = "SendDlgItemMessage")]
		public static extern int SendDlgItemMessage(
			[In] IntPtr hDlg, int nIDDlgItem, uint Msg, [MarshalAs(UnmanagedType.SysUInt)] uint wParam, [MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>Retrieves a string that specifies the window type.</summary>
		/// <param name="hwnd">A handle to the window whose type will be retrieved.</param>
		/// <param name="pszType">A pointer to a string that receives the window type.</param>
		/// <param name="cchType">
		///     The length, in characters, of the buffer pointed to by the <paramref name="pszType" /> parameter.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the number of characters copied to the specified buffer.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "RealGetWindowClass")]
		public static extern uint RealGetWindowClass([In] IntPtr hwnd, [Out] StringBuilder pszType, uint cchType);

		/// <summary>
		///     Creates, displays, and operates a message box. The message box contains application-defined message text and title, any icon, and any combination
		///     of predefined push buttons.
		/// </summary>
		/// <param name="lpMsgBoxParams">
		///     A pointer to a <see cref="MSGBOXPARAMS" /> structure that contains information used to display the message box.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is one of the following menu-item values.</para>
		///     <para>
		///         If a message box has a Cancel button, the function returns the IDCANCEL value if either the ESC key is pressed
		///         or the Cancel button is selected. If the message box has no Cancel button, pressing ESC has no effect.
		///     </para>
		///     <para>If there is not enough memory to create the message box, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         When you use a system-modal message box to indicate that the system is low on memory, the strings pointed to by the <see cref="MSGBOXPARAMS.lpszText" />
		///         and <see cref="MSGBOXPARAMS.lpszCaption" /> members of the <see cref="MSGBOXPARAMS" /> structure should not be taken from a resource file, because an
		///         attempt to load the resource may fail.
		///     </para>
		///     <para>
		///         If you create a message box while a dialog box is present, use a handle to the dialog box as the hWnd parameter. The
		///         hWnd parameter should not identify a child window, such as a control in a dialog box.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "MessageBoxIndirect")]
		public static extern int MessageBoxIndirect([In] ref MSGBOXPARAMS lpMsgBoxParams);

		/// <summary>
		///     Loads a new input locale identifier (formerly called the keyboard layout) into the system. Several input locale identifiers can be loaded at a
		///     time, but only one per process is active at a time. Loading multiple input locale identifiers makes it possible to rapidly switch between them.
		/// </summary>
		/// <param name="pwszKLID">
		///     The name of the input locale identifier to load. This name is a string composed of the hexadecimal value of the Language Identifier (low word)
		///     and a device identifier (high word). For example, U.S. English has a language identifier of 0x0409, so the primary U.S. English layout is named
		///     "00000409". Variants of U.S. English layout (such as the Dvorak layout) are named "00010409", "00020409", and so on.
		/// </param>
		/// <param name="Flags">
		///     <para>Specifies how the input locale identifier is to be loaded. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>KLF_ACTIVATE 0x00000001</term>
		///             <description>
		///                 If the specified input locale identifier is not already loaded, the function loads and activates the input locale identifier
		///                 for the current thread.
		///             </description>
		///         </item>
		///         <item>
		///             <term>KLF_NOTELLSHELL 0x00000080</term>
		///             <description>
		///                 Prevents a ShellProc hook procedure from receiving an HSHELL_LANGUAGE hook code when the new input
		///                 locale identifier is loaded. This value is typically used when an application loads multiple input locale identifiers one after
		///                 another. Applying this value to all but the last input locale identifier delays the shell's processing until all input locale
		///                 identifiers have been added.
		///             </description>
		///         </item>
		///         <item>
		///             <term>KLF_REORDER 0x00000008</term>
		///             <description>
		///                 Moves the specified input locale identifier to the head of the input locale identifier list, making that locale identifier the active
		///                 locale identifier for the current thread. This value reorders the input locale identifier list even if
		///                 <see cref="KLF.KLF_ACTIVATE" /> is not provided.
		///             </description>
		///         </item>
		///         <item>
		///             <term>KLF_REPLACELANG 0x00000010</term>
		///             <description>
		///                 If the new input locale identifier has the same language identifier as a current input locale identifier, the new input locale
		///                 identifier replaces the current one as the input locale identifier for that language. If this value is not provided and the input
		///                 locale identifiers have the same language identifiers, the current input locale identifier is not replaced and the function returns
		///                 NULL.
		///             </description>
		///         </item>
		///         <item>
		///             <term>KLF_SUBSTITUTE_OK 0x00000002</term>
		///             <description>
		///                 Substitutes the specified input locale identifier with another locale preferred by the user. The system starts with this flag set,
		///                 and it is recommended that your application always use this flag. The substitution occurs only if the registry key
		///                 HKEY_CURRENT_USER\Keyboard\Layout\Substitutes explicitly defines a substitution locale. For example, if the key includes the value
		///                 name "00000409" with value "00010409", loading the U.S. English layout ("00000409") causes the Dvorak U.S. English layout
		///                 ("00010409") to be loaded instead. The system uses <see cref="KLF.KLF_SUBSTITUTE_OK" /> when booting, and it is recommended that all
		///                 applications use this value when loading input locale identifiers to ensure that the user's preference is selected.
		///             </description>
		///         </item>
		///         <item>
		///             <term>KLF_SETFORPROCESS 0x00000100</term>
		///             <description>
		///                 This flag is valid only with <see cref="KLF.KLF_ACTIVATE" />. Activates the specified input locale identifier for the entire process
		///                 and sends the <see cref="WM.WM_INPUTLANGCHANGE" /> message to the current thread's Focus or Active window. Typically,
		///                 <see cref="LoadKeyboardLayout" /> activates an input locale identifier only for the current thread.
		///             </description>
		///         </item>
		///         <item>
		///             <term>KLF_UNLOADPREVIOUS</term>
		///             <description>
		///                 This flag is unsupported. Use the <see cref="UnloadKeyboardLayout" /> function instead.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     If the function succeeds, the return value is the input locale identifier to the locale matched with the requested name. If no matching locale is
		///     available, the return value is NULL. To get extended error information, call GetLastError.
		/// </returns>
		/// <remarks>
		///     <para>This function only affects the layout for the current process or thread.</para>
		///     <para>
		///         The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input
		///         Method Editor (IME), or any other form of input.
		///     </para>
		///     <para>
		///         An application can and will typically load the default input locale identifier or IME for a language and can do so by specifying only a
		///         string version of the language identifier. If an application wants to load a specific locale or IME, it should read the registry to determine
		///         the specific input locale identifier to pass to <see cref="LoadKeyboardLayout" />. In this case, a request to activate the default input
		///         locale identifier for a locale will activate the first matching one. A specific IME should be activated using an explicit input locale
		///         identifier returned from <see cref="GetKeyboardLayout" /> or <see cref="LoadKeyboardLayout" />.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "LoadKeyboardLayout")]
		public static extern IntPtr LoadKeyboardLayout([In] string pwszKLID, KLF Flags);

		/// <summary>Creates a cursor based on data contained in a file.</summary>
		/// <param name="lpFileName">
		///     <para>The source of the file data to be used to create the cursor. The data in the file must be in either .CUR or .ANI format.</para>
		///     <para>
		///         If the high-order word of <paramref name="lpFileName" /> is nonzero, it is a pointer to a string that is a fully qualified name of a file
		///         containing cursor data.
		///     </para>
		/// </param>
		/// <returns>
		///     <para>If the function is successful, the return value is a handle to the new cursor.</para>
		///     <para>
		///         If the function fails, the return value is NULL. To get extended error information, call GetLastError. GetLastError may return the
		///         following value.
		///     </para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "LoadCursorFromFile")]
		public static extern IntPtr LoadCursorFromFile([In] string lpFileName);

		/// <summary>
		///     Determines whether a character is either an alphabetical or a numeric character. This determination is based on the semantics of the language
		///     selected by the user during setup or through Control Panel.
		/// </summary>
		/// <param name="ch">The character to be tested.</param>
		/// <returns>
		///     <para>If the character is alphanumeric, the return value is nonzero.</para>
		///     <para>If the character is not alphanumeric, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "IsCharAlphaNumeric")]
		public static extern bool IsCharAlphaNumeric(char ch);

		/// <summary>Retrieves a handle to the first control in a group of controls that precedes (or follows) the specified control in a dialog box.</summary>
		/// <param name="hDlg">A handle to the dialog box to be searched.</param>
		/// <param name="hCtl">
		///     A handle to the control to be used as the starting point for the search. If this parameter is NULL, the function uses the last (or first) control
		///     in the dialog box as the starting point for the search.
		/// </param>
		/// <param name="bPrevious">
		///     Indicates how the function is to search the group of controls in the dialog box. If this parameter is TRUE, the function searches for the
		///     previous control in the group. If it is FALSE, the function searches for the next control in the group.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to the previous (or next) control in the group of controls.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="GetNextDlgGroupItem" /> function searches controls in the order (or reverse order) they were created in the dialog box
		///         template. The first control in the group must have the <see cref="WS.WS_GROUP" /> style; all other controls in the group must have been
		///         consecutively created and must not have the <see cref="WS.WS_GROUP" /> style.
		///     </para>
		///     <para>
		///         When searching for the previous control, the function returns the first control it locates that is visible and not disabled. If the control
		///         specified by <paramref name="hCtl" /> has the <see cref="WS.WS_GROUP" /> style, the function temporarily reverses the search to locate
		///         the first control having the <see cref="WS.WS_GROUP" /> style, then resumes the search in the original direction, returning the first
		///         control it locates that is visible and not disabled, or returning <paramref name="hCtl" /> if no such control is found.
		///     </para>
		///     <para>
		///         When searching for the next control, the function returns the first control it locates that is visible, not disabled, and does not have the
		///         <see cref="WS.WS_GROUP" /> style. If it encounters a control having the <see cref="WS.WS_GROUP" /> style, the function reverses
		///         the search, locates the first control having the <see cref="WS.WS_GROUP" /> style, and returns this control if it is visible and not
		///         disabled. Otherwise, the function resumes the search in the original direction and returns the first control it locates that is visible and
		///         not disabled, or returns
		///         <paramref name="hCtl" /> if no such control is found.
		///     </para>
		///     <para>
		///         If the search for the next control in the group encounters a window with the <see cref="WS_EX.WS_EX_CONTROLPARENT" /> style, the system
		///         recursively searches the window's children.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetNextDlgGroupItem")]
		public static extern IntPtr GetNextDlgGroupItem([In] IntPtr hDlg, [In] IntPtr hCtl, [MarshalAs(UnmanagedType.Bool)] bool bPrevious);

		/// <summary>
		///     Retrieves the extra message information for the current thread. Extra message information is an application- or driver-defined value associated
		///     with the current thread's message queue.
		/// </summary>
		/// <returns>
		///     <para>The return value specifies the extra information. The meaning of the extra information is device specific.</para>
		/// </returns>
		/// <remarks>
		///     To set a thread's extra message information, use the <see cref="SetMessageExtraInfo" /> function.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetMessageExtraInfo")]
		[return: MarshalAs(UnmanagedType.SysInt)]
		public static extern int GetMessageExtraInfo();

		/// <summary>
		///     Retrieves a handle to the foreground window (the window with which the user is currently working). The system assigns a slightly higher priority
		///     to the thread that creates the foreground window than it does to other threads.
		/// </summary>
		/// <returns>
		///     <para>
		///         The return value is a handle to the foreground window. The foreground window can be NULL in certain circumstances, such as when a window is
		///         losing activation.
		///     </para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetForegroundWindow")]
		public static extern IntPtr GetForegroundWindow();

		/// <summary>
		///     Enumerates all window stations in the current session. The function passes the name of each window station, in turn, to an application-defined
		///     callback function.
		/// </summary>
		/// <param name="lpEnumFunc">
		///     A pointer to an application-defined <see cref="EnumWindowStationProc" /> callback function.
		/// </param>
		/// <param name="lParam">An application-defined value to be passed to the callback function.</param>
		/// <returns>
		///     <para>
		///         If the function succeeds, it returns the nonzero value returned by the callback function that was pointed to by
		///         <paramref name="lpEnumFunc" />.
		///     </para>
		///     <para>If the function is unable to perform the enumeration, the return value is zero. Call GetLastError to get extended error information.</para>
		///     <para>
		///         If the callback function fails, the return value is zero. The callback function can call SetLastError to set an error code for the caller to
		///         retrieve by calling GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="User32.EnumWindowStations" /> function enumerates only those window stations for which the calling process has the
		///         WINSTA_ENUMERATE access right. For more information, see Window Station Security and Access Rights.
		///     </para>
		///     <para>
		///         <see cref="User32.EnumWindowStations" /> repeatedly invokes the <paramref name="lpEnumFunc" /> callback function until the last window
		///         station is enumerated or the callback function returns FALSE.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "EnumWindowStations")]
		public static extern bool EnumWindowStations(EnumWindowStationProc lpEnumFunc, [MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>
		///     The <see cref="User32.EnumDisplayMonitors" /> function enumerates display monitors (including invisible pseudo-monitors associated with the
		///     mirroring drivers) that intersect a region formed by the intersection of a specified clipping rectangle and the visible region of a device
		///     context. <see cref="User32.EnumDisplayMonitors" /> calls an application-defined <see cref="MonitorEnumProc" /> callback function once for each
		///     monitor that is enumerated. Note that <see cref="GetSystemMetrics" /> (SM_CMONITORS) counts only the display monitors.
		/// </summary>
		/// <param name="hdc">
		///     <para>A handle to a display device context that defines the visible region of interest.</para>
		///     <para>
		///         If this parameter is NULL, the hdcMonitor parameter passed to the callback function will be NULL, and the visible region of interest is the
		///         virtual screen that encompasses all the displays on the desktop.
		///     </para>
		/// </param>
		/// <param name="lprcClip">
		///     <para>
		///         A pointer to a <see cref="RECT" /> structure that specifies a clipping rectangle. The region of interest is the intersection of the clipping
		///         rectangle with the visible region specified by <paramref name="hdc" />.
		///     </para>
		///     <para>
		///         If <paramref name="hdc" /> is non-NULL, the coordinates of the clipping rectangle are relative to the origin of the <paramref name="hdc" />.
		///         If <paramref name="hdc" /> is NULL, the coordinates are virtual-screen coordinates.
		///     </para>
		///     <para>
		///         This parameter can be NULL if you don't want to clip the region specified by <paramref name="hdc" />.
		///     </para>
		/// </param>
		/// <param name="lpfnEnum">
		///     A pointer to a <see cref="MonitorEnumProc" /> application-defined callback function.
		/// </param>
		/// <param name="dwData">
		///     Application-defined data that <see cref="User32.EnumDisplayMonitors" /> passes directly to the <see cref="MonitorEnumProc" /> function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     There are two reasons to call the <see cref="User32.EnumDisplayMonitors" /> function:
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "EnumDisplayMonitors")]
		public static extern bool EnumDisplayMonitors(
			[In] IntPtr hdc, [In] IntPtr lprcClip, MonitorEnumProc lpfnEnum, [MarshalAs(UnmanagedType.SysInt)] int dwData);

		/// <summary>
		///     The <see cref="EnumDisplayDevices" /> function lets you obtain information about the display devices in the current session.
		/// </summary>
		/// <param name="lpDevice">
		///     <para>
		///         A pointer to the device name. If NULL, function returns information for the display adapter(s) on the machine, based on
		///         <paramref name="iDevNum" />.
		///     </para>
		///     <para>For more information, see Remarks.</para>
		/// </param>
		/// <param name="iDevNum">
		///     <para>An index value that specifies the display device of interest.</para>
		///     <para>
		///         The operating system identifies each display device in the current session with an index value. The index values are consecutive integers,
		///         starting at 0. If the current session has three display devices, for example, they are specified by the index values 0, 1, and 2.
		///     </para>
		/// </param>
		/// <param name="lpDisplayDevice">
		///     <para>
		///         A pointer to a <see cref="DISPLAY_DEVICE" /> structure that receives information about the display device specified by
		///         <paramref name="iDevNum" />.
		///     </para>
		///     <para>
		///         Before calling <see cref="EnumDisplayDevices" />, you must initialize the <see cref="DISPLAY_DEVICE.cb" /> member of
		///         <see cref="DISPLAY_DEVICE" /> to the size, in bytes, of <see cref="DISPLAY_DEVICE" />.
		///     </para>
		/// </param>
		/// <param name="dwFlags">
		///     Set this flag to EDD_GET_DEVICE_INTERFACE_NAME (0x00000001) to retrieve the device interface name for GUID_DEVINTERFACE_MONITOR, which is
		///     registered by the operating system on a per monitor basis. The value is placed in the DeviceID member of the <see cref="DISPLAY_DEVICE" />
		///     structure returned in <paramref name="lpDisplayDevice" />. The resulting device interface name can be used with SetupAPI functions and serves as
		///     a link between GDI monitor devices and SetupAPI monitor devices.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>
		///         If the function fails, the return value is zero. The function fails if <paramref name="iDevNum" /> is greater than the largest device index.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         To query all display devices in the current session, call this function in a loop, starting with <paramref name="iDevNum" /> set to 0, and
		///         incrementing <paramref name="iDevNum" /> until the function fails. To select all display devices in the desktop, use only the display devices
		///         that have the DISPLAY_DEVICE_ATTACHED_TO_DESKTOP flag in the <see cref="DISPLAY_DEVICE" /> structure.
		///     </para>
		///     <para>
		///         To get information on the display adapter, call <see cref="EnumDisplayDevices" /> with <paramref name="lpDevice" /> set to NULL. For example,
		///         <see cref="DISPLAY_DEVICE" />.<see cref="DISPLAY_DEVICE.DeviceString" /> contains the adapter name.
		///     </para>
		///     <para>
		///         To obtain information on a display monitor, first call <see cref="EnumDisplayDevices" /> with <paramref name="lpDevice" /> set to NULL. Then
		///         call <see cref="EnumDisplayDevices" /> with <paramref name="lpDevice" /> set to <see cref="DISPLAY_DEVICE" />.
		///         <see cref="DISPLAY_DEVICE.DeviceName" /> from the first call to <see cref="EnumDisplayDevices" /> and with <paramref name="iDevNum" /> set to
		///         zero. Then <see cref="DISPLAY_DEVICE" />.
		///         <see cref="DISPLAY_DEVICE.DeviceString" /> is the monitor name.
		///     </para>
		///     <para>
		///         To query all monitor devices associated with an adapter, call <see cref="EnumDisplayDevices" /> in a loop with <paramref name="lpDevice" />
		///         set to the adapter name, <paramref name="iDevNum" /> set to start at 0, and <paramref name="iDevNum" /> set to increment until the function
		///         fails. Note that <see cref="DISPLAY_DEVICE.DeviceName" /> changes with each call for monitor information, so you must save the adapter name.
		///         The function fails when there are no more monitors for the adapter.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "EnumDisplayDevices")]
		public static extern bool EnumDisplayDevices(
			[In] [MarshalAs(UnmanagedType.LPTStr)] string lpDevice, uint iDevNum, ref DISPLAY_DEVICE lpDisplayDevice, EDD dwFlags);

		/// <summary>
		///     Replaces the contents of a combo box with the names of the subdirectories and files in a specified directory. You can filter the list of names by
		///     specifying a set of file attributes. The list of names can include mapped drive letters.
		/// </summary>
		/// <param name="hDlg">A handle to the dialog box that contains the combo box.</param>
		/// <param name="lpPathSpec">
		///     <para>
		///         A pointer to a buffer containing a null-terminated string that specifies an absolute path, relative path, or file name. An absolute path can
		///         begin with a drive letter (for example, d:\) or a UNC name (for example, \\machinename\sharename).
		///     </para>
		///     <para>
		///         The function splits the string into a directory and a file name. The function searches the directory for names that match the file name. If
		///         the string does not specify a directory, the function searches the current directory.
		///     </para>
		///     <para>
		///         If the string includes a file name, the file name must contain at least one wildcard character (? or *). If the string does not include a
		///         file name, the function behaves as if you had specified the asterisk wildcard character (*) as the file name. All names in the specified
		///         directory that match the file name and have the attributes specified by the <paramref name="uFiletype" /> parameter are added to the list
		///         displayed in the combo box.
		///     </para>
		/// </param>
		/// <param name="nIDComboBox">
		///     The identifier of a combo box in the <paramref name="hDlg" /> dialog box. If this parameter is zero, <see cref="DlgDirListComboBox" /> does not
		///     try to fill a combo box.
		/// </param>
		/// <param name="nIDStaticPath">
		///     The identifier of a static control in the <paramref name="hDlg" /> dialog box. <see cref="DlgDirListComboBox" /> sets the text of this control to
		///     display the current drive and directory. This parameter can be zero if you do not want to display the current drive and directory.
		/// </param>
		/// <param name="uFiletype">
		///     <para>
		///         A set of bit flags that specifies the attributes of the files or directories to be added to the combo box. This parameter can be a
		///         combination of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>DDL_ARCHIVE</term>
		///             <description>Includes archived files.</description>
		///         </item>
		///         <item>
		///             <term>DDL_DIRECTORY</term>
		///             <description>Includes subdirectories, which are enclosed in square brackets ([ ]).</description>
		///         </item>
		///         <item>
		///             <term>DDL_DRIVES</term>
		///             <description>All mapped drives are added to the list. Drives are listed in the form [-x-], where x is the drive letter.</description>
		///         </item>
		///         <item>
		///             <term>DDL_EXCLUSIVE</term>
		///             <description>
		///                 Includes only files with the specified attributes. By default, read/write files are listed even if DDL_READWRITE is not
		///                 specified.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DDL_HIDDEN</term>
		///             <description>Includes hidden files.</description>
		///         </item>
		///         <item>
		///             <term>DDL_READONLY</term>
		///             <description>Includes read-only files.</description>
		///         </item>
		///         <item>
		///             <term>DDL_READWRITE</term>
		///             <description>Includes read/write files with no additional attributes. This is the default setting.</description>
		///         </item>
		///         <item>
		///             <term>DDL_SYSTEM</term>
		///             <description>Includes system files.</description>
		///         </item>
		///         <item>
		///             <term>DDL_POSTMSGS</term>
		///             <description>
		///                 If this flag is set, <see cref="DlgDirListComboBox" /> uses the <see cref="PostMessage" /> function to send messages to the combo
		///                 box. If this flag is not set, <see cref="DlgDirListComboBox" /> uses the <see cref="SendMessage" /> function.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>
		///         If the function fails, the return value is zero. For example, if the string specified by <paramref name="lpPathSpec" /> is not a valid path,
		///         the function fails. To get extended error information, call GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If <paramref name="lpPathSpec" /> specifies a directory, <see cref="DlgDirListComboBox" /> changes the current directory to the specified
		///         directory before filling the combo box. The text of the static control identified by the <paramref name="nIDStaticPath" /> parameter is set
		///         to the name of the new current directory.
		///     </para>
		///     <para>
		///         <see cref="DlgDirListComboBox" /> sends the CB_RESETCONTENT and CB_DIR messages to the combo box.
		///     </para>
		///     <para>
		///         Microsoft Windows NT 4.0 and later: If <paramref name="uFiletype" /> includes the DDL_DIRECTORY flag and <paramref name="lpPathSpec" />
		///         specifies a first-level directory, such as C:\TEMP, the combo box will always include a ".." entry for the root directory. This is true even
		///         if the root directory has hidden or system attributes and the DDL_HIDDEN and DDL_SYSTEM flags are not specified. The root directory of an
		///         NTFS volume has hidden and system attributes.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DlgDirListComboBox")]
		public static extern int DlgDirListComboBox([In] IntPtr hDlg, IntPtr lpPathSpec, int nIDComboBox, int nIDStaticPath, uint uFiletype);

		/// <summary>
		///     Increments the usage count associated with the specified handle. This function enables an application to save a string handle passed to the
		///     application's Dynamic Data Exchange (DDE) callback function. Otherwise, a string handle passed to the callback function is deleted when the
		///     callback function returns. This function should also be used to keep a copy of a string handle referenced by the <see cref="CONVINFO" />
		///     structure returned by the <see cref="DdeQueryConvInfo" /> function.
		/// </summary>
		/// <param name="idInst">
		///     The application instance identifier obtained by a previous call to the <see cref="DdeInitialize" /> function.
		/// </param>
		/// <param name="hsz">A handle to the string handle to be saved.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DdeKeepStringHandle")]
		public static extern bool DdeKeepStringHandle(uint idInst, IntPtr hsz);

		/// <summary>Frees a string handle in the calling application.</summary>
		/// <param name="idInst">
		///     The application instance identifier obtained by a previous call to the <see cref="DdeInitialize" /> function.
		/// </param>
		/// <param name="hsz">
		///     A handle to the string handle to be freed. This handle must have been created by a previous call to the <see cref="DdeCreateStringHandle" />
		///     function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     An application can free string handles it creates with <see cref="DdeCreateStringHandle" /> but should not free those that the system passed to
		///     the application's Dynamic Data Exchange (DDE) callback function or those returned in the <see cref="CONVINFO" /> structure by the
		///     <see cref="DdeQueryConvInfo" /> function.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DdeFreeStringHandle")]
		public static extern bool DdeFreeStringHandle(uint idInst, IntPtr hsz);

		/// <summary>
		///     Creates a Dynamic Data Exchange (DDE) object and fills the object with data from the specified buffer. A DDE application uses this function
		///     during transactions that involve passing data to the partner application.
		/// </summary>
		/// <param name="idInst">
		///     The application instance identifier obtained by a previous call to the <see cref="DdeInitialize" /> function.
		/// </param>
		/// <param name="pSrc">The data to be copied to the DDE object. If this parameter is NULL, no data is copied to the object.</param>
		/// <param name="cb">
		///     The amount of memory, in bytes, to copy from the buffer pointed to by <paramref name="pSrc" />. (include the terminating NULL, if the data is a
		///     string). If this parameter is zero, the <paramref name="pSrc" /> parameter is ignored.
		/// </param>
		/// <param name="cbOff">
		///     An offset, in bytes, from the beginning of the buffer pointed to by the <paramref name="pSrc" /> parameter. The data beginning at this offset is
		///     copied from the buffer to the DDE object.
		/// </param>
		/// <param name="hszItem">
		///     A handle to the string that specifies the data item corresponding to the DDE object. This handle must have been created by a previous call to the
		///     <see cref="DdeCreateStringHandle" /> function. If the data handle is to be used in an XTYP_EXECUTE transaction, this parameter must be 0L.
		/// </param>
		/// <param name="wFmt">The standard clipboard format of the data.</param>
		/// <param name="afCmd">
		///     The creation flags. This parameter can be HDATA_APPOWNED, which specifies that the server application calling the
		///     <see cref="DdeCreateDataHandle" /> function owns the data handle this function creates. This flag enables the application to share the data
		///     handle with other DDEML applications rather than creating a separate handle to pass to each application. If this flag is specified, the
		///     application must eventually free the shared memory object associated with the handle by using the <see cref="DdeFreeDataHandle" /> function. If
		///     this flag is not specified, the handle becomes invalid in the application that created the handle after the data handle is returned by the
		///     application's DDE callback function or is used as a parameter in another DDEML function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a data handle.</para>
		///     <para>If the function fails, the return value is 0L.</para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>Any unfilled locations in the DDE object are undefined.</para>
		///     <para>
		///         After a data handle has been used as a parameter in another DDEML function or has been returned by a DDE callback function, the handle can be
		///         used only for read access to the DDE object identified by the handle.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DdeCreateDataHandle")]
		public static extern IntPtr DdeCreateDataHandle(uint idInst, ref byte pSrc, uint cb, uint cbOff, IntPtr hszItem, uint wFmt, uint afCmd);

		/// <summary>Compares the values of two string handles. The value of a string handle is not related to the case of the associated string.</summary>
		/// <param name="hsz1">A handle to the first string.</param>
		/// <param name="hsz2">A handle to the second string.</param>
		/// <returns>The return value can be one of the following values.</returns>
		/// <remarks>
		///     <para>
		///         An application that must do a case-sensitive comparison of two string handles should compare the string handles directly. An application
		///         should use <see cref="DdeCmpStringHandles" /> for all other comparisons to preserve the case-insensitive nature of Dynamic Data Exchange
		///         (DDE).
		///     </para>
		///     <para>
		///         <see cref="DdeCmpStringHandles" /> cannot be used to sort string handles alphabetically.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DdeCmpStringHandles")]
		public static extern int DdeCmpStringHandles(IntPtr hsz1, IntPtr hsz2);

		/// <summary>Allocates memory for a multiple-window- position structure and returns the handle to the structure.</summary>
		/// <param name="nNumWindows">
		///     The initial number of windows for which to store position information. The <see cref="DeferWindowPos" /> function increases the size of the
		///     structure, if necessary.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value identifies the multiple-window-position structure. If insufficient system resources are available
		///         to allocate the structure, the return value is NULL. To get extended error information, call GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>The multiple-window-position structure is an internal structure; an application cannot access it directly.</para>
		///     <para>
		///         <see cref="DeferWindowPos" /> fills the multiple-window-position structure with information about the target position for one or more windows
		///         about to be moved. The <see cref="EndDeferWindowPos" /> function accepts the handle to this structure and repositions the windows by using
		///         the information stored in the structure.
		///     </para>
		///     <para>
		///         If any of the windows in the multiple-window- position structure have the <see cref="SWP.SWP_HIDEWINDOW" /> or <see cref="SWP.SWP_SHOWWINDOW" /> flag
		///         set, none of the windows are repositioned.
		///     </para>
		///     <para>
		///         If the system must increase the size of the multiple-window- position structure beyond the initial size specified by the
		///         <paramref name="nNumWindows" /> parameter but cannot allocate enough memory to do so, the system fails the entire window positioning sequence
		///         (<see cref="BeginDeferWindowPos" />, <see cref="DeferWindowPos" />, and <see cref="EndDeferWindowPos" />). By specifying the maximum size
		///         needed, an application can detect and process failure early in the process.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "BeginDeferWindowPos")]
		public static extern IntPtr BeginDeferWindowPos(int nNumWindows);

		/// <summary>
		///     <para>[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]</para>
		///     <para>Switches focus to the specified window and brings it to the foreground.</para>
		/// </summary>
		/// <param name="hWnd">A handle to the window.</param>
		/// <param name="fAltTab">
		///     A TRUE for this parameter indicates that the window is being switched to using the Alt/Ctl+Tab key sequence. This parameter should be FALSE
		///     otherwise.
		/// </param>
		/// <returns>This function does not return a value.</returns>
		/// <remarks>
		///     <para>This function is typically called to maintain window z-ordering.</para>
		///     <para>
		///         This function was not included in the SDK headers and libraries until Windows XP with Service Pack 1 (SP1) and Windows Server 2003. If you do
		///         not have a header file and import library for this function, you can call the function using LoadLibrary and GetProcAddress.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SwitchToThisWindow")]
		public static extern void SwitchToThisWindow([In] IntPtr hWnd, [MarshalAs(UnmanagedType.Bool)] bool fAltTab);

		/// <summary>Sets the show state and the restored, minimized, and maximized positions of the specified window.</summary>
		/// <param name="hWnd">A handle to the window.</param>
		/// <param name="lpwndpl">
		///     <para>
		///         A pointer to a <see cref="WINDOWPLACEMENT" /> structure that specifies the new show state and window positions.
		///     </para>
		///     <para>
		///         Before calling <see cref="SetWindowPlacement" />, set the <see cref="WINDOWPLACEMENT.length" /> member of the <see cref="WINDOWPLACEMENT" /> structure to
		///         sizeof(<see cref="WINDOWPLACEMENT" />). <see cref="SetWindowPlacement" /> fails if the <see cref="WINDOWPLACEMENT.length" /> member is not set correctly.
		///     </para>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If the information specified in <see cref="WINDOWPLACEMENT" /> would result in a window that is completely off the screen, the system will
		///         automatically adjust the coordinates so that the window is visible, taking into account changes in screen resolution and multiple monitor
		///         configuration.
		///     </para>
		///     <para>
		///         The <see cref="WINDOWPLACEMENT.length" /> member of <see cref="WINDOWPLACEMENT" /> must be set to sizeof(WINDOWPLACEMENT). If this member is not set
		///         correctly, the function returns FALSE. For additional remarks on the proper use of window placement coordinates, see
		///         <see cref="WINDOWPLACEMENT" />.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetWindowPlacement")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool SetWindowPlacement([In] IntPtr hWnd, [In] ref WINDOWPLACEMENT lpwndpl);

		/// <summary>
		///     Associates the specified bitmap with a menu item. Whether the menu item is selected or clear, the system displays the appropriate bitmap next to
		///     the menu item.
		/// </summary>
		/// <param name="hMenu">A handle to the menu containing the item to receive new check-mark bitmaps.</param>
		/// <param name="uPosition">
		///     The menu item to be changed, as determined by the <paramref name="uFlags" /> parameter.
		/// </param>
		/// <param name="uFlags">
		///     <para>
		///         Specifies how the <paramref name="uPosition" /> parameter is to be interpreted. The <paramref name="uFlags" /> parameter must be one of the
		///         following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BYCOMMAND 0x00000000L</term>
		///             <description>
		///                 Indicates that <paramref name="uPosition" /> gives the identifier of the menu item. If neither <see cref="MF.MF_BYCOMMAND" /> nor
		///                 <see cref="MF.MF_BYPOSITION" /> is specified, <see cref="MF.MF_BYCOMMAND" /> is the default flag.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_BYPOSITION 0x00000400L</term>
		///             <description>
		///                 Indicates that <paramref name="uPosition" /> gives the zero-based relative position of the menu item.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="hBitmapUnchecked">A handle to the bitmap displayed when the menu item is not selected.</param>
		/// <param name="hBitmapChecked">A handle to the bitmap displayed when the menu item is selected.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If either the <paramref name="hBitmapUnchecked" /> or <paramref name="hBitmapChecked" /> parameter is NULL, the system displays nothing next
		///         to the menu item for the corresponding check state. If both parameters are NULL, the system displays the default check-mark bitmap when the
		///         item is selected, and removes the bitmap when the item is not selected.
		///     </para>
		///     <para>When the menu is destroyed, these bitmaps are not destroyed; it is up to the application to destroy them.</para>
		///     <para>
		///         The selected and clear bitmaps should be monochrome. The system uses the Boolean AND operator to combine bitmaps with the menu so that the
		///         white part becomes transparent and the black part becomes the menu-item color. If you use color bitmaps, the results may be undesirable.
		///     </para>
		///     <para>
		///         Use the <see cref="GetSystemMetrics" /> function with the CXMENUCHECK and CYMENUCHECK values to retrieve the bitmap dimensions.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetMenuItemBitmaps")]
		public static extern bool SetMenuItemBitmaps([In] IntPtr hMenu, uint uPosition, MF uFlags, [In] IntPtr hBitmapUnchecked, [In] IntPtr hBitmapChecked);

		/// <summary>Sets the default menu item for the specified menu.</summary>
		/// <param name="hMenu">A handle to the menu to set the default item for.</param>
		/// <param name="uItem">
		///     The identifier or position of the new default menu item or -1 for no default item. The meaning of this parameter depends on the value of
		///     <paramref name="fByPos" />.
		/// </param>
		/// <param name="fByPos">
		///     The meaning of <paramref name="uItem" />. If this parameter is FALSE, <paramref name="uItem" /> is a menu item identifier. Otherwise, it is a
		///     menu item position. See About Menus for more information.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetMenuDefaultItem")]
		public static extern bool SetMenuDefaultItem([In] IntPtr hMenu, uint uItem, uint fByPos);

		/// <summary>
		///     Sets the double-click time for the mouse. A double-click is a series of two clicks of a mouse button, the second occurring within a specified
		///     time after the first. The double-click time is the maximum number of milliseconds that may occur between the first and second clicks of a
		///     double-click.
		/// </summary>
		/// <param name="uInterval">
		///     The number of milliseconds that may occur between the first and second clicks of a double-click. If this parameter is set to 0, the system uses
		///     the default double-click time of 500 milliseconds. If this parameter value is greater than 5000 milliseconds, the system sets the value to 5000
		///     milliseconds.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     The <see cref="SetDoubleClickTime" /> function alters the double-click time for all windows in the system.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetDoubleClickTime")]
		public static extern bool SetDoubleClickTime(uint uInterval);

		/// <summary>
		///     Adds the specified window to the chain of clipboard viewers. Clipboard viewer windows receive a <see cref="WM.WM_DRAWCLIPBOARD" /> message
		///     whenever the content of the clipboard changes.
		/// </summary>
		/// <param name="hWndNewViewer">A handle to the window to be added to the clipboard chain.</param>
		/// <returns>
		///     If the function succeeds, the return value identifies the next window in the clipboard viewer chain. If an error occurs or there are no other
		///     windows in the clipboard viewer chain, the return value is NULL. To get extended error information, call GetLastError.
		/// </returns>
		/// <remarks>
		///     <para>
		///         The windows that are part of the clipboard viewer chain, called clipboard viewer windows, must process the clipboard messages
		///         <see cref="WM.WM_CHANGECBCHAIN" /> and <see cref="WM.WM_DRAWCLIPBOARD" />. Each clipboard viewer window calls the <see cref="SendMessage" />
		///         function to pass these messages to the next window in the clipboard viewer chain.
		///     </para>
		///     <para>
		///         A clipboard viewer window must eventually remove itself from the clipboard viewer chain by calling the <see cref="ChangeClipboardChain" />
		///         function — for example, in response to the <see cref="WM.WM_DESTROY" /> message.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetClipboardViewer")]
		public static extern IntPtr SetClipboardViewer([In] IntPtr hWndNewViewer);

		/// <summary>
		///     Sends the specified message to a window or windows. If the window was created by the calling thread, <see cref="SendNotifyMessage" /> calls the
		///     window procedure for the window and does not return until the window procedure has processed the message. If the window was created by a
		///     different thread, <see cref="SendNotifyMessage" /> passes the message to the window procedure and returns immediately; it does not wait for the
		///     window procedure to finish processing the message.
		/// </summary>
		/// <param name="hWnd">
		///     A handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff), the
		///     message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up windows;
		///     but the message is not sent to child windows.
		/// </param>
		/// <param name="Msg">
		///     <para>The message to be sent.</para>
		///     <para>For lists of the system-provided messages, see System-Defined Messages.</para>
		/// </param>
		/// <param name="wParam">Additional message-specific information.</param>
		/// <param name="lParam">Additional message-specific information.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If you send a message in the range below <see cref="WM.WM_USER" /> to the asynchronous message functions (<see cref="PostMessage" />,
		///         <see cref="SendNotifyMessage" />, and <see cref="SendMessageCallback" />), its message parameters cannot include pointers. Otherwise, the
		///         operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free
		///         the memory before it is used.
		///     </para>
		///     <para>
		///         Applications that need to communicate using HWND_BROADCAST should use the <see cref="RegisterWindowMessage" /> function to
		///         obtain a unique message for inter-application communication.
		///     </para>
		///     <para>
		///         The system only does marshalling for system messages (those in the range 0 to (<see cref="WM.WM_USER" />-1)). To send other messages (those
		///         >=
		///         <see cref="WM.WM_USER" />) to another process, you must do custom marshalling.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SendNotifyMessage")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool SendNotifyMessage(
			[In] IntPtr hWnd, uint Msg, [MarshalAs(UnmanagedType.SysUInt)] uint wParam, [MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>Posts a message to the message queue of the specified thread. It returns without waiting for the thread to process the message.</summary>
		/// <param name="idThread">
		///     <para>The identifier of the thread to which the message is to be posted.</para>
		///     <para>
		///         The function fails if the specified thread does not have a message queue. The system creates a thread's message queue when the thread makes
		///         its first call to one of the User or GDI functions. For more information, see the Remarks section.
		///     </para>
		///     <para>
		///         Message posting is subject to UIPI. The thread of a process can post messages only to posted-message queues of threads in processes of lesser
		///         or equal integrity level.
		///     </para>
		///     <para>
		///         This thread must have the SE_TCB_NAME privilege to post a message to a thread that belongs to a process with the same locally
		///         unique identifier (LUID) but is in a different desktop. Otherwise, the function fails and returns ERROR_INVALID_THREAD_ID.
		///     </para>
		///     <para>
		///         This thread must either belong to the same desktop as the calling thread or to a process with the same LUID. Otherwise, the function fails
		///         and returns ERROR_INVALID_THREAD_ID.
		///     </para>
		/// </param>
		/// <param name="Msg">The type of message to be posted.</param>
		/// <param name="wParam">Additional message-specific information.</param>
		/// <param name="lParam">Additional message-specific information.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>
		///         If the function fails, the return value is zero. To get extended error information, call GetLastError. GetLastError returns
		///         ERROR_INVALID_THREAD_ID if <paramref name="idThread" /> is not a valid thread identifier, or if the thread specified by
		///         <paramref name="idThread" /> does not have a message queue. GetLastError returns
		///         ERROR_NOT_ENOUGH_QUOTA when the message limit is hit.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
		///     <para>
		///         The thread to which the message is posted must have created a message queue, or else the call to <see cref="PostThreadMessage" /> fails. Use
		///         the following method to handle this situation.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "PostThreadMessage")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool PostThreadMessage(
			uint idThread, uint Msg, [MarshalAs(UnmanagedType.SysUInt)] uint wParam, [MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>Opens the specified window station.</summary>
		/// <param name="lpszWinSta">
		///     <para>The name of the window station to be opened. Window station names are case-insensitive.</para>
		///     <para>This window station must belong to the current session.</para>
		/// </param>
		/// <param name="fInherit">
		///     If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this
		///     handle.
		/// </param>
		/// <param name="dwDesiredAccess">The access to the window station. For a list of access rights, see Window Station Security and Access Rights.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the handle to the specified window station.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     After you are done with the handle, you must call <see cref="CloseWindowStation" /> to free the handle.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "OpenWindowStation")]
		public static extern IntPtr OpenWindowStation([In] string lpszWinSta, [MarshalAs(UnmanagedType.Bool)] bool fInherit, uint dwDesiredAccess);

		/// <summary>
		///     The <see cref="IsDlgButtonChecked" /> function determines whether a button control is checked or whether a three-state button control is checked,
		///     unchecked, or indeterminate.
		/// </summary>
		/// <param name="hDlg">A handle to the dialog box that contains the button control.</param>
		/// <param name="nIDButton">The identifier of the button control.</param>
		/// <returns>
		///     The return value from a button created with the <see cref="BS.BS_AUTOCHECKBOX" />, <see cref="BS.BS_AUTORADIOBUTTON" />, <see cref="BS.BS_AUTO3STATE" />,
		///     <see cref="BS.BS_CHECKBOX" />, <see cref="BS.BS_RADIOBUTTON" />, or <see cref="BS.BS_3STATE" /> styles can be one of the values in the following table. If
		///     the button has any other style, the return value is zero.
		/// </returns>
		/// <remarks>
		///     The <see cref="IsDlgButtonChecked" /> function sends a BM_GETCHECK message to the specified button control.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "IsDlgButtonChecked")]
		public static extern uint IsDlgButtonChecked([In] IntPtr hDlg, int nIDButton);

		/// <summary>Retrieves the show state and the restored, minimized, and maximized positions of the specified window.</summary>
		/// <param name="hWnd">A handle to the window.</param>
		/// <param name="lpwndpl">
		///     A pointer to the <see cref="WINDOWPLACEMENT" /> structure that receives the show state and position information. Before calling
		///     <see cref="GetWindowPlacement" />, set the <see cref="WINDOWPLACEMENT.length" /> member to sizeof(WINDOWPLACEMENT). <see cref="GetWindowPlacement" /> fails if
		///     <paramref name="lpwndpl" />-> <see cref="WINDOWPLACEMENT.length" /> is not set correctly.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="WINDOWPLACEMENT.flags" /> member of <see cref="WINDOWPLACEMENT" /> retrieved by this function is always zero. If the window identified by the
		///         <paramref name="hWnd" /> parameter is maximized, the <see cref="WINDOWPLACEMENT.showCmd" /> member is SW_SHOWMAXIMIZED. If the window is minimized,
		///         <see cref="WINDOWPLACEMENT.showCmd" /> is SW_SHOWMINIMIZED. Otherwise, it is SW_SHOWNORMAL.
		///     </para>
		///     <para>
		///         The <see cref="WINDOWPLACEMENT.length" /> member of <see cref="WINDOWPLACEMENT" /> must be set to sizeof(<see cref="WINDOWPLACEMENT" />). If this member is
		///         not set correctly, the function returns FALSE. For additional remarks on the proper use of window placement coordinates, see
		///         <see cref="WINDOWPLACEMENT" />.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetWindowPlacement")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool GetWindowPlacement([In] IntPtr hWnd, ref WINDOWPLACEMENT lpwndpl);

		/// <summary>Determines the default menu item on the specified menu.</summary>
		/// <param name="hMenu">A handle to the menu for which to retrieve the default menu item.</param>
		/// <param name="fByPos">
		///     Indicates whether to retrieve the menu item's identifier or its position. If this parameter is FALSE, the identifier is returned. Otherwise, the
		///     position is returned.
		/// </param>
		/// <param name="gmdiFlags">
		///     <para>Indicates how the function should search for menu items. This parameter can be zero or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>GMDI_GOINTOPOPUPS 0x0002L</term>
		///             <description>
		///                 If the default item is one that opens a submenu, the function is to search recursively in the corresponding submenu. If the submenu
		///                 has no default item, the return value identifies the item that opens the submenu. By default, the function returns the first default
		///                 item on the specified menu, regardless of whether it is an item that opens a submenu.
		///             </description>
		///         </item>
		///         <item>
		///             <term>GMDI_USEDISABLED 0x0001L</term>
		///             <description>The function is to return a default item, even if it is disabled. By default, the function skips disabled or grayed items.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the identifier or position of the menu item.</para>
		///     <para>If the function fails, the return value is -1. To get extended error information, call GetLastError.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetMenuDefaultItem")]
		public static extern uint GetMenuDefaultItem([In] IntPtr hMenu, uint fByPos, GMDI gmdiFlags);

		/// <summary>Determines which pop-up window owned by the specified window was most recently active.</summary>
		/// <param name="hWnd">A handle to the owner window.</param>
		/// <returns>
		///     <para>
		///         The return value identifies the most recently active pop-up window. The return value is the same as the <paramref name="hWnd" /> parameter,
		///         if any of the following conditions are met:
		///     </para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetLastActivePopup")]
		public static extern IntPtr GetLastActivePopup([In] IntPtr hWnd);

		/// <summary>
		///     Retrieves the current double-click time for the mouse. A double-click is a series of two clicks of the mouse button, the second occurring within
		///     a specified time after the first. The double-click time is the maximum number of milliseconds that may occur between the first and second click
		///     of a double-click. The maximum double-click time is 5000 milliseconds.
		/// </summary>
		/// <returns>The return value specifies the current double-click time, in milliseconds. The maximum return value is 5000 milliseconds.</returns>
		[DllImport("user32.dll", EntryPoint = "GetDoubleClickTime")]
		public static extern uint GetDoubleClickTime();

		/// <summary>
		///     <para>
		///         Retrieves the system's dialog base units, which are the average width and height of characters in the system font. For dialog boxes that use
		///         the system font, you can use these values to convert between dialog template units, as specified in dialog box templates, and pixels. For
		///         dialog boxes that do not use the system font, the conversion from dialog template units to pixels depends on the font used by the dialog box.
		///     </para>
		///     <para>
		///         For either type of dialog box, it is easier to use the <see cref="MapDialogRect" /> function to perform the conversion.
		///         <see cref="MapDialogRect" /> takes the font into account and correctly converts a rectangle from dialog template units into pixels.
		///     </para>
		/// </summary>
		/// <returns>
		///     The function returns the dialog base units. The low-order word of the return value contains the horizontal dialog box base unit, and the
		///     high-order word contains the vertical dialog box base unit.
		/// </returns>
		/// <remarks>
		///     <para>
		///         The horizontal base unit returned by <see cref="GetDialogBaseUnits" /> is equal to the average width, in pixels, of the characters in the
		///         system font; the vertical base unit is equal to the height, in pixels, of the font.
		///     </para>
		///     <para>
		///         The system font is used only if the dialog box template fails to specify a font. Most dialog box templates specify a font; as a result, this
		///         function is not useful for most dialog boxes.
		///     </para>
		///     <para>
		///         For a dialog box that does not use the system font, the base units are the average width and height, in pixels, of the characters in the
		///         dialog's font. You can use the GetTextMetrics and GetTextExtentPoint32 functions to calculate these values for a selected font. However, by
		///         using the <see cref="MapDialogRect" /> function, you can avoid errors that might result if your calculations differ from those performed by
		///         the system.
		///     </para>
		///     <para>
		///         Each horizontal base unit is equal to 4 horizontal dialog template units; each vertical base unit is equal to 8 vertical dialog template
		///         units. Therefore, to convert dialog template units to pixels, use the following formulas:
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetDialogBaseUnits")]
		public static extern int GetDialogBaseUnits();

		/// <summary>Retrieves the handle to the first window in the clipboard viewer chain.</summary>
		/// <returns>
		///     <para>If the function succeeds, the return value is the handle to the first window in the clipboard viewer chain.</para>
		///     <para>If there is no clipboard viewer, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetClipboardViewer")]
		public static extern IntPtr GetClipboardViewer();

		/// <summary>
		///     Enumerates all top-level windows associated with the specified desktop. It passes the handle to each window, in turn, to an application-defined
		///     callback function.
		/// </summary>
		/// <param name="hDesktop">
		///     <para>
		///         A handle to the desktop whose top-level windows are to be enumerated. This handle is returned by the <see cref="CreateDesktop" />,
		///         <see cref="GetThreadDesktop" />, <see cref="OpenDesktop" />, or <see cref="OpenInputDesktop" /> function, and must have the
		///         DESKTOP_READOBJECTS access right. For more information, see Desktop Security and Access Rights.
		///     </para>
		///     <para>If this parameter is NULL, the current desktop is used.</para>
		/// </param>
		/// <param name="lpfn">
		///     A pointer to an application-defined <see cref="EnumWindowsProc" /> callback function.
		/// </param>
		/// <param name="lParam">An application-defined value to be passed to the callback function.</param>
		/// <returns>
		///     <para>If the function fails or is unable to perform the enumeration, the return value is zero.</para>
		///     <para>To get extended error information, call GetLastError.</para>
		///     <para>You must ensure that the callback function sets SetLastError if it fails.</para>
		/// </returns>
		/// <remarks>
		///     The <see cref="EnumDesktopWindows" /> function repeatedly invokes the <paramref name="lpfn" /> callback function until the last top-level window
		///     is enumerated or the callback function returns FALSE.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "EnumDesktopWindows")]
		public static extern bool EnumDesktopWindows([In] IntPtr hDesktop, EnumWindowsProc lpfn, [MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>Retrieves the next conversation handle in the specified conversation list.</summary>
		/// <param name="hConvList">
		///     A handle to the conversation list. This handle must have been created by a previous call to the <see cref="DdeConnectList" /> function.
		/// </param>
		/// <param name="hConvPrev">
		///     A handle to the conversation handle previously returned by this function. If this parameter is 0L, the function returns the first conversation
		///     handle in the list.
		/// </param>
		/// <returns>If the list contains any more conversation handles, the return value is the next conversation handle in the list; otherwise, it is 0L.</returns>
		[DllImport("user32.dll", EntryPoint = "DdeQueryNextServer")]
		public static extern IntPtr DdeQueryNextServer(IntPtr hConvList, IntPtr hConvPrev);

		/// <summary>
		///     Creates an icon or cursor from an <see cref="ICONINFO" /> structure.
		/// </summary>
		/// <param name="piconinfo">
		///     A pointer to an <see cref="ICONINFO" /> structure the function uses to create the icon or cursor.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to the icon or cursor that is created.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The system copies the bitmaps in the <see cref="ICONINFO" /> structure before creating the icon or cursor. Because the system may temporarily
		///         select the bitmaps in a device context, the <see cref="ICONINFO.hbmMask" /> and <see cref="ICONINFO.hbmColor" /> members of the
		///         <see cref="ICONINFO" />
		///         structure should not already be selected into a device context. The application must continue to manage the original bitmaps and delete them
		///         when they are no longer necessary.
		///     </para>
		///     <para>
		///         When you are finished using the icon, destroy it using the <see cref="DestroyIcon" /> function.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CreateIconIndirect")]
		public static extern IntPtr CreateIconIndirect([In] ref ICONINFO piconinfo);

		/// <summary>
		///     Creates a modeless dialog box from a dialog box template resource. Before displaying the dialog box, the function passes an application-defined
		///     value to the dialog box procedure as the lParam parameter of the <see cref="WM.WM_INITDIALOG" /> message. An application can use this value to
		///     initialize dialog box controls.
		/// </summary>
		/// <param name="hInstance">A handle to the module whose executable file contains the dialog box template.</param>
		/// <param name="lpTemplateName">
		///     The dialog box template. This parameter is either the pointer to a null-terminated character string that specifies the name of the dialog box
		///     template or an integer value that specifies the resource identifier of the dialog box template. If the parameter specifies a resource identifier,
		///     its high-order word must be zero and low-order word must contain the identifier. You can use the MAKEINTRESOURCE macro to create this value.
		/// </param>
		/// <param name="hWndParent">A handle to the window that owns the dialog box.</param>
		/// <param name="lpDialogFunc">
		///     A pointer to the dialog box procedure. For more information about the dialog box procedure, see <see cref="DialogProc" />.
		/// </param>
		/// <param name="dwInitParam">
		///     The value to be passed to the dialog box procedure in the lParam parameter in the <see cref="WM.WM_INITDIALOG" /> message.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the window handle to the dialog box.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="CreateDialogParam" /> function uses the <see cref="CreateWindowEx" /> function to create the dialog box.
		///         <see cref="CreateDialogParam" /> then sends a <see cref="WM.WM_INITDIALOG" /> message (and a <see cref="WM.WM_SETFONT" /> message if the
		///         template specifies the DS_SETFONT or DS_SHELLFONT style) to the dialog box procedure. The function displays the dialog box if the template
		///         specifies the <see cref="WS.WS_VISIBLE" /> style. Finally, <see cref="CreateDialogParam" /> returns the window handle of the dialog box.
		///     </para>
		///     <para>
		///         After <see cref="CreateDialogParam" /> returns, the application displays the dialog box (if it is not already displayed) using the
		///         <see cref="ShowWindow" /> function. The application destroys the dialog box by using the <see cref="DestroyWindow" /> function. To support
		///         keyboard navigation and other dialog box functionality, the message loop for the dialog box must call the <see cref="IsDialogMessage" />
		///         function.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CreateDialogParam")]
		public static extern IntPtr CreateDialogParam(
			[In] IntPtr hInstance, [In] string lpTemplateName, [In] IntPtr hWndParent, DialogProc lpDialogFunc, [MarshalAs(UnmanagedType.SysInt)] int dwInitParam);

		/// <summary>Closes an open window station handle.</summary>
		/// <param name="hWinSta">
		///     A handle to the window station to be closed. This handle is returned by the <see cref="CreateWindowStation" /> or
		///     <see cref="OpenWindowStation" /> function. Do not specify the handle returned by the <see cref="GetProcessWindowStation" /> function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     The <see cref="CloseWindowStation" /> function will fail if the handle being closed is for the window station assigned to the calling process.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "CloseWindowStation")]
		public static extern bool CloseWindowStation([In] IntPtr hWinSta);

		/// <summary>
		///     Checks a specified menu item and makes it a radio item. At the same time, the function clears all other menu items in the associated group and
		///     clears the radio-item type flag for those items.
		/// </summary>
		/// <param name="hmenu">A handle to the menu that contains the group of menu items.</param>
		/// <param name="idFirst">The identifier or position of the first menu item in the group.</param>
		/// <param name="idLast">The identifier or position of the last menu item in the group.</param>
		/// <param name="idCheck">The identifier or position of the menu item to check.</param>
		/// <param name="uFlags">
		///     Indicates the meaning of <paramref name="idFirst" />, <paramref name="idLast" />, and <paramref name="idCheck" />. If this parameter is
		///     <see cref="MF.MF_BYCOMMAND" />, the other parameters specify menu item identifiers. If it is <see cref="MF.MF_BYPOSITION" />, the other
		///     parameters specify the menu item positions.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="CheckMenuRadioItem" /> function sets the MFT_RADIOCHECK type flag and the MFS_CHECKED state for the item specified by
		///         <paramref name="idCheck" /> and, at the same time, clears both flags for all other items in the group. The selected item is displayed using a
		///         bullet bitmap instead of a check-mark bitmap.
		///     </para>
		///     <para>
		///         For more information about menu item type and state flags, see the <see cref="MENUITEMINFO" /> structure.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "CheckMenuRadioItem")]
		public static extern bool CheckMenuRadioItem([In] IntPtr hmenu, uint idFirst, uint idLast, uint idCheck, MF uFlags);

		/// <summary>
		///     Calculates the required size of the window rectangle, based on the desired size of the client rectangle. The window rectangle can then be passed
		///     to the <see cref="CreateWindowEx" /> function to create a window whose client area is the desired size.
		/// </summary>
		/// <param name="lpRect">
		///     A pointer to a <see cref="RECT" /> structure that contains the coordinates of the top-left and bottom-right corners of the desired client area.
		///     When the function returns, the structure contains the coordinates of the top-left and bottom-right corners of the window to accommodate the
		///     desired client area.
		/// </param>
		/// <param name="dwStyle">
		///     The window style of the window whose required size is to be calculated. Note that you cannot specify the <see cref="WS.WS_OVERLAPPED" /> style.
		/// </param>
		/// <param name="bMenu">Indicates whether the window has a menu.</param>
		/// <param name="dwExStyle">The extended window style of the window whose required size is to be calculated.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         A client rectangle is the smallest rectangle that completely encloses a client area. A window rectangle is the smallest rectangle that
		///         completely encloses the window, which includes the client area and the nonclient area.
		///     </para>
		///     <para>
		///         The <see cref="AdjustWindowRectEx" /> function does not add extra space when a menu bar wraps to two or more rows.
		///     </para>
		///     <para>
		///         The <see cref="AdjustWindowRectEx" /> function does not take the <see cref="WS.WS_VSCROLL" /> or <see cref="WS.WS_HSCROLL" /> styles into account.
		///         To account for the scroll bars, call the <see cref="GetSystemMetrics" /> function with <see cref="SM.SM_CXVSCROLL" /> or
		///         <see cref="SM.SM_CYHSCROLL" />.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "AdjustWindowRectEx")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool AdjustWindowRectEx(ref RECT lpRect, WS dwStyle, [MarshalAs(UnmanagedType.Bool)] bool bMenu, WS_EX dwExStyle);

		[DllImport("user32.dll", EntryPoint = "UnhookWindowsHook")]
		[return: MarshalAs(UnmanagedType.Bool)]
		protected static extern bool UnhookWindowsHookInternal(WH nCode, HOOKPROC pfnFilterProc);

		public static bool UnhookWindowsHook(WH nCode, HOOKPROC pfnFilterProc)
		{
			if (nCode == WH.WH_GETMESSAGE)
				return UninitializeHook(nCode);

			return UnhookWindowsHookInternal(nCode, pfnFilterProc);
		}

		[DllImport("user32.dll", EntryPoint = "SetWindowsHookEx")]
		protected static extern IntPtr SetWindowsHookExInternal(WH idHook, HOOKPROC lpfn, [In] IntPtr hmod, uint dwThreadId);

		[DllImport("SystemHookCore.dll", EntryPoint = "SetUserHookCallback")]
		protected static extern IntPtr SetUserHookCallback(WH hookID, HOOKPROC lpfn, uint threadId);

		[DllImport("SystemHookCore.dll", EntryPoint = "UninitializeHook")]
		protected static extern bool UninitializeHook(WH hookType);

		public static IntPtr SetWindowsHookEx(WH idHook, HOOKPROC lpfn, IntPtr hmod, uint dwThreadId)
		{
			if (idHook == WH.WH_GETMESSAGE)
				return SetUserHookCallback(idHook, lpfn, dwThreadId);

			else
				return SetWindowsHookExInternal(idHook, lpfn, hmod, dwThreadId);
		}

		/// <summary>
		///     Sets the caret blink time to the specified number of milliseconds. The blink time is the elapsed time, in milliseconds, required to invert the
		///     caret's pixels.
		/// </summary>
		/// <param name="uMSeconds">The new blink time, in milliseconds.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The user can set the blink time using the Control Panel. Applications should respect the setting that the user has chosen. The
		///         <see cref="SetCaretBlinkTime" /> function should only be used by application that allow the user to set the blink time, such as a Control
		///         Panel applet.
		///     </para>
		///     <para>
		///         If you change the blink time, subsequently activated applications will use the modified blink time, even if you restore the previous blink
		///         time when you lose the keyboard focus or become inactive. This is due to the multithreaded environment, where deactivation of your
		///         application is not synchronized with the activation of another application. This feature allows the system to activate another application
		///         even if the current application is not responding.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetCaretBlinkTime")]
		public static extern bool SetCaretBlinkTime(uint uMSeconds);

		/// <summary>
		///     The <see cref="MonitorFromWindow" /> function retrieves a handle to the display monitor that has the largest area of intersection with the
		///     bounding rectangle of a specified window.
		/// </summary>
		/// <param name="hwnd">A handle to the window of interest.</param>
		/// <param name="dwFlags">
		///     <para>Determines the function's return value if the window does not intersect any display monitor.</para>
		///     <para>This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MONITOR_DEFAULTTONEAREST</term>
		///             <description>Returns a handle to the display monitor that is nearest to the window.</description>
		///         </item>
		///         <item>
		///             <term>MONITOR_DEFAULTTONULL</term>
		///             <description>Returns NULL.</description>
		///         </item>
		///         <item>
		///             <term>MONITOR_DEFAULTTOPRIMARY</term>
		///             <description>Returns a handle to the primary display monitor.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>
		///         If the window intersects one or more display monitor rectangles, the return value is an HMONITOR handle to the display monitor that has the
		///         largest area of intersection with the window.
		///     </para>
		///     <para>
		///         If the window does not intersect a display monitor, the return value depends on the value of <paramref name="dwFlags" />.
		///     </para>
		/// </returns>
		/// <remarks>
		///     If the window is currently minimized, <see cref="MonitorFromWindow" /> uses the rectangle of the window before it was minimized.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "MonitorFromWindow")]
		public static extern IntPtr MonitorFromWindow([In] IntPtr hwnd, MONITOR dwFlags);

		/// <summary>Determines which menu item, if any, is at the specified location.</summary>
		/// <param name="hWnd">
		///     A handle to the window containing the menu. If this value is NULL and the <paramref name="hMenu" /> parameter represents a popup menu, the
		///     function will find the menu window.
		/// </param>
		/// <param name="hMenu">A handle to the menu containing the menu items to hit test.</param>
		/// <param name="ptScreen">
		///     A structure that specifies the location to test. If <paramref name="hMenu" /> specifies a menu bar, this parameter is in window coordinates.
		///     Otherwise, it is in client coordinates.
		/// </param>
		/// <returns>Returns the zero-based position of the menu item at the specified location or -1 if no menu item is at the specified location.</returns>
		[DllImport("user32.dll", EntryPoint = "MenuItemFromPoint")]
		public static extern int MenuItemFromPoint([In] IntPtr hWnd, [In] IntPtr hMenu, POINT ptScreen);

		/// <summary>Loads the specified menu template in memory.</summary>
		/// <param name="lpMenuTemplate">
		///     A pointer to a menu template or an extended menu template. A menu template consists of a <see cref="MENUITEMTEMPLATEHEADER" /> structure followed
		///     by one or more contiguous <see cref="MENUITEMTEMPLATE" /> structures. An extended menu template consists of a
		///     MENUEX_TEMPLATE_HEADER structure followed by one or more contiguous MENUEX_TEMPLATE_ITEM structures.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to the menu.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     For both the ANSI and the Unicode version of this function, the strings in the <see cref="MENUITEMTEMPLATE" /> structure must be Unicode strings.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "LoadMenuIndirect")]
		public static extern IntPtr LoadMenuIndirect([In] IntPtr lpMenuTemplate);

		/// <summary>Loads the specified accelerator table.</summary>
		/// <param name="hInstance">A handle to the module whose executable file contains the accelerator table to be loaded.</param>
		/// <param name="lpTableName">
		///     The name of the accelerator table to be loaded. Alternatively, this parameter can specify the resource identifier of an accelerator-table
		///     resource in the low-order word and zero in the high-order word. To create this value, use the MAKEINTRESOURCE macro.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to the loaded accelerator table.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>If the accelerator table has not yet been loaded, the function loads it from the specified executable file.</para>
		///     <para>Accelerator tables loaded from resources are freed automatically when the application terminates.</para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "LoadAccelerators")]
		public static extern IntPtr LoadAccelerators([In] IntPtr hInstance, [In] string lpTableName);

		/// <summary>Performs a buffered read of the raw input data.</summary>
		/// <param name="pData">
		///     A pointer to a buffer of <see cref="RAWINPUT" /> structures that contain the raw input data. If NULL, the minimum required buffer, in bytes, is
		///     returned in *<paramref name="pcbSize" />.
		/// </param>
		/// <param name="pcbSize">
		///     The size, in bytes, of a <see cref="RAWINPUT" /> structure.
		/// </param>
		/// <param name="cbSizeHeader">
		///     The size, in bytes, of the <see cref="RAWINPUTHEADER" /> structure.
		/// </param>
		/// <returns>
		///     <para>
		///         If <paramref name="pData" /> is NULL and the function is successful, the return value is zero. If <paramref name="pData" /> is not NULL and
		///         the function is successful, the return value is the number of <see cref="RAWINPUT" /> structures written to <paramref name="pData" />.
		///     </para>
		///     <para>If an error occurs, the return value is (UINT)-1. Call GetLastError for the error code.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Using <see cref="GetRawInputBuffer" />, the raw input data is buffered in the array of <see cref="RAWINPUT" /> structures. For an unbuffered
		///         read, use the <see cref="GetMessage" /> function to read in the raw input data.
		///     </para>
		///     <para>
		///         The NEXTRAWINPUTBLOCK macro allows an application to traverse an array of <see cref="RAWINPUT" /> structures.
		///     </para>
		///     <para>
		///         Note:  To get the correct size of the raw input buffer, do not use *<paramref name="pcbSize" />, use *
		///         <paramref name="pcbSize" /> * 8 instead. To ensure <see cref="GetRawInputBuffer" /> behaves properly on WOW64, you must align the
		///         <see cref="RAWINPUT" /> structure by 8 bytes. The following code shows how to align <see cref="RAWINPUT" /> for WOW64.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetRawInputBuffer")]
		public static extern uint GetRawInputBuffer(ref RAWINPUT[] pData, ref uint pcbSize, uint cbSizeHeader);

		/// <summary>
		///     Retrieves a handle to the first control that has the <see cref="WS.WS_TABSTOP" /> style that precedes (or follows) the specified control.
		/// </summary>
		/// <param name="hDlg">A handle to the dialog box to be searched.</param>
		/// <param name="hCtl">A handle to the control to be used as the starting point for the search. If this parameter is NULL, the function fails.</param>
		/// <param name="bPrevious">
		///     Indicates how the function is to search the dialog box. If this parameter is TRUE, the function searches for the previous control in the dialog
		///     box. If this parameter is FALSE, the function searches for the next control in the dialog box.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is the window handle of the previous (or next) control that has the
		///         <see cref="WS.WS_TABSTOP" />
		///         style set.
		///     </para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="GetNextDlgTabItem" /> function searches controls in the order (or reverse order) they were created in the dialog box template.
		///         The function returns the first control it locates that is visible, not disabled, and has the <see cref="WS.WS_TABSTOP" /> style. If no
		///         such control exists, the function returns <paramref name="hCtl" />.
		///     </para>
		///     <para>
		///         If the search for the next control with the <see cref="WS.WS_TABSTOP" /> style encounters a window with the
		///         <see cref="WS_EX.WS_EX_CONTROLPARENT" />
		///         style, the system recursively searches the window's children.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetNextDlgTabItem")]
		public static extern IntPtr GetNextDlgTabItem([In] IntPtr hDlg, [In] IntPtr hCtl, [MarshalAs(UnmanagedType.Bool)] bool bPrevious);

		/// <summary>
		///     Retrieves the active input locale identifier (formerly called the keyboard layout) for the specified thread. If the <paramref name="idThread" />
		///     parameter is zero, the input locale identifier for the active thread is returned.
		/// </summary>
		/// <param name="idThread">The identifier of the thread to query, or 0 for the current thread.</param>
		/// <returns>
		///     The return value is the input locale identifier for the thread. The low word contains a Language Identifier for the input language and the high
		///     word contains a device handle to the physical layout of the keyboard.
		/// </returns>
		/// <remarks>
		///     <para>
		///         The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input
		///         Method Editor (IME), or any other form of input.
		///     </para>
		///     <para>
		///         Since the keyboard layout can be dynamically changed, applications that cache information about the current keyboard layout should process
		///         the <see cref="WM.WM_INPUTLANGCHANGE" /> message to be informed of changes in the input language.
		///     </para>
		///     <para>
		///         To get the KLID (keyboard layout ID) of the currently active HKL, call the <see cref="GetKeyboardLayoutName" />. To find out if a particular
		///         KLID is loaded, call <see cref="GetKeyboardLayoutList" />, load the keyboard with <see cref="LoadKeyboardLayout" />, and then check to see if
		///         the HKL is the same as the one already loaded. If not, unload it after.
		///     </para>
		///     <para>
		///         Beginning in Windows 8: The preferred method to retrieve the language associated with the current keyboard layout or input method is a call
		///         to CurrentInputMethodLanguageTag. If your app passes language tags from
		///         CurrentInputMethodLanguageTag to any National Language Support functions, it must first convert the tags by calling
		///         ResolveLocaleName.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetKeyboardLayout")]
		public static extern IntPtr GetKeyboardLayout(uint idThread);

		/// <summary>Retrieves the window handle of the current owner of the clipboard.</summary>
		/// <returns>
		///     <para>If the function succeeds, the return value is the handle to the window that owns the clipboard.</para>
		///     <para>If the clipboard is not owned, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>The clipboard can still contain data even if the clipboard is not currently owned.</para>
		///     <para>
		///         In general, the clipboard owner is the window that last placed data in clipboard. The <see cref="EmptyClipboard" /> function assigns
		///         clipboard ownership.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetClipboardOwner")]
		public static extern IntPtr GetClipboardOwner();

		/// <summary>Retrieves the time required to invert the caret's pixels. The user can set this value.</summary>
		/// <returns>
		///     <para>If the function succeeds, the return value is the blink time, in milliseconds.</para>
		///     <para>A return value of INFINITE indicates that the caret does not blink.</para>
		///     <para>A return value is zero indicates that the function has failed. To get extended error information, call GetLastError.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetCaretBlinkTime")]
		public static extern uint GetCaretBlinkTime();

		/// <summary>
		///     Enumerates all nonchild windows associated with a thread by passing the handle to each window, in turn, to an application-defined callback
		///     function. <see cref="EnumThreadWindows" /> continues until the last window is enumerated or the callback function returns FALSE. To enumerate
		///     child windows of a particular window, use the <see cref="EnumChildWindows" /> function.
		/// </summary>
		/// <param name="dwThreadId">The identifier of the thread whose windows are to be enumerated.</param>
		/// <param name="lpfn">
		///     A pointer to an application-defined callback function. For more information, see <see cref="EnumWindowsProc" />.
		/// </param>
		/// <param name="lParam">An application-defined value to be passed to the callback function.</param>
		/// <returns>
		///     <para>
		///         If the callback function returns TRUE for all windows in the thread specified by <paramref name="dwThreadId" />, the return value is TRUE. If
		///         the callback function returns FALSE on any enumerated window, or if there are no windows found in the thread specified by
		///         <paramref name="dwThreadId" />, the return value is FALSE.
		///     </para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "EnumThreadWindows")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool EnumThreadWindows(uint dwThreadId, EnumWindowsProc lpfn, [MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>Simultaneously updates the position and size of one or more windows in a single screen-refreshing cycle.</summary>
		/// <param name="hWinPosInfo">
		///     A handle to a multiple-window – position structure that contains size and position information for one or more windows. This internal structure
		///     is returned by the <see cref="BeginDeferWindowPos" /> function or by the most recent call to the <see cref="DeferWindowPos" /> function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     The <see cref="EndDeferWindowPos" /> function sends the <see cref="WM.WM_WINDOWPOSCHANGING" /> and <see cref="WM.WM_WINDOWPOSCHANGED" /> messages
		///     to each window identified in the internal structure.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "EndDeferWindowPos")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool EndDeferWindowPos([In] IntPtr hWinPosInfo);

		/// <summary>Animates the caption of a window to indicate the opening of an icon or the minimizing or maximizing of a window.</summary>
		/// <param name="hwnd">A handle to the window whose caption should be animated on the screen. The animation will be clipped to the parent of this window.</param>
		/// <param name="idAni">
		///     The type of animation. This must be IDANI_CAPTION. With the IDANI_CAPTION animation type, the window caption will animate from the position
		///     specified by lprcFrom to the position specified by lprcTo. The effect is similar to minimizing or maximizing a window.
		/// </param>
		/// <param name="lprcFrom">
		///     A pointer to a <see cref="RECT" /> structure specifying the location and size of the icon or minimized window. Coordinates are relative to the
		///     clipping window <paramref name="hwnd" />.
		/// </param>
		/// <param name="lprcTo">
		///     A pointer to a <see cref="RECT" /> structure specifying the location and size of the restored window. Coordinates are relative to the clipping
		///     window <paramref name="hwnd" />.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DrawAnimatedRects")]
		public static extern bool DrawAnimatedRects([In] IntPtr hwnd, int idAni, [In] ref RECT lprcFrom, [In] ref RECT lprcTo);

		/// <summary>Frees a Dynamic Data Exchange (DDE) object and deletes the data handle associated with the object.</summary>
		/// <param name="hData">
		///     A handle to the DDE object to be freed. This handle must have been created by a previous call to the <see cref="DdeCreateDataHandle" /> function
		///     or returned by the <see cref="DdeClientTransaction" /> function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		/// <remarks>
		///     An application must call <see cref="DdeFreeDataHandle" /> under the following circumstances:
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DdeFreeDataHandle")]
		public static extern bool DdeFreeDataHandle(IntPtr hData);

		/// <summary>Enables or disables transactions for a specific conversation or for all conversations currently established by the calling application.</summary>
		/// <param name="idInst">
		///     The application-instance identifier obtained by a previous call to the <see cref="DdeInitialize" /> function.
		/// </param>
		/// <param name="hConv">A handle to the conversation to enable or disable. If this parameter is NULL, the function affects all conversations.</param>
		/// <param name="wCmd">
		///     <para>The function code. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>EC_ENABLEALL 0</term>
		///             <description>Enables all transactions for the specified conversation.</description>
		///         </item>
		///         <item>
		///             <term>EC_ENABLEONE 0x0080</term>
		///             <description>Enables one transaction for the specified conversation.</description>
		///         </item>
		///         <item>
		///             <term>EC_DISABLE 0x0008</term>
		///             <description>
		///                 <para>Disables all blockable transactions for the specified conversation.</para>
		///                 <para>A server application can disable the following transactions:</para>
		///                 <para>A client application can disable the following transactions:</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>EC_QUERYWAITING 2</term>
		///             <description>Determines whether any transactions are in the queue for the specified conversation.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		///     <para>
		///         If the <paramref name="wCmd" /> parameter is <see cref="EC.EC_QUERYWAITING" />, and the application transaction queue contains one or more
		///         unprocessed transactions that are not being processed, the return value is TRUE; otherwise, it is FALSE.
		///     </para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         An application can disable transactions for a specific conversation by returning the CBR_BLOCK return code from its Dynamic
		///         Data Exchange (DDE) callback function. When you reenable the conversation by using the <see cref="DdeEnableCallback" /> function, the
		///         operating system generates the same transaction that was in process when the conversation was disabled.
		///     </para>
		///     <para>
		///         Using the <see cref="EC.EC_QUERYWAITING" /> flag does not change the enable state of the conversation and does not cause transactions to be
		///         issued within the context of the call to <see cref="DdeEnableCallback" />.
		///     </para>
		///     <para>
		///         If <see cref="DdeEnableCallback" /> is called with <see cref="EC.EC_QUERYWAITING" /> and the function returns a nonzero, an application should
		///         try to quickly allow message processing, return from its callback, or enable callbacks. Such a result does not guarantee that subsequent
		///         callbacks will be made. Calling <see cref="DdeEnableCallback" /> with <see cref="EC.EC_QUERYWAITING" /> lets an application with blocked
		///         callbacks determine whether there are any transactions pending on the blocked conversation. Of course, even if such a call returns zero, an
		///         application should always process messages in a timely manner.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DdeEnableCallback")]
		public static extern bool DdeEnableCallback(uint idInst, IntPtr hConv, uint wCmd);

		/// <summary>Destroys the specified conversation list and terminates all conversations associated with the list.</summary>
		/// <param name="hConvList">
		///     A handle to the conversation list. This handle must have been created by a previous call to the <see cref="DdeConnectList" /> function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		/// <remarks>
		///     An application can use the <see cref="DdeDisconnect" /> function to terminate individual conversations in the list.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DdeDisconnectList")]
		public static extern bool DdeDisconnectList(IntPtr hConvList);

		/// <summary>Attaches or detaches the input processing mechanism of one thread to that of another thread.</summary>
		/// <param name="idAttach">The identifier of the thread to be attached to another thread. The thread to be attached cannot be a system thread.</param>
		/// <param name="idAttachTo">
		///     <para>
		///         The identifier of the thread to which <paramref name="idAttach" /> will be attached. This thread cannot be a system thread.
		///     </para>
		///     <para>
		///         A thread cannot attach to itself. Therefore, <paramref name="idAttachTo" /> cannot equal <paramref name="idAttach" />.
		///     </para>
		/// </param>
		/// <param name="fAttach">If this parameter is TRUE, the two threads are attached. If the parameter is FALSE, the threads are detached.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Windows created in different threads typically process input independently of each other. That is, they have their own input states (focus,
		///         active, capture windows, key state, queue status, and so on), and their input processing is not synchronized with the input processing of
		///         other threads. By using the <see cref="AttachThreadInput" /> function, a thread can attach its input processing mechanism to another thread.
		///         Keyboard and mouse events received by both threads are processed by the thread specified by the <paramref name="idAttachTo" /> parameter
		///         until the threads are detached by calling <see cref="AttachThreadInput" /> a second time and specifying FALSE for the
		///         <paramref name="fAttach" /> parameter. This also allows threads to share their input states, so they can call the <see cref="SetFocus" />
		///         function to set the keyboard focus to a window of a different thread. This also allows threads to get key-state information.
		///     </para>
		///     <para>
		///         The <see cref="AttachThreadInput" /> function fails if either of the specified threads does not have a message queue. The system creates a
		///         thread's message queue when the thread makes its first call to one of the USER or GDI functions. The <see cref="AttachThreadInput" />
		///         function also fails if a journal record hook is installed. Journal record hooks attach all input queues together.
		///     </para>
		///     <para>
		///         Note that key state, which can be ascertained by calls to the <see cref="GetKeyState" /> or <see cref="GetKeyboardState" /> function, is
		///         reset after a call to <see cref="AttachThreadInput" />. You cannot attach a thread to a thread in another desktop.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "AttachThreadInput")]
		public static extern bool AttachThreadInput(uint idAttach, uint idAttachTo, [MarshalAs(UnmanagedType.Bool)] bool fAttach);

		/// <summary>
		///     Waits until the specified process has finished processing its initial input and is waiting for user input with no input pending, or until the
		///     time-out interval has elapsed.
		/// </summary>
		/// <param name="hProcess">
		///     A handle to the process. If this process is a console application or does not have a message queue, <see cref="WaitForInputIdle" /> returns
		///     immediately.
		/// </param>
		/// <param name="dwMilliseconds">
		///     The time-out interval, in milliseconds. If <paramref name="dwMilliseconds" /> is INFINITE, the function does not return until the process is
		///     idle.
		/// </param>
		/// <returns>The following table shows the possible return values for this function.</returns>
		/// <remarks>
		///     <para>
		///         The <see cref="WaitForInputIdle" /> function enables a thread to suspend its execution until the specified process has finished its
		///         initialization and is waiting for user input with no input pending. If the process has multiple threads, the <see cref="WaitForInputIdle" />
		///         function returns as soon as any thread becomes idle.
		///     </para>
		///     <para>
		///         <see cref="WaitForInputIdle" /> can be used at any time, not just during application startup. However, <see cref="WaitForInputIdle" /> waits
		///         only once for a process to become idle; subsequent <see cref="WaitForInputIdle" /> calls return immediately, whether the process is idle or
		///         busy.
		///     </para>
		///     <para>
		///         <see cref="WaitForInputIdle" /> can be useful for synchronizing a parent process and a newly created child process. When a parent process
		///         creates a child process, the CreateProcess function returns without waiting for the child process to finish its
		///         initialization. Before trying to communicate with the child process, the parent process can use the <see cref="WaitForInputIdle" /> function
		///         to determine when the child's initialization has been completed. For example, the parent process should use the
		///         <see cref="WaitForInputIdle" /> function before trying to find a window associated with the child process.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "WaitForInputIdle")]
		public static extern uint WaitForInputIdle([In] IntPtr hProcess, uint dwMilliseconds);

		/// <summary>Frees a hot key previously registered by the calling thread.</summary>
		/// <param name="hWnd">
		///     A handle to the window associated with the hot key to be freed. This parameter should be NULL if the hot key is not associated
		///     with a window.
		/// </param>
		/// <param name="id">The identifier of the hot key to be freed.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "UnregisterHotKey")]
		public static extern bool UnregisterHotKey([In] IntPtr hWnd, int id);

		/// <summary>Unregisters a window class, freeing the memory required for the class.</summary>
		/// <param name="lpClassName">
		///     A null-terminated string or a class atom. If <paramref name="lpClassName" /> is a string, it specifies the window class name. This class name
		///     must have been registered by a previous call to the <see cref="RegisterClass" /> or <see cref="RegisterClassEx" /> function. System classes, such
		///     as dialog box controls, cannot be unregistered. If this parameter is an atom, it must be a class atom created by a previous call to the
		///     <see cref="RegisterClass" /> or <see cref="RegisterClassEx" /> function. The atom must be in the low-order word of
		///     <paramref name="lpClassName" />; the high-order word must be zero.
		/// </param>
		/// <param name="hInstance">A handle to the instance of the module that created the class.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>
		///         If the class could not be found or if a window still exists that was created with the class, the return value is zero. To get extended error
		///         information, call GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>Before calling this function, an application must destroy all windows created with the specified class.</para>
		///     <para>All window classes that an application registers are unregistered when it terminates.</para>
		///     <para>
		///         Class atoms are special atoms returned only by <see cref="RegisterClass" /> and <see cref="RegisterClassEx" />.
		///     </para>
		///     <para>No window classes registered by a DLL are unregistered when the .dll is unloaded.</para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "UnregisterClass")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool UnregisterClass([In] string lpClassName, [In] IntPtr hInstance);

		/// <summary>
		///     Translates virtual-key messages into character messages. The character messages are posted to the calling thread's message queue, to be read the
		///     next time the thread calls the <see cref="GetMessage" /> or <see cref="PeekMessage" /> function.
		/// </summary>
		/// <param name="lpMsg">
		///     A pointer to an <see cref="MSG" /> structure that contains message information retrieved from the calling thread's message queue by using the
		///     <see cref="GetMessage" /> or <see cref="PeekMessage" /> function.
		/// </param>
		/// <returns>
		///     <para>If the message is translated (that is, a character message is posted to the thread's message queue), the return value is nonzero.</para>
		///     <para>
		///         If the message is <see cref="WM.WM_KEYDOWN" />, <see cref="WM.WM_KEYUP" />, <see cref="WM.WM_SYSKEYDOWN" />, or <see cref="WM.WM_SYSKEYUP" />
		///         , the return value is nonzero, regardless of the translation.
		///     </para>
		///     <para>If the message is not translated (that is, a character message is not posted to the thread's message queue), the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="TranslateMessage" /> function does not modify the message pointed to by the <paramref name="lpMsg" /> parameter.
		///     </para>
		///     <para>
		///         <see cref="WM.WM_KEYDOWN" /> and <see cref="WM.WM_KEYUP" /> combinations produce a <see cref="WM.WM_CHAR" /> or <see cref="WM.WM_DEADCHAR" />
		///         message.
		///         <see cref="WM.WM_SYSKEYDOWN" /> and <see cref="WM.WM_SYSKEYUP" /> combinations produce a <see cref="WM.WM_SYSCHAR" /> or
		///         <see cref="WM.WM_SYSDEADCHAR" />
		///         message.
		///     </para>
		///     <para>
		///         <see cref="TranslateMessage" /> produces <see cref="WM.WM_CHAR" /> messages only for keys that are mapped to ASCII characters by the keyboard
		///         driver.
		///     </para>
		///     <para>
		///         If applications process virtual-key messages for some other purpose, they should not call <see cref="TranslateMessage" />. For instance, an
		///         application should not call <see cref="TranslateMessage" /> if the <see cref="TranslateAccelerator" /> function returns a nonzero value. Note
		///         that the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use the main message
		///         loop for this. However, to permit the user to move to and to select controls by using the keyboard, the application must call
		///         <see cref="IsDialogMessage" />. For more information, see Dialog Box Keyboard Interface.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "TranslateMessage")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool TranslateMessage([In] ref MSG lpMsg);

		/// <summary>
		///     Displays a shortcut menu at the specified location and tracks the selection of items on the shortcut menu. The shortcut menu can appear anywhere
		///     on the screen.
		/// </summary>
		/// <param name="hmenu">
		///     A handle to the shortcut menu to be displayed. This handle can be obtained by calling the <see cref="CreatePopupMenu" /> function to create a new
		///     shortcut menu or by calling the <see cref="GetSubMenu" /> function to retrieve a handle to a submenu associated with an existing menu item.
		/// </param>
		/// <param name="fuFlags">
		///     <para>Specifies function options.</para>
		///     <para>Use one of the following flags to specify how the function positions the shortcut menu horizontally.</para>
		///     <list type="table">
		///         <item>
		///             <term>TPM_CENTERALIGN 0x0004L</term>
		///             <description>
		///                 Centers the shortcut menu horizontally relative to the coordinate specified by the <paramref name="x" /> parameter.
		///             </description>
		///         </item>
		///         <item>
		///             <term>TPM_LEFTALIGN 0x0000L</term>
		///             <description>
		///                 Positions the shortcut menu so that its left side is aligned with the coordinate specified by the <paramref name="x" /> parameter.
		///             </description>
		///         </item>
		///         <item>
		///             <term>TPM_RIGHTALIGN 0x0008L</term>
		///             <description>
		///                 Positions the shortcut menu so that its right side is aligned with the coordinate specified by the <paramref name="x" /> parameter.
		///             </description>
		///         </item>
		///     </list>
		///     <para>Use one of the following flags to specify how the function positions the shortcut menu vertically.</para>
		///     <list type="table">
		///         <item>
		///             <term>TPM_BOTTOMALIGN 0x0020L</term>
		///             <description>
		///                 Positions the shortcut menu so that its bottom side is aligned with the coordinate specified by the <paramref name="y" /> parameter.
		///             </description>
		///         </item>
		///         <item>
		///             <term>TPM_TOPALIGN 0x0000L</term>
		///             <description>
		///                 Positions the shortcut menu so that its top side is aligned with the coordinate specified by the <paramref name="y" /> parameter.
		///             </description>
		///         </item>
		///         <item>
		///             <term>TPM_VCENTERALIGN 0x0010L</term>
		///             <description>
		///                 Centers the shortcut menu vertically relative to the coordinate specified by the <paramref name="y" /> parameter.
		///             </description>
		///         </item>
		///     </list>
		///     <para>Use the following flags to control discovery of the user selection without having to set up a parent window for the menu.</para>
		///     <list type="table">
		///         <item>
		///             <term>TPM_NONOTIFY 0x0080L</term>
		///             <description>The function does not send notification messages when the user clicks a menu item.</description>
		///         </item>
		///         <item>
		///             <term>TPM_RETURNCMD 0x0100L</term>
		///             <description>The function returns the menu item identifier of the user's selection in the return value.</description>
		///         </item>
		///     </list>
		///     <para>Use one of the following flags to specify which mouse button the shortcut menu tracks.</para>
		///     <list type="table">
		///         <item>
		///             <term>TPM_LEFTBUTTON 0x0000L</term>
		///             <description>The user can select menu items with only the left mouse button.</description>
		///         </item>
		///         <item>
		///             <term>TPM_RIGHTBUTTON 0x0002L</term>
		///             <description>The user can select menu items with both the left and right mouse buttons.</description>
		///         </item>
		///     </list>
		///     <para>
		///         Use any reasonable combination of the following flags to modify the animation of a menu. For example, by selecting a horizontal and a
		///         vertical flag, you can achieve diagonal animation.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>TPM_HORNEGANIMATION 0x0800L</term>
		///             <description>Animates the menu from right to left.</description>
		///         </item>
		///         <item>
		///             <term>TPM_HORPOSANIMATION 0x0400L</term>
		///             <description>Animates the menu from left to right.</description>
		///         </item>
		///         <item>
		///             <term>TPM_NOANIMATION 0x4000L</term>
		///             <description>Displays menu without animation.</description>
		///         </item>
		///         <item>
		///             <term>TPM_VERNEGANIMATION 0x2000L</term>
		///             <description>Animates the menu from bottom to top.</description>
		///         </item>
		///         <item>
		///             <term>TPM_VERPOSANIMATION 0x1000L</term>
		///             <description>Animates the menu from top to bottom.</description>
		///         </item>
		///     </list>
		///     <para>
		///         For any animation to occur, the <see cref="SystemParametersInfo" /> function must set <see cref="SPI.SPI_SETMENUANIMATION" />. Also, all the
		///         TPM_*ANIMATION flags, except <see cref="TPM.TPM_NOANIMATION" />, are ignored if menu fade animation is on. For more information,
		///         see the <see cref="SPI.SPI_GETMENUFADE" /> flag in <see cref="SystemParametersInfo" />.
		///     </para>
		///     <para>
		///         Use the <see cref="TPM.TPM_RECURSE" /> flag to display a menu when another menu is already displayed. This is intended to support context menus
		///         within a menu.
		///     </para>
		///     <para>Use one of the following flags to specify whether to accommodate horizontal or vertical alignment.</para>
		///     <list type="table">
		///         <item>
		///             <term>TPM_HORIZONTAL 0x0000L</term>
		///             <description>
		///                 If the menu cannot be shown at the specified location without overlapping the excluded rectangle, the system tries to accommodate the
		///                 requested horizontal alignment before the requested vertical alignment.
		///             </description>
		///         </item>
		///         <item>
		///             <term>TPM_VERTICAL 0x0040L</term>
		///             <description>
		///                 If the menu cannot be shown at the specified location without overlapping the excluded rectangle, the system tries to accommodate the
		///                 requested vertical alignment before the requested horizontal alignment.
		///             </description>
		///         </item>
		///     </list>
		///     <para>
		///         The excluded rectangle is a portion of the screen that the menu should not overlap; it is specified by the <paramref name="lptpm" />
		///         parameter.
		///     </para>
		///     <para>
		///         For right-to-left text layout, use <see cref="TPM.TPM_LAYOUTRTL" />. By default, the text layout is left-to-right.
		///     </para>
		/// </param>
		/// <param name="x">The horizontal location of the shortcut menu, in screen coordinates.</param>
		/// <param name="y">The vertical location of the shortcut menu, in screen coordinates.</param>
		/// <param name="hwnd">
		///     A handle to the window that owns the shortcut menu. This window receives all messages from the menu. The window does not receive a
		///     <see cref="WM.WM_COMMAND" /> message from the menu until the function returns. If you specify TPM_NONOTIFY in the <paramref name="fuFlags" />
		///     parameter, the function does not send messages to the window identified by <paramref name="hwnd" />. However, you must still pass a window handle
		///     in <paramref name="hwnd" />. It can be any window handle from your application.
		/// </param>
		/// <param name="lptpm">
		///     A pointer to a <see cref="TPMPARAMS" /> structure that specifies an area of the screen the menu should not overlap. This parameter can be NULL.
		/// </param>
		/// <returns>
		///     <para>
		///         If you specify <see cref="TPM.TPM_RETURNCMD" /> in the <paramref name="fuFlags" /> parameter, the return value is the menu-item identifier of the
		///         item that the user selected. If the user cancels the menu without making a selection, or if an error occurs, the return value is zero.
		///     </para>
		///     <para>
		///         If you do not specify <see cref="TPM.TPM_RETURNCMD" /> in the <paramref name="fuFlags" /> parameter, the return value is nonzero if the function
		///         succeeds and zero if it fails. To get extended error information, call GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Call <see cref="GetSystemMetrics" /> with <see cref="SM.SM_MENUDROPALIGNMENT" /> to determine the correct horizontal alignment flag (
		///         <see cref="TPM.TPM_LEFTALIGN" /> or <see cref="TPM.TPM_RIGHTALIGN" />) and/or horizontal animation direction flag (<see cref="TPM.TPM_HORPOSANIMATION" />
		///         or <see cref="TPM.TPM_HORNEGANIMATION" />) to pass to <see cref="TrackPopupMenu" /> or <see cref="TrackPopupMenuEx" />. This is essential for
		///         creating an optimal user experience, especially when developing Microsoft Tablet PC applications.
		///     </para>
		///     <para>
		///         To display a context menu for a notification icon, the current window must be the foreground window before the application calls
		///         <see cref="TrackPopupMenu" /> or <see cref="TrackPopupMenuEx" />. Otherwise, the menu will not disappear when the user clicks outside of the
		///         menu or the window that created the menu (if it is visible). If the current window is a child window, you must set the (top-level) parent
		///         window as the foreground window.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "TrackPopupMenuEx")]
		public static extern bool TrackPopupMenuEx([In] IntPtr hmenu, uint fuFlags, int x, int y, [In] IntPtr hwnd, [In] ref TPMPARAMS lptpm);

		/// <summary>Assigns the specified desktop to the calling thread. All subsequent operations on the desktop use the access rights granted to the desktop.</summary>
		/// <param name="hDesktop">
		///     <para>
		///         A handle to the desktop to be assigned to the calling thread. This handle is returned by the <see cref="CreateDesktop" />,
		///         <see cref="GetThreadDesktop" />, <see cref="OpenDesktop" />, or <see cref="OpenInputDesktop" /> function.
		///     </para>
		///     <para>This desktop must be associated with the current window station for the process.</para>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="SetThreadDesktop" /> function will fail if the calling thread has any windows or hooks on its current desktop (unless the
		///         <paramref name="hDesktop" /> parameter is a handle to the current desktop).
		///     </para>
		///     <para>
		///         Warning:  There is a significant security risk for any service that opens a window on the interactive desktop. By opening a
		///         desktop window, a service makes itself vulnerable to attack from the logged-on user, whose application could send malicious messages to the
		///         service's desktop window and affect its ability to function.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetThreadDesktop")]
		public static extern bool SetThreadDesktop([In] IntPtr hDesktop);

		/// <summary>Changes information about a menu item.</summary>
		/// <param name="hMenu">A handle to the menu that contains the menu item.</param>
		/// <param name="uItem">
		///     The identifier or position of the menu item to change. The meaning of this parameter depends on the value of <paramref name="fByPosition" />.
		/// </param>
		/// <param name="fByPosition">
		///     The meaning of <paramref name="uItem" />. If this parameter is FALSE, <paramref name="uItem" /> is a menu item identifier. Otherwise, it is a
		///     menu item position. See About Menus for more information.
		/// </param>
		/// <param name="lpmii">
		///     A pointer to a <see cref="MENUITEMINFO" /> structure that contains information about the menu item and specifies which menu item attributes to
		///     change.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The application must call the <see cref="DrawMenuBar" /> function whenever a menu changes, whether the menu is in a displayed window.
		///     </para>
		///     <para>
		///         In order for keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the
		///         <see cref="WM.WM_MENUCHAR" /> message. See Owner-Drawn Menus and the WM_MENUCHAR Message for more information.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetMenuItemInfo")]
		public static extern bool SetMenuItemInfo(
			[In] IntPtr hMenu, uint uItem, [MarshalAs(UnmanagedType.Bool)] bool fByPosition, [In] ref MENUITEMINFO lpmii);

		/// <summary>
		///     Copies an array of keyboard key states into the calling thread's keyboard input-state table. This is the same table accessed by the
		///     <see cref="GetKeyboardState" /> and <see cref="GetKeyState" /> functions. Changes made to this table do not affect keyboard input to any other
		///     thread.
		/// </summary>
		/// <param name="lpKeyState">A pointer to a 256-byte array that contains keyboard key states.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     Because the <see cref="SetKeyboardState" /> function alters the input state of the calling thread and not the global input state of the system,
		///     an application cannot use <see cref="SetKeyboardState" /> to set the NUM LOCK, CAPS LOCK, or SCROLL LOCK (or the Japanese KANA) indicator lights
		///     on the keyboard. These can be set or cleared using <see cref="SendInput" /> to simulate keystrokes.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetKeyboardState")]
		public static extern bool SetKeyboardState([MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.I1, SizeConst = 256)] byte[] lpKeyState);

		/// <summary>
		///     Places data on the clipboard in a specified clipboard format. The window must be the current clipboard owner, and the application must have
		///     called the <see cref="OpenClipboard" /> function. (When responding to the <see cref="WM.WM_RENDERFORMAT" /> and
		///     <see cref="WM.WM_RENDERALLFORMATS" />
		///     messages, the clipboard owner must not call <see cref="OpenClipboard" /> before calling <see cref="SetClipboardData" />.)
		/// </summary>
		/// <param name="uFormat">
		///     The clipboard format. This parameter can be a registered format or any of the standard clipboard formats. For more information, see Standard
		///     Clipboard Formats and Registered Clipboard Formats.
		/// </param>
		/// <param name="hMem">
		///     <para>
		///         A handle to the data in the specified format. This parameter can be NULL, indicating that the window provides data in the specified clipboard
		///         format (renders the format) upon request. If a window delays rendering, it must process the <see cref="WM.WM_RENDERFORMAT" /> and
		///         <see cref="WM.WM_RENDERALLFORMATS" /> messages.
		///     </para>
		///     <para>
		///         If <see cref="SetClipboardData" /> succeeds, the system owns the object identified by the <paramref name="hMem" /> parameter. The application
		///         may not write to or free the data once ownership has been transferred to the system, but it can lock and read from the data until the
		///         <see cref="CloseClipboard" /> function is called. (The memory must be unlocked before the Clipboard is closed.) If the
		///         <paramref name="hMem" /> parameter identifies a memory object, the object must have been allocated using the function with the
		///         <see cref="GMEM.GMEM_MOVEABLE" /> flag.
		///     </para>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the handle to the data.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Windows 8: Bitmaps to be shared with Windows Store app apps must be in the <see cref="CF.CF_BITMAP" /> format (device-dependent
		///         bitmap).
		///     </para>
		///     <para>
		///         If an application calls <see cref="SetClipboardData" /> in response to <see cref="WM.WM_RENDERFORMAT" /> or
		///         <see cref="WM.WM_RENDERALLFORMATS" />, the application should not use the handle after <see cref="SetClipboardData" /> has been called.
		///     </para>
		///     <para>
		///         If an application calls <see cref="OpenClipboard" /> with hwnd set to NULL, <see cref="EmptyClipboard" /> sets the clipboard owner to NULL;
		///         this causes <see cref="SetClipboardData" /> to fail.
		///     </para>
		///     <para>
		///         The system performs implicit data format conversions between certain clipboard formats when an application calls the
		///         <see cref="GetClipboardData" /> function. For example, if the <see cref="CF.CF_OEMTEXT" /> format is on the clipboard, a window can retrieve
		///         data in the <see cref="CF.CF_TEXT" /> format. The format on the clipboard is converted to the requested format on demand. For more information,
		///         see Synthesized Clipboard Formats.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetClipboardData")]
		public static extern IntPtr SetClipboardData(CF uFormat, [In] IntPtr hMem);

		/// <summary>
		///     <para>
		///         Registers a window class for subsequent use in calls to the CreateWindow or <see cref="CreateWindowEx" /> function.
		///     </para>
		///     <para>
		///         Note:  The <see cref="RegisterClass" /> function has been superseded by the <see cref="RegisterClassEx" /> function. You can
		///         still use <see cref="RegisterClass" />, however, if you do not need to set the class small icon.
		///     </para>
		/// </summary>
		/// <param name="lpWndClass">
		///     A pointer to a <see cref="WNDCLASS" /> structure. You must fill the structure with the appropriate class attributes before passing it to the
		///     function.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can only be used by
		///         the CreateWindow, <see cref="CreateWindowEx" />, <see cref="GetClassInfo" />, <see cref="GetClassInfoEx" />,
		///         <see cref="FindWindow" />, <see cref="FindWindowEx" />, and <see cref="UnregisterClass" /> functions and the
		///         IActiveIMMap::FilterClientWindows method.
		///     </para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If you register the window class by using RegisterClassA, the application tells the system that the windows of the created
		///         class expect messages with text or character parameters to use the ANSI character set; if you register it by using
		///         RegisterClassW, the application requests that the system pass text parameters of messages as Unicode. The
		///         <see cref="IsWindowUnicode" /> function enables applications to query the nature of each window. For more information on ANSI and Unicode
		///         functions, see Conventions for Function Prototypes.
		///     </para>
		///     <para>All window classes that an application registers are unregistered when it terminates.</para>
		///     <para>
		///         No window classes registered by a DLL are unregistered when the DLL is unloaded. A DLL must explicitly unregister its classes when it is
		///         unloaded.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "RegisterClassEx")]
		public static extern ushort RegisterClassEx([In] ref WNDCLASSEX lpWndClass);

		/// <summary>Opens the desktop that receives user input.</summary>
		/// <param name="dwFlags">
		///     <para>This parameter can be zero or the following value.</para>
		///     <list type="table">
		///         <item>
		///             <term>DF_ALLOWOTHERACCOUNTHOOK 0x0001</term>
		///             <description>Allows processes running in other accounts on the desktop to set hooks in this process.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="fInherit">
		///     If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this
		///     handle.
		/// </param>
		/// <param name="dwDesiredAccess">The access to the desktop. For a list of access rights, see Desktop Security and Access Rights.</param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is a handle to the desktop that receives user input. When you are finished using the handle, call
		///         the <see cref="CloseDesktop" /> function to close it.
		///     </para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The calling process must have an associated window station, either assigned by the system when the process is created, or set by the
		///         <see cref="SetProcessWindowStation" /> function. The window station associated with the calling process must be capable of receiving input.
		///     </para>
		///     <para>
		///         If the calling process is running in a disconnected session, the function returns a handle to the desktop that becomes active when the user
		///         restores the connection.
		///     </para>
		///     <para>
		///         An application can use the <see cref="SwitchDesktop" /> function to change the input desktop.
		///     </para>
		///     <para>
		///         If the <paramref name="dwDesiredAccess" /> parameter specifies the READ_CONTROL, WRITE_DAC, or
		///         WRITE_OWNER standard access rights, you must also request the DESKTOP_READOBJECTS and
		///         DESKTOP_WRITEOBJECTS access rights.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "OpenInputDesktop")]
		public static extern IntPtr OpenInputDesktop(DF dwFlags, [MarshalAs(UnmanagedType.Bool)] bool fInherit, uint dwDesiredAccess);

		/// <summary>
		///     The <see cref="MonitorFromPoint" /> function retrieves a handle to the display monitor that contains a specified point.
		/// </summary>
		/// <param name="pt">
		///     A <see cref="POINT" /> structure that specifies the point of interest in virtual-screen coordinates.
		/// </param>
		/// <param name="dwFlags">
		///     <para>Determines the function's return value if the point is not contained within any display monitor.</para>
		///     <para>This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MONITOR_DEFAULTTONEAREST</term>
		///             <description>Returns a handle to the display monitor that is nearest to the point.</description>
		///         </item>
		///         <item>
		///             <term>MONITOR_DEFAULTTONULL</term>
		///             <description>Returns NULL.</description>
		///         </item>
		///         <item>
		///             <term>MONITOR_DEFAULTTOPRIMARY</term>
		///             <description>Returns a handle to the primary display monitor.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>
		///         If the point is contained by a display monitor, the return value is an HMONITOR handle to that display monitor.
		///     </para>
		///     <para>
		///         If the point is not contained by a display monitor, the return value depends on the value of <paramref name="dwFlags" />.
		///     </para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "MonitorFromPoint")]
		public static extern IntPtr MonitorFromPoint(POINT pt, MONITOR dwFlags);

		/// <summary>
		///     Translates (maps) a virtual-key code into a scan code or character value, or translates a scan code into a virtual-key code. The function
		///     translates the codes using the input language and an input locale identifier.
		/// </summary>
		/// <param name="uCode">
		///     <para>
		///         The virtual-key code or scan code for a key. How this value is interpreted depends on the value of the <paramref name="uMapType" />
		///         parameter.
		///     </para>
		///     <para>
		///         Starting with Windows Vista, the high byte of the <paramref name="uCode" /> value can contain either 0xe0 or 0xe1 to specify the extended
		///         scan code.
		///     </para>
		/// </param>
		/// <param name="uMapType">
		///     <para>
		///         The translation to perform. The value of this parameter depends on the value of the <paramref name="uCode" /> parameter.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MAPVK_VK_TO_CHAR 2</term>
		///             <description>
		///                 The <paramref name="uCode" /> parameter is a virtual-key code and is translated into an unshifted character value in the low order
		///                 word of the return value. Dead keys (diacritics) are indicated by setting the top bit of the return value. If there is no
		///                 translation, the function returns 0.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MAPVK_VK_TO_VSC 0</term>
		///             <description>
		///                 The <paramref name="uCode" /> parameter is a virtual-key code and is translated into a scan code. If it is a virtual-key code that
		///                 does not distinguish between left- and right-hand keys, the left-hand scan code is returned. If there is no translation, the function
		///                 returns 0.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MAPVK_VK_TO_VSC_EX 4</term>
		///             <description>
		///                 The <paramref name="uCode" /> parameter is a virtual-key code and is translated into a scan code. If it is a virtual-key code that
		///                 does not distinguish between left- and right-hand keys, the left-hand scan code is returned. If the scan code is an extended scan
		///                 code, the high byte of the <paramref name="uCode" /> value can contain either 0xe0 or 0xe1 to specify the extended scan code. If
		///                 there is no translation, the function returns 0.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MAPVK_VSC_TO_VK 1</term>
		///             <description>
		///                 The <paramref name="uCode" /> parameter is a scan code and is translated into a virtual-key code that does not distinguish between
		///                 left- and right-hand keys. If there is no translation, the function returns 0.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MAPVK_VSC_TO_VK_EX 3</term>
		///             <description>
		///                 The <paramref name="uCode" /> parameter is a scan code and is translated into a virtual-key code that distinguishes between left- and
		///                 right-hand keys. If there is no translation, the function returns 0.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="dwhkl">
		///     Input locale identifier to use for translating the specified code. This parameter can be any input locale identifier previously returned by the
		///     <see cref="LoadKeyboardLayout" /> function.
		/// </param>
		/// <returns>
		///     The return value is either a scan code, a virtual-key code, or a character value, depending on the value of <paramref name="uCode" /> and
		///     <paramref name="uMapType" />. If there is no translation, the return value is zero.
		/// </returns>
		/// <remarks>
		///     <para>
		///         The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input
		///         Method Editor (IME), or any other form of input.
		///     </para>
		///     <para>
		///         An application can use <see cref="MapVirtualKeyEx" /> to translate scan codes to the virtual-key code constants <see cref="VK.VK_SHIFT" />,
		///         <see cref="VK.VK_CONTROL" />, and <see cref="VK.VK_MENU" />, and vice versa. These translations do not distinguish between the left and right
		///         instances of the SHIFT, CTRL, or ALT keys.
		///     </para>
		///     <para>
		///         An application can get the scan code corresponding to the left or right instance of one of these keys by calling
		///         <see cref="MapVirtualKeyEx" /> with <paramref name="uCode" /> set to one of the following virtual-key code constants.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "MapVirtualKeyEx")]
		public static extern uint MapVirtualKeyEx(uint uCode, uint uMapType, [In] IntPtr dwhkl);

		/// <summary>
		///     The <see cref="LockWindowUpdate" /> function disables or enables drawing in the specified window. Only one window can be locked at a time.
		/// </summary>
		/// <param name="hWndLock">The window in which drawing will be disabled. If this parameter is NULL, drawing in the locked window is enabled.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero, indicating that an error occurred or another window was already locked.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The purpose of the <see cref="LockWindowUpdate" /> function is to permit drag/drop feedback to be drawn over a window without interference
		///         from the window itself. The intent is that the window is locked when feedback is drawn and unlocked when feedback is complete.
		///         <see cref="LockWindowUpdate" /> is not intended for general-purpose suppression of window redraw. Use the <see cref="WM.WM_SETREDRAW" />
		///         message to disable redrawing of a particular window.
		///     </para>
		///     <para>
		///         If an application with a locked window (or any locked child windows) calls the <see cref="GetDC" />, <see cref="GetDCEx" />, or
		///         <see cref="BeginPaint" /> function, the called function returns a device context with a visible region that is empty. This will occur until
		///         the application unlocks the window by calling <see cref="LockWindowUpdate" />, specifying a value of NULL for <paramref name="hWndLock" />.
		///     </para>
		///     <para>
		///         If an application attempts to draw within a locked window, the system records the extent of the attempted operation in a bounding rectangle.
		///         When the window is unlocked, the system invalidates the area within this bounding rectangle, forcing an eventual <see cref="WM.WM_PAINT" />
		///         message to be sent to the previously locked window and its child windows. If no drawing has occurred while the window updates were locked, no
		///         area is invalidated.
		///     </para>
		///     <para>
		///         <see cref="LockWindowUpdate" /> does not make the specified window invisible and does not clear the WS_VISIBLE style bit.
		///     </para>
		///     <para>A locked window cannot be moved.</para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "LockWindowUpdate")]
		public static extern bool LockWindowUpdate([In] IntPtr hWndLock);

		/// <summary>Determines whether a message is intended for the specified dialog box and, if it is, processes the message.</summary>
		/// <param name="hDlg">A handle to the dialog box.</param>
		/// <param name="lpMsg">
		///     A pointer to an <see cref="MSG" /> structure that contains the message to be checked.
		/// </param>
		/// <returns>
		///     <para>If the message has been processed, the return value is nonzero.</para>
		///     <para>If the message has not been processed, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Although the <see cref="IsDialogMessage" /> function is intended for modeless dialog boxes, you can use it with any window that contains
		///         controls, enabling the windows to provide the same keyboard selection as is used in a dialog box.
		///     </para>
		///     <para>
		///         When <see cref="IsDialogMessage" /> processes a message, it checks for keyboard messages and converts them into selections for the
		///         corresponding dialog box. For example, the TAB key, when pressed, selects the next control or group of controls, and the DOWN ARROW key, when
		///         pressed, selects the next control in a group.
		///     </para>
		///     <para>
		///         Because the <see cref="IsDialogMessage" /> function performs all necessary translating and dispatching of messages, a message processed by
		///         <see cref="IsDialogMessage" /> must not be passed to the <see cref="TranslateMessage" /> or <see cref="DispatchMessage" /> function.
		///     </para>
		///     <para>
		///         <see cref="IsDialogMessage" /> sends <see cref="WM.WM_GETDLGCODE" /> messages to the dialog box procedure to determine which keys should be
		///         processed.
		///     </para>
		///     <para>
		///         <see cref="IsDialogMessage" /> can send DM_GETDEFID and DM_SETDEFID messages to the window. These messages are
		///         defined in the Winuser.h header file as <see cref="WM.WM_USER" /> and <see cref="WM.WM_USER" /> + 1, so conflicts are possible with
		///         application-defined messages having the same values.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "IsDialogMessage")]
		public static extern bool IsDialogMessage([In] IntPtr hDlg, [In] ref MSG lpMsg);

		/// <summary>Retrieves a handle to the desktop assigned to the specified thread.</summary>
		/// <param name="dwThreadId">
		///     The thread identifier. The GetCurrentThreadId and CreateProcess functions return thread identifiers.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is a handle to the desktop associated with the specified thread. You do not need to call the
		///         <see cref="CloseDesktop" /> function to close the returned handle.
		///     </para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The system associates a desktop with a thread when that thread is created. A thread can use the <see cref="SetThreadDesktop" /> function to
		///         change its desktop. The desktop associated with a thread must be on the window station associated with the thread's process.
		///     </para>
		///     <para>
		///         The calling process can use the returned handle in calls to the <see cref="GetUserObjectInformation" />, <see cref="GetUserObjectSecurity" />
		///         , <see cref="SetUserObjectInformation" />, and <see cref="SetUserObjectSecurity" /> functions.
		///     </para>
		///     <para>
		///         A service application is created with an associated window station and desktop, so there is no need to call a USER or GDI function to connect
		///         the service to a window station and desktop.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetThreadDesktop")]
		public static extern IntPtr GetThreadDesktop(uint dwThreadId);

		/// <summary>
		///     <para>Retrieves the specified system metric or system configuration setting.</para>
		///     <para>
		///         Note that all dimensions retrieved by <see cref="GetSystemMetrics" /> are in pixels.
		///     </para>
		/// </summary>
		/// <param name="nIndex">
		///     <para>
		///         The system metric or configuration setting to be retrieved. This parameter can be one of the following values. Note that all SM_CX* values
		///         are widths and all SM_CY* values are heights. Also note that all settings designed to return Boolean data represent TRUE as any nonzero
		///         value, and FALSE as a zero value.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>SM_ARRANGE 56</term>
		///             <description>
		///                 The flags that specify how the system arranged minimized windows. For more information, see the Remarks section in this
		///                 topic.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CLEANBOOT 67</term>
		///             <description>
		///                 <para>The value that specifies how the system is started:</para>
		///                 <para>A fail-safe boot (also called SafeBoot, Safe Mode, or Clean Boot) bypasses the user startup files.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CMONITORS 80</term>
		///             <description>The number of display monitors on a desktop. For more information, see the Remarks section in this topic.</description>
		///         </item>
		///         <item>
		///             <term>SM_CMOUSEBUTTONS 43</term>
		///             <description>The number of buttons on a mouse, or zero if no mouse is installed.</description>
		///         </item>
		///         <item>
		///             <term>SM_CXBORDER 5</term>
		///             <description>The width of a window border, in pixels. This is equivalent to the SM_CXEDGE value for windows with the 3-D look.</description>
		///         </item>
		///         <item>
		///             <term>SM_CXCURSOR 13</term>
		///             <description>The width of a cursor, in pixels. The system cannot create cursors of other sizes.</description>
		///         </item>
		///         <item>
		///             <term>SM_CXDLGFRAME 7</term>
		///             <description>This value is the same as SM_CXFIXEDFRAME.</description>
		///         </item>
		///         <item>
		///             <term>SM_CXDOUBLECLK 36</term>
		///             <description>
		///                 <para>
		///                     The width of the rectangle around the location of a first click in a double-click sequence, in pixels. The second click must
		///                     occur within the rectangle that is defined by SM_CXDOUBLECLK and SM_CYDOUBLECLK for the system to consider the two clicks a
		///                     double-click. The two clicks must also occur within a specified time.
		///                 </para>
		///                 <para>
		///                     To set the width of the double-click rectangle, call <see cref="SystemParametersInfo" /> with SPI_SETDOUBLECLKWIDTH.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CXDRAG 68</term>
		///             <description>
		///                 The number of pixels on either side of a mouse-down point that the mouse pointer can move before a drag operation begins. This allows
		///                 the user to click and release the mouse button easily without unintentionally starting a drag operation. If this value is negative,
		///                 it is subtracted from the left of the mouse-down point and added to the right of it.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CXEDGE 45</term>
		///             <description>The width of a 3-D border, in pixels. This metric is the 3-D counterpart of SM_CXBORDER.</description>
		///         </item>
		///         <item>
		///             <term>SM_CXFIXEDFRAME 7</term>
		///             <description>
		///                 <para>
		///                     The thickness of the frame around the perimeter of a window that has a caption but is not sizable, in pixels. SM_CXFIXEDFRAME is
		///                     the height of the horizontal border, and SM_CYFIXEDFRAME is the width of the vertical border.
		///                 </para>
		///                 <para>This value is the same as SM_CXDLGFRAME.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CXFOCUSBORDER 83</term>
		///             <description>
		///                 <para>
		///                     The width of the left and right edges of the focus rectangle that the <see cref="DrawFocusRect" /> draws. This value is in
		///                     pixels.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CXFRAME 32</term>
		///             <description>This value is the same as SM_CXSIZEFRAME.</description>
		///         </item>
		///         <item>
		///             <term>SM_CXFULLSCREEN 16</term>
		///             <description>
		///                 The width of the client area for a full-screen window on the primary display monitor, in pixels. To get the coordinates of the
		///                 portion of the screen that is not obscured by the system taskbar or by application desktop toolbars, call the
		///                 <see cref="SystemParametersInfo" /> function with the SPI_GETWORKAREA value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CXHSCROLL 21</term>
		///             <description>The width of the arrow bitmap on a horizontal scroll bar, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_CXHTHUMB 10</term>
		///             <description>The width of the thumb box in a horizontal scroll bar, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_CXICON 11</term>
		///             <description>
		///                 The default width of an icon, in pixels. The <see cref="LoadIcon" /> function can load only icons with the dimensions that SM_CXICON
		///                 and SM_CYICON specifies.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CXICONSPACING 38</term>
		///             <description>
		///                 The width of a grid cell for items in large icon view, in pixels. Each item fits into a rectangle of size SM_CXICONSPACING by
		///                 SM_CYICONSPACING when arranged. This value is always greater than or equal to SM_CXICON.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CXMAXIMIZED 61</term>
		///             <description>The default width, in pixels, of a maximized top-level window on the primary display monitor.</description>
		///         </item>
		///         <item>
		///             <term>SM_CXMAXTRACK 59</term>
		///             <description>
		///                 The default maximum width of a window that has a caption and sizing borders, in pixels. This metric refers to the entire desktop. The
		///                 user cannot drag the window frame to a size larger than these dimensions. A window can override this value by processing the
		///                 <see cref="WM.WM_GETMINMAXINFO" /> message.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CXMENUCHECK 71</term>
		///             <description>The width of the default menu check-mark bitmap, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_CXMENUSIZE 54</term>
		///             <description>
		///                 The width of menu bar buttons, such as the child window close button that is used in the multiple document interface, in
		///                 pixels.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CXMIN 28</term>
		///             <description>The minimum width of a window, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_CXMINIMIZED 57</term>
		///             <description>The width of a minimized window, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_CXMINSPACING 47</term>
		///             <description>
		///                 The width of a grid cell for a minimized window, in pixels. Each minimized window fits into a rectangle this size when arranged. This
		///                 value is always greater than or equal to SM_CXMINIMIZED.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CXMINTRACK 34</term>
		///             <description>
		///                 The minimum tracking width of a window, in pixels. The user cannot drag the window frame to a size smaller than these dimensions. A
		///                 window can override this value by processing the <see cref="WM.WM_GETMINMAXINFO" /> message.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CXPADDEDBORDER 92</term>
		///             <description>
		///                 <para>The amount of border padding for captioned windows, in pixels.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CXSCREEN 0</term>
		///             <description>
		///                 The width of the screen of the primary display monitor, in pixels. This is the same value obtained by calling
		///                 GetDeviceCaps as follows: GetDeviceCaps( hdcPrimaryMonitor, HORZRES).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CXSIZE 30</term>
		///             <description>The width of a button in a window caption or title bar, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_CXSIZEFRAME 32</term>
		///             <description>
		///                 <para>
		///                     The thickness of the sizing border around the perimeter of a window that can be resized, in pixels. SM_CXSIZEFRAME is the width
		///                     of the horizontal border, and SM_CYSIZEFRAME is the height of the vertical border.
		///                 </para>
		///                 <para>This value is the same as SM_CXFRAME.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CXSMICON 49</term>
		///             <description>The recommended width of a small icon, in pixels. Small icons typically appear in window captions and in small icon view.</description>
		///         </item>
		///         <item>
		///             <term>SM_CXSMSIZE 52</term>
		///             <description>The width of small caption buttons, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_CXVIRTUALSCREEN 78</term>
		///             <description>
		///                 The width of the virtual screen, in pixels. The virtual screen is the bounding rectangle of all display monitors. The
		///                 SM_XVIRTUALSCREEN metric is the coordinates for the left side of the virtual screen.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CXVSCROLL 2</term>
		///             <description>The width of a vertical scroll bar, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_CYBORDER 6</term>
		///             <description>The height of a window border, in pixels. This is equivalent to the SM_CYEDGE value for windows with the 3-D look.</description>
		///         </item>
		///         <item>
		///             <term>SM_CYCAPTION 4</term>
		///             <description>The height of a caption area, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_CYCURSOR 14</term>
		///             <description>The height of a cursor, in pixels. The system cannot create cursors of other sizes.</description>
		///         </item>
		///         <item>
		///             <term>SM_CYDLGFRAME 8</term>
		///             <description>This value is the same as SM_CYFIXEDFRAME.</description>
		///         </item>
		///         <item>
		///             <term>SM_CYDOUBLECLK 37</term>
		///             <description>
		///                 <para>
		///                     The height of the rectangle around the location of a first click in a double-click sequence, in pixels. The second click must
		///                     occur within the rectangle defined by SM_CXDOUBLECLK and SM_CYDOUBLECLK for the system to consider the two clicks a double-click.
		///                     The two clicks must also occur within a specified time.
		///                 </para>
		///                 <para>
		///                     To set the height of the double-click rectangle, call <see cref="SystemParametersInfo" /> with SPI_SETDOUBLECLKHEIGHT.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CYDRAG 69</term>
		///             <description>
		///                 The number of pixels above and below a mouse-down point that the mouse pointer can move before a drag operation begins. This allows
		///                 the user to click and release the mouse button easily without unintentionally starting a drag operation. If this value is negative,
		///                 it is subtracted from above the mouse-down point and added below it.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CYEDGE 46</term>
		///             <description>The height of a 3-D border, in pixels. This is the 3-D counterpart of SM_CYBORDER.</description>
		///         </item>
		///         <item>
		///             <term>SM_CYFIXEDFRAME 8</term>
		///             <description>
		///                 <para>
		///                     The thickness of the frame around the perimeter of a window that has a caption but is not sizable, in pixels. SM_CXFIXEDFRAME is
		///                     the height of the horizontal border, and SM_CYFIXEDFRAME is the width of the vertical border.
		///                 </para>
		///                 <para>This value is the same as SM_CYDLGFRAME.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CYFOCUSBORDER 84</term>
		///             <description>
		///                 <para>
		///                     The height of the top and bottom edges of the focus rectangle drawn by <see cref="DrawFocusRect" />. This value is in pixels.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CYFRAME 33</term>
		///             <description>This value is the same as SM_CYSIZEFRAME.</description>
		///         </item>
		///         <item>
		///             <term>SM_CYFULLSCREEN 17</term>
		///             <description>
		///                 The height of the client area for a full-screen window on the primary display monitor, in pixels. To get the coordinates of the
		///                 portion of the screen not obscured by the system taskbar or by application desktop toolbars, call the
		///                 <see cref="SystemParametersInfo" /> function with the SPI_GETWORKAREA value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CYHSCROLL 3</term>
		///             <description>The height of a horizontal scroll bar, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_CYICON 12</term>
		///             <description>
		///                 The default height of an icon, in pixels. The <see cref="LoadIcon" /> function can load only icons with the dimensions SM_CXICON and
		///                 SM_CYICON.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CYICONSPACING 39</term>
		///             <description>
		///                 The height of a grid cell for items in large icon view, in pixels. Each item fits into a rectangle of size SM_CXICONSPACING by
		///                 SM_CYICONSPACING when arranged. This value is always greater than or equal to SM_CYICON.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CYKANJIWINDOW 18</term>
		///             <description>
		///                 For double byte character set versions of the system, this is the height of the Kanji window at the bottom of the screen, in
		///                 pixels.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CYMAXIMIZED 62</term>
		///             <description>The default height, in pixels, of a maximized top-level window on the primary display monitor.</description>
		///         </item>
		///         <item>
		///             <term>SM_CYMAXTRACK 60</term>
		///             <description>
		///                 The default maximum height of a window that has a caption and sizing borders, in pixels. This metric refers to the entire desktop.
		///                 The user cannot drag the window frame to a size larger than these dimensions. A window can override this value by processing the
		///                 <see cref="WM.WM_GETMINMAXINFO" /> message.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CYMENU 15</term>
		///             <description>The height of a single-line menu bar, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_CYMENUCHECK 72</term>
		///             <description>The height of the default menu check-mark bitmap, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_CYMENUSIZE 55</term>
		///             <description>
		///                 The height of menu bar buttons, such as the child window close button that is used in the multiple document interface, in
		///                 pixels.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CYMIN 29</term>
		///             <description>The minimum height of a window, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_CYMINIMIZED 58</term>
		///             <description>The height of a minimized window, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_CYMINSPACING 48</term>
		///             <description>
		///                 The height of a grid cell for a minimized window, in pixels. Each minimized window fits into a rectangle this size when arranged.
		///                 This value is always greater than or equal to SM_CYMINIMIZED.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CYMINTRACK 35</term>
		///             <description>
		///                 The minimum tracking height of a window, in pixels. The user cannot drag the window frame to a size smaller than these dimensions. A
		///                 window can override this value by processing the <see cref="WM.WM_GETMINMAXINFO" /> message.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CYSCREEN 1</term>
		///             <description>
		///                 The height of the screen of the primary display monitor, in pixels. This is the same value obtained by calling
		///                 GetDeviceCap as follows: GetDeviceCaps( hdcPrimaryMonitor, VERTRES).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CYSIZE 31</term>
		///             <description>The height of a button in a window caption or title bar, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_CYSIZEFRAME 33</term>
		///             <description>
		///                 <para>
		///                     The thickness of the sizing border around the perimeter of a window that can be resized, in pixels. SM_CXSIZEFRAME is the width
		///                     of the horizontal border, and SM_CYSIZEFRAME is the height of the vertical border.
		///                 </para>
		///                 <para>This value is the same as SM_CYFRAME.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CYSMCAPTION 51</term>
		///             <description>The height of a small caption, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_CYSMICON 50</term>
		///             <description>The recommended height of a small icon, in pixels. Small icons typically appear in window captions and in small icon view.</description>
		///         </item>
		///         <item>
		///             <term>SM_CYSMSIZE 53</term>
		///             <description>The height of small caption buttons, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_CYVIRTUALSCREEN 79</term>
		///             <description>
		///                 The height of the virtual screen, in pixels. The virtual screen is the bounding rectangle of all display monitors. The
		///                 SM_YVIRTUALSCREEN metric is the coordinates for the top of the virtual screen.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_CYVSCROLL 20</term>
		///             <description>The height of the arrow bitmap on a vertical scroll bar, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_CYVTHUMB 9</term>
		///             <description>The height of the thumb box in a vertical scroll bar, in pixels.</description>
		///         </item>
		///         <item>
		///             <term>SM_DBCSENABLED 42</term>
		///             <description>Nonzero if User32.dll supports DBCS; otherwise, 0.</description>
		///         </item>
		///         <item>
		///             <term>SM_DEBUG 22</term>
		///             <description>Nonzero if the debug version of User.exe is installed; otherwise, 0.</description>
		///         </item>
		///         <item>
		///             <term>SM_DIGITIZER 94</term>
		///             <description>
		///                 <para>
		///                     Nonzero if the current operating system is Windows 7 or Windows Server 2008 R2 and the Tablet PC Input service is started;
		///                     otherwise, 0. The return value is a bitmask that specifies the type of digitizer input supported by the device. For more
		///                     information, see Remarks.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_IMMENABLED 82</term>
		///             <description>
		///                 <para>Nonzero if Input Method Manager/Input Method Editor features are enabled; otherwise, 0.</para>
		///                 <para>
		///                     SM_IMMENABLED indicates whether the system is ready to use a Unicode-based IME on a Unicode application. To ensure that a
		///                     language-dependent IME works, check SM_DBCSENABLED and the system ANSI code page. Otherwise the ANSI-to-Unicode conversion may
		///                     not be performed correctly, or some components like fonts or registry settings may not be present.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_MAXIMUMTOUCHES 95</term>
		///             <description>
		///                 <para>Nonzero if there are digitizers in the system; otherwise, 0.</para>
		///                 <para>
		///                     SM_MAXIMUMTOUCHES returns the aggregate maximum of the maximum number of contacts supported by every digitizer in the system. If
		///                     the system has only single-touch digitizers, the return value is 1. If the system has multi-touch digitizers, the return value is
		///                     the number of simultaneous contacts the hardware can provide.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_MEDIACENTER 87</term>
		///             <description>Nonzero if the current operating system is the Windows XP, Media Center Edition, 0 if not.</description>
		///         </item>
		///         <item>
		///             <term>SM_MENUDROPALIGNMENT 40</term>
		///             <description>Nonzero if drop-down menus are right-aligned with the corresponding menu-bar item; 0 if the menus are left-aligned.</description>
		///         </item>
		///         <item>
		///             <term>SM_MIDEASTENABLED 74</term>
		///             <description>Nonzero if the system is enabled for Hebrew and Arabic languages, 0 if not.</description>
		///         </item>
		///         <item>
		///             <term>SM_MOUSEPRESENT 19</term>
		///             <description>
		///                 Nonzero if a mouse is installed; otherwise, 0. This value is rarely zero, because of support for virtual mice and because some
		///                 systems detect the presence of the port instead of the presence of a mouse.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_MOUSEHORIZONTALWHEELPRESENT 91</term>
		///             <description>Nonzero if a mouse with a horizontal scroll wheel is installed; otherwise 0.</description>
		///         </item>
		///         <item>
		///             <term>SM_MOUSEWHEELPRESENT 75</term>
		///             <description>Nonzero if a mouse with a vertical scroll wheel is installed; otherwise 0.</description>
		///         </item>
		///         <item>
		///             <term>SM_NETWORK 63</term>
		///             <description>
		///                 The least significant bit is set if a network is present; otherwise, it is cleared. The other bits are reserved for future
		///                 use.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_PENWINDOWS 41</term>
		///             <description>Nonzero if the Microsoft Windows for Pen computing extensions are installed; zero otherwise.</description>
		///         </item>
		///         <item>
		///             <term>SM_REMOTECONTROL 0x2001</term>
		///             <description>
		///                 <para>
		///                     This system metric is used in a Terminal Services environment to determine if the current Terminal Server session is being
		///                     remotely controlled. Its value is nonzero if the current session is remotely controlled; otherwise, 0.
		///                 </para>
		///                 <para>
		///                     You can use terminal services management tools such as Terminal Services Manager (tsadmin.msc) and shadow.exe to control a remote
		///                     session. When a session is being remotely controlled, another user can view the contents of that session and potentially interact
		///                     with it.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_REMOTESESSION 0x1000</term>
		///             <description>
		///                 <para>
		///                     This system metric is used in a Terminal Services environment. If the calling process is associated with a Terminal Services
		///                     client session, the return value is nonzero. If the calling process is associated with the Terminal Services console session, the
		///                     return value is 0.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_SAMEDISPLAYFORMAT 81</term>
		///             <description>
		///                 Nonzero if all the display monitors have the same color format, otherwise, 0. Two displays can have the same bit depth, but different
		///                 color formats. For example, the red, green, and blue pixels can be encoded with different numbers of bits, or those bits can be
		///                 located in different places in a pixel color value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_SECURE 44</term>
		///             <description>This system metric should be ignored; it always returns 0.</description>
		///         </item>
		///         <item>
		///             <term>SM_SERVERR2 89</term>
		///             <description>The build number if the system is Windows Server 2003 R2; otherwise, 0.</description>
		///         </item>
		///         <item>
		///             <term>SM_SHOWSOUNDS 70</term>
		///             <description>
		///                 Nonzero if the user requires an application to present information visually in situations where it would otherwise present the
		///                 information only in audible form; otherwise, 0.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_SHUTTINGDOWN 0x2000</term>
		///             <description>
		///                 <para>Nonzero if the current session is shutting down; otherwise, 0.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_SLOWMACHINE 73</term>
		///             <description>Nonzero if the computer has a low-end (slow) processor; otherwise, 0.</description>
		///         </item>
		///         <item>
		///             <term>SM_STARTER 88</term>
		///             <description>
		///                 Nonzero if the current operating system is Windows 7 Starter Edition, Windows Vista Starter, or Windows XP Starter Edition;
		///                 otherwise, 0.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_SWAPBUTTON 23</term>
		///             <description>Nonzero if the meanings of the left and right mouse buttons are swapped; otherwise, 0.</description>
		///         </item>
		///         <item>
		///             <term>SM_TABLETPC 86</term>
		///             <description>
		///                 Nonzero if the current operating system is the Windows XP Tablet PC edition or if the current operating system is Windows Vista or
		///                 Windows 7 and the Tablet PC Input service is started; otherwise, 0. The SM_DIGITIZER setting indicates the type of digitizer input
		///                 supported by a device running Windows 7 or Windows Server 2008 R2. For more information, see Remarks.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_XVIRTUALSCREEN 76</term>
		///             <description>
		///                 The coordinates for the left side of the virtual screen. The virtual screen is the bounding rectangle of all display monitors. The
		///                 SM_CXVIRTUALSCREEN metric is the width of the virtual screen.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SM_YVIRTUALSCREEN 77</term>
		///             <description>
		///                 The coordinates for the top of the virtual screen. The virtual screen is the bounding rectangle of all display monitors. The
		///                 SM_CYVIRTUALSCREEN metric is the height of the virtual screen.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the requested system metric or configuration setting.</para>
		///     <para>If the function fails, the return value is 0. GetLastError does not provide extended error information.</para>
		/// </returns>
		/// <remarks>
		///     <para>System metrics can vary from display to display.</para>
		///     <para>
		///         <see cref="GetSystemMetrics" />(SM_CMONITORS) counts only visible display monitors. This is different from <see cref="EnumDisplayMonitors" />
		///         , which enumerates both visible display monitors and invisible pseudo-monitors that are associated with mirroring drivers. An invisible
		///         pseudo-monitor is associated with a pseudo-device used to mirror application drawing for remoting or other purposes.
		///     </para>
		///     <para>
		///         The SM_ARRANGE setting specifies how the system arranges minimized windows, and consists of a starting position and a direction. The starting
		///         position can be one of the following values.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetSystemMetrics")]
		public static extern int GetSystemMetrics(int nIndex);

		/// <summary>
		///     The <see cref="GetSysColorBrush" /> function retrieves a handle identifying a logical brush that corresponds to the specified color index.
		/// </summary>
		/// <param name="nIndex">
		///     A color index. This value corresponds to the color used to paint one of the window elements. See <see cref="GetSysColor" /> for system color
		///     index values.
		/// </param>
		/// <returns>
		///     The return value identifies a logical brush if the <paramref name="nIndex" /> parameter is supported by the current platform. Otherwise, it
		///     returns NULL.
		/// </returns>
		/// <remarks>
		///     <para>
		///         A brush is a bitmap that the system uses to paint the interiors of filled shapes. An application can retrieve the current system colors by
		///         calling the <see cref="GetSysColor" /> function. An application can set the current system colors by calling the <see cref="SetSysColors" />
		///         function.
		///     </para>
		///     <para>
		///         An application must not register a window class for a window using a system brush. To register a window class with a system color, see the
		///         documentation of the <see cref="WNDCLASS.hbrBackground" /> member of the <see cref="WNDCLASS" /> or <see cref="WNDCLASSEX" /> structures.
		///     </para>
		///     <para>
		///         System color brushes track changes in system colors. In other words, when the user changes a system color, the associated system color brush
		///         automatically changes to the new color.
		///     </para>
		///     <para>
		///         To paint with a system color brush, an application should use <see cref="GetSysColorBrush" /> (nIndex) instead of
		///         CreateSolidBrush( <see cref="GetSysColor" /> (nIndex)), because <see cref="GetSysColorBrush" /> returns a cached brush
		///         instead of allocating a new one.
		///     </para>
		///     <para>
		///         System color brushes are owned by the system so you don't need to destroy them. Although you don't need to delete the logical brush that
		///         <see cref="GetSysColorBrush" /> returns, no harm occurs by calling DeleteObject.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetSysColorBrush")]
		public static extern IntPtr GetSysColorBrush(int nIndex);

		/// <summary>
		///     The <see cref="GetScrollBarInfo" /> function retrieves information about the specified scroll bar.
		/// </summary>
		/// <param name="hwnd">
		///     Handle to a window associated with the scroll bar whose information is to be retrieved. If the <paramref name="idObject" /> parameter is
		///     OBJID_CLIENT, <paramref name="hwnd" /> is a handle to a scroll bar control. Otherwise, <paramref name="hwnd" /> is a handle to a window created
		///     with <see cref="WS.WS_VSCROLL" /> and/or <see cref="WS.WS_HSCROLL" /> style.
		/// </param>
		/// <param name="idObject">
		///     <para>Specifies the scroll bar object. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>OBJID_CLIENT</term>
		///             <description>
		///                 The <paramref name="hwnd" /> parameter is a handle to a scroll bar control.
		///             </description>
		///         </item>
		///         <item>
		///             <term>OBJID_HSCROLL</term>
		///             <description>
		///                 The horizontal scroll bar of the <paramref name="hwnd" /> window.
		///             </description>
		///         </item>
		///         <item>
		///             <term>OBJID_VSCROLL</term>
		///             <description>
		///                 The vertical scroll bar of the <paramref name="hwnd" /> window.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="psbi">
		///     Pointer to a <see cref="SCROLLBARINFO" /> structure to receive the information. Before calling <see cref="GetScrollBarInfo" />, set the
		///     <see cref="SCROLLBARINFO.cbSize" /> member to sizeof(<see cref="SCROLLBARINFO" />).
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     If <paramref name="idObject" /> is OBJID_CLIENT and the window specified by <paramref name="hwnd" /> is not a system scroll bar control, the
		///     system sends the SBM_GETSCROLLBARINFO message to the window to obtain scroll bar information. This allows
		///     <see cref="GetScrollBarInfo" /> to operate on a custom control that mimics a scroll bar. If the window does not handle the
		///     SBM_GETSCROLLBARINFO message, the <see cref="GetScrollBarInfo" /> function fails.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetScrollBarInfo")]
		public static extern bool GetScrollBarInfo([In] IntPtr hwnd, int idObject, ref SCROLLBARINFO psbi);

		/// <summary>Retrieves information about a menu item.</summary>
		/// <param name="hMenu">A handle to the menu that contains the menu item.</param>
		/// <param name="uItem">
		///     The identifier or position of the menu item to get information about. The meaning of this parameter depends on the value of
		///     <paramref name="fByPosition" />.
		/// </param>
		/// <param name="fByPosition">
		///     The meaning of <paramref name="uItem" />. If this parameter is FALSE, <paramref name="uItem" /> is a menu item identifier. Otherwise, it is a
		///     menu item position. See Accessing Menu Items Programmatically for more information.
		/// </param>
		/// <param name="lpmii">
		///     A pointer to a <see cref="MENUITEMINFO" /> structure that specifies the information to retrieve and receives information about the menu item.
		///     Note that you must set the <see cref="MENUITEMINFO.cbSize" /> member to sizeof(MENUITEMINFO) before calling this function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         To retrieve a menu item of type MFT_STRING, first find the size of the string by setting the <see cref="MENUITEMINFO.dwTypeData" /> member
		///         of <see cref="MENUITEMINFO" /> to NULL and then calling <see cref="GetMenuItemInfo" />. The value of <see cref="MENUITEMINFO.cch" />+1 is the size needed.
		///         Then allocate a buffer of this size, place the pointer to the buffer in <see cref="MENUITEMINFO.dwTypeData" />, increment <see cref="MENUITEMINFO.cch" /> by one, and
		///         then call <see cref="GetMenuItemInfo" /> once again to fill the buffer with the string.
		///     </para>
		///     <para>
		///         If the retrieved menu item is of some other type, then <see cref="GetMenuItemInfo" /> sets the <see cref="MENUITEMINFO.dwTypeData" /> member to a value
		///         whose type is specified by the <see cref="MENUITEMINFO.fType" /><see cref="MENUITEMINFO.fType" /> member and sets <see cref="MENUITEMINFO.cch" /> to 0.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetMenuItemInfo")]
		public static extern bool GetMenuItemInfo([In] IntPtr hMenu, uint uItem, [MarshalAs(UnmanagedType.Bool)] bool fByPosition, ref MENUITEMINFO lpmii);

		/// <summary>Determines the number of items in the specified menu.</summary>
		/// <param name="hMenu">A handle to the menu to be examined.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value specifies the number of items in the menu.</para>
		///     <para>If the function fails, the return value is -1. To get extended error information, call GetLastError.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetMenuItemCount")]
		public static extern int GetMenuItemCount([In] IntPtr hMenu);

		/// <summary>Retrieves the time of the last input event.</summary>
		/// <param name="plii">
		///     A pointer to a <see cref="LASTINPUTINFO" /> structure that receives the time of the last input event.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         This function is useful for input idle detection. However, <see cref="GetLastInputInfo" /> does not provide system-wide user input
		///         information across all running sessions. Rather, <see cref="GetLastInputInfo" /> provides session-specific user input information for only
		///         the session that invoked the function.
		///     </para>
		///     <para>
		///         The tick count when the last input event was received (see <see cref="LASTINPUTINFO" />) is not guaranteed to be incremental. In some cases,
		///         the value might be less than the tick count of a prior event. For example, this can be caused by a timing gap between the raw input thread
		///         and the desktop thread or an event raised by <see cref="SendInput" />, which supplies its own tick count.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetLastInputInfo")]
		public static extern bool GetLastInputInfo([Out] out LASTINPUTINFO plii);

		/// <summary>Copies the status of the 256 virtual keys to the specified buffer.</summary>
		/// <param name="lpKeyState">The 256-byte array that receives the status data for each virtual key.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         An application can call this function to retrieve the current status of all the virtual keys. The status changes as a thread removes keyboard
		///         messages from its message queue. The status does not change as keyboard messages are posted to the thread's message queue, nor does it change
		///         as keyboard messages are posted to or retrieved from message queues of other threads. (Exception: Threads that are connected through
		///         <see cref="AttachThreadInput" /> share the same keyboard state.)
		///     </para>
		///     <para>
		///         When the function returns, each member of the array pointed to by the <paramref name="lpKeyState" /> parameter contains status data for a
		///         virtual key. If the high-order bit is 1, the key is down; otherwise, it is up. If the key is a toggle key, for example CAPS LOCK, then the
		///         low-order bit is 1 when the key is toggled and is 0 if the key is untoggled. The low-order bit is meaningless for non-toggle keys. A toggle
		///         key is said to be toggled when it is turned on. A toggle key's indicator light (if any) on the keyboard will be on when the key is toggled,
		///         and off when the key is untoggled.
		///     </para>
		///     <para>
		///         To retrieve status information for an individual key, use the <see cref="GetKeyState" /> function. To retrieve the current state for an
		///         individual key regardless of whether the corresponding keyboard message has been retrieved from the message queue, use the
		///         <see cref="GetAsyncKeyState" /> function.
		///     </para>
		///     <para>
		///         An application can use the virtual-key code constants <see cref="VK.VK_SHIFT" />, <see cref="VK.VK_CONTROL" /> and <see cref="VK.VK_MENU" /> as
		///         indices into the array pointed to by <paramref name="lpKeyState" />. This gives the status of the SHIFT, CTRL, or ALT keys without
		///         distinguishing between left and right. An application can also use the following virtual-key code constants as indices to distinguish between
		///         the left and right instances of those keys:
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetKeyboardState")]
		public static extern bool GetKeyboardState(IntPtr lpKeyState);

		/// <summary>Retrieves information about the active window or a specified GUI thread.</summary>
		/// <param name="idThread">
		///     The identifier for the thread for which information is to be retrieved. To retrieve this value, use the <see cref="GetWindowThreadProcessId" />
		///     function. If this parameter is NULL, the function returns information for the foreground thread.
		/// </param>
		/// <param name="lpgui">
		///     A pointer to a <see cref="GUITHREADINFO" /> structure that receives information describing the thread. Note that you must set the
		///     <see cref="GUITHREADINFO.cbSize" /> member to sizeof(GUITHREADINFO) before calling this function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         This function succeeds even if the active window is not owned by the calling process. If the specified thread does not exist or have an input
		///         queue, the function will fail.
		///     </para>
		///     <para>
		///         This function is useful for retrieving out-of-context information about a thread. The information retrieved is the same as if an application
		///         retrieved the information about itself.
		///     </para>
		///     <para>
		///         For an edit control, the returned rcCaret rectangle contains the caret plus information on text direction and padding. Thus,
		///         it may not give the correct position of the cursor. The Sans Serif font uses four characters for the cursor:
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetGUIThreadInfo")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool GetGUIThreadInfo(uint idThread, ref GUITHREADINFO lpgui);

		/// <summary>
		///     Retrieves a handle to the desktop window. The desktop window covers the entire screen. The desktop window is the area on top of which other
		///     windows are painted.
		/// </summary>
		/// <returns>
		///     <para>The return value is a handle to the desktop window.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetDesktopWindow")]
		public static extern IntPtr GetDesktopWindow();

		/// <summary>Retrieves data from the clipboard in a specified format. The clipboard must have been opened previously.</summary>
		/// <param name="uFormat">A clipboard format. For a description of the standard clipboard formats, see Standard Clipboard Formats.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the handle to a clipboard object in the specified format.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Caution:  Clipboard data is not trusted. Parse the data carefully before using it in your application.
		///     </para>
		///     <para>
		///         An application can enumerate the available formats in advance by using the <see cref="EnumClipboardFormats" /> function.
		///     </para>
		///     <para>
		///         The clipboard controls the handle that the <see cref="GetClipboardData" /> function returns, not the application. The application should copy
		///         the data immediately. The application must not free the handle nor leave it locked. The application must not use the handle after the
		///         <see cref="EmptyClipboard" /> or <see cref="CloseClipboard" /> function is called, or after the <see cref="SetClipboardData" /> function is
		///         called with the same clipboard format.
		///     </para>
		///     <para>
		///         The system performs implicit data format conversions between certain clipboard formats when an application calls the
		///         <see cref="GetClipboardData" /> function. For example, if the <see cref="CF.CF_OEMTEXT" /> format is on the clipboard, a window can retrieve
		///         data in the <see cref="CF.CF_TEXT" /> format. The format on the clipboard is converted to the requested format on demand. For more information,
		///         see Synthesized Clipboard Formats.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetClipboardData")]
		public static extern IntPtr GetClipboardData(uint uFormat);

		/// <summary>
		///     Determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to
		///     <see cref="GetAsyncKeyState" />.
		/// </summary>
		/// <param name="vKey">
		///     <para>The virtual-key code. For more information, see Virtual Key Codes.</para>
		///     <para>You can use left- and right-distinguishing constants to specify certain keys. See the Remarks section for further information.</para>
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value specifies whether the key was pressed since the last call to <see cref="GetAsyncKeyState" />, and
		///         whether the key is currently up or down. If the most significant bit is set, the key is down, and if the least significant bit is set, the
		///         key was pressed after the previous call to <see cref="GetAsyncKeyState" />. However, you should not rely on this last behavior; for more
		///         information, see the Remarks.
		///     </para>
		///     <para>The return value is zero for the following cases:</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="GetAsyncKeyState" /> function works with mouse buttons. However, it checks on the state of the physical mouse buttons, not on
		///         the logical mouse buttons that the physical buttons are mapped to. For example, the call <see cref="GetAsyncKeyState" />(VK_LBUTTON) always
		///         returns the state of the left physical mouse button, regardless of whether it is mapped to the left or right logical mouse button. You can
		///         determine the system's current mapping of physical mouse buttons to logical mouse buttons by calling GetSystemMetrics(SM_SWAPBUTTON).
		///     </para>
		///     <para>which returns TRUE if the mouse buttons have been swapped.</para>
		///     <para>
		///         Although the least significant bit of the return value indicates whether the key has been pressed since the last query, due to the
		///         pre-emptive multitasking nature of Windows, another application can call <see cref="GetAsyncKeyState" /> and receive the "recently pressed"
		///         bit instead of your application. The behavior of the least significant bit of the return value is retained strictly for compatibility with
		///         16-bit Windows applications (which are non-preemptive) and should not be relied upon.
		///     </para>
		///     <para>
		///         You can use the virtual-key code constants <see cref="VK.VK_SHIFT" />, <see cref="VK.VK_CONTROL" />, and <see cref="VK.VK_MENU" /> as values for the
		///         <paramref name="vKey" /> parameter. This gives the state of the SHIFT, CTRL, or ALT keys without distinguishing between left and right.
		///     </para>
		///     <para>
		///         You can use the following virtual-key code constants as values for <paramref name="vKey" /> to distinguish between the left and right
		///         instances of those keys.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetAsyncKeyState")]
		public static extern short GetAsyncKeyState(int vKey);

		/// <summary>
		///     The <see cref="ExcludeUpdateRgn" /> function prevents drawing within invalid areas of a window by excluding an updated region in the window from
		///     a clipping region.
		/// </summary>
		/// <param name="hDC">Handle to the device context associated with the clipping region.</param>
		/// <param name="hWnd">Handle to the window to update.</param>
		/// <returns>The return value specifies the complexity of the excluded region; it can be any one of the following values.</returns>
		[DllImport("user32.dll", EntryPoint = "ExcludeUpdateRgn")]
		public static extern int ExcludeUpdateRgn([In] IntPtr hDC, [In] IntPtr hWnd);

		/// <summary>
		///     Enumerates the child windows that belong to the specified parent window by passing the handle to each child window, in turn, to an
		///     application-defined callback function. <see cref="EnumChildWindows" /> continues until the last child window is enumerated or the callback
		///     function returns FALSE.
		/// </summary>
		/// <param name="hWndParent">
		///     A handle to the parent window whose child windows are to be enumerated. If this parameter is NULL, this function is equivalent to
		///     <see cref="EnumWindows" />.
		/// </param>
		/// <param name="lpEnumFunc">
		///     A pointer to an application-defined callback function. For more information, see EnumChildProc.
		/// </param>
		/// <param name="lParam">An application-defined value to be passed to the callback function.</param>
		/// <returns>
		///     <para>The return value is not used.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If a child window has created child windows of its own, <see cref="EnumChildWindows" /> enumerates those windows as well.
		///     </para>
		///     <para>
		///         A child window that is moved or repositioned in the Z order during the enumeration process will be properly enumerated. The function does not
		///         enumerate a child window that is destroyed before being enumerated or that is created during the enumeration process.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "EnumChildWindows")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool EnumChildWindows([In] IntPtr hWndParent, EnumWindowsProc lpEnumFunc, [MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>
		///     The <see cref="DrawFrameControl" /> function draws a frame control of the specified type and style.
		/// </summary>
		/// <param name="hdc">A handle to the device context of the window in which to draw the control.</param>
		/// <param name="lprc">
		///     A pointer to a <see cref="RECT" /> structure that contains the logical coordinates of the bounding rectangle for frame control.
		/// </param>
		/// <param name="uType">
		///     <para>The type of frame control to draw. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>DFC_BUTTON</term>
		///             <description>Standard button</description>
		///         </item>
		///         <item>
		///             <term>DFC_CAPTION</term>
		///             <description>Title bar</description>
		///         </item>
		///         <item>
		///             <term>DFC_MENU</term>
		///             <description>Menu bar</description>
		///         </item>
		///         <item>
		///             <term>DFC_POPUPMENU</term>
		///             <description>Popup menu item.</description>
		///         </item>
		///         <item>
		///             <term>DFC_SCROLL</term>
		///             <description>Scroll bar</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="uState">
		///     <para>
		///         The initial state of the frame control. If <paramref name="uType" /> is DFC_BUTTON, <paramref name="uState" /> can be one of the following
		///         values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>DFCS_BUTTON3STATE</term>
		///             <description>Three-state button</description>
		///         </item>
		///         <item>
		///             <term>DFCS_BUTTONCHECK</term>
		///             <description>Check box</description>
		///         </item>
		///         <item>
		///             <term>DFCS_BUTTONPUSH</term>
		///             <description>Push button</description>
		///         </item>
		///         <item>
		///             <term>DFCS_BUTTONRADIO</term>
		///             <description>Radio button</description>
		///         </item>
		///         <item>
		///             <term>DFCS_BUTTONRADIOIMAGE</term>
		///             <description>Image for radio button (nonsquare needs image)</description>
		///         </item>
		///         <item>
		///             <term>DFCS_BUTTONRADIOMASK</term>
		///             <description>Mask for radio button (nonsquare needs mask)</description>
		///         </item>
		///     </list>
		///     <para>
		///         If <paramref name="uType" /> is DFC_CAPTION, <paramref name="uState" /> can be one of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>DFCS_CAPTIONCLOSE</term>
		///             <description>
		///                 Close button
		///             </description>
		///         </item>
		///         <item>
		///             <term>DFCS_CAPTIONHELP</term>
		///             <description>
		///                 Help button
		///             </description>
		///         </item>
		///         <item>
		///             <term>DFCS_CAPTIONMAX</term>
		///             <description>
		///                 Maximize button
		///             </description>
		///         </item>
		///         <item>
		///             <term>DFCS_CAPTIONMIN</term>
		///             <description>
		///                 Minimize button
		///             </description>
		///         </item>
		///         <item>
		///             <term>DFCS_CAPTIONRESTORE</term>
		///             <description>
		///                 Restore button
		///             </description>
		///         </item>
		///     </list>
		///     <para>
		///         If <paramref name="uType" /> is DFC_MENU, <paramref name="uState" /> can be one of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>DFCS_MENUARROW</term>
		///             <description>Submenu arrow</description>
		///         </item>
		///         <item>
		///             <term>DFCS_MENUARROWRIGHT</term>
		///             <description>
		///                 Submenu arrow pointing left. This is used for the right-to-left cascading menus used with right-to-left languages such as
		///                 Arabic or Hebrew.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DFCS_MENUBULLET</term>
		///             <description>Bullet</description>
		///         </item>
		///         <item>
		///             <term>DFCS_MENUCHECK</term>
		///             <description>Check mark</description>
		///         </item>
		///     </list>
		///     <para>
		///         If <paramref name="uType" /> is DFC_SCROLL, <paramref name="uState" /> can be one of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>DFCS_SCROLLCOMBOBOX</term>
		///             <description>Combo box scroll bar</description>
		///         </item>
		///         <item>
		///             <term>DFCS_SCROLLDOWN</term>
		///             <description>Down arrow of scroll bar</description>
		///         </item>
		///         <item>
		///             <term>DFCS_SCROLLLEFT</term>
		///             <description>Left arrow of scroll bar</description>
		///         </item>
		///         <item>
		///             <term>DFCS_SCROLLRIGHT</term>
		///             <description>Right arrow of scroll bar</description>
		///         </item>
		///         <item>
		///             <term>DFCS_SCROLLSIZEGRIP</term>
		///             <description>Size grip in lower-right corner of window</description>
		///         </item>
		///         <item>
		///             <term>DFCS_SCROLLSIZEGRIPRIGHT</term>
		///             <description>Size grip in lower-left corner of window. This is used with right-to-left languages such as Arabic or Hebrew.</description>
		///         </item>
		///         <item>
		///             <term>DFCS_SCROLLUP</term>
		///             <description>Up arrow of scroll bar</description>
		///         </item>
		///     </list>
		///     <para>The following style can be used to adjust the bounding rectangle of the push button.</para>
		///     <list type="table">
		///         <item>
		///             <term>DFCS_ADJUSTRECT</term>
		///             <description>Bounding rectangle is adjusted to exclude the surrounding edge of the push button.</description>
		///         </item>
		///     </list>
		///     <para>One or more of the following values can be used to set the state of the control to be drawn.</para>
		///     <list type="table">
		///         <item>
		///             <term>DFCS_CHECKED</term>
		///             <description>Button is checked.</description>
		///         </item>
		///         <item>
		///             <term>DFCS_FLAT</term>
		///             <description>Button has a flat border.</description>
		///         </item>
		///         <item>
		///             <term>DFCS_HOT</term>
		///             <description>Button is hot-tracked.</description>
		///         </item>
		///         <item>
		///             <term>DFCS_INACTIVE</term>
		///             <description>Button is inactive (grayed).</description>
		///         </item>
		///         <item>
		///             <term>DFCS_MONO</term>
		///             <description>Button has a monochrome border.</description>
		///         </item>
		///         <item>
		///             <term>DFCS_PUSHED</term>
		///             <description>Button is pushed.</description>
		///         </item>
		///         <item>
		///             <term>DFCS_TRANSPARENT</term>
		///             <description>The background remains untouched. This flag can only be combined with DFCS_MENUARROWUP or DFCS_MENUARROWDOWN.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     If <paramref name="uType" /> is either DFC_MENU or DFC_BUTTON and <paramref name="uState" /> is not DFCS_BUTTONPUSH, the frame control is a
		///     black-on-white mask (that is, a black frame control on a white background). In such cases, the application must pass a handle to a bitmap memory
		///     device control. The application can then use the associated bitmap as the hbmMask parameter to the MaskBlt
		///     function, or it can use the device context as a parameter to the BitBlt function using ROPs such as SRCAND and SRCINVERT.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DrawFrameControl")]
		public static extern bool DrawFrameControl([In] IntPtr hdc, ref RECT lprc, uint uType, uint uState);

		/// <summary>
		///     Dispatches a message to a window procedure. It is typically used to dispatch a message retrieved by the <see cref="GetMessage" /> function.
		/// </summary>
		/// <param name="lpmsg">A pointer to a structure that contains the message.</param>
		/// <returns>
		///     <para>
		///         The return value specifies the value returned by the window procedure. Although its meaning depends on the message being dispatched, the
		///         return value generally is ignored.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="MSG" /> structure must contain valid message values. If the <paramref name="lpmsg" /> parameter points to a
		///         <see cref="WM.WM_TIMER" /> message and the lParam parameter of the <see cref="WM.WM_TIMER" /> message is not NULL,
		///         lParam points to a function that is called instead of the window procedure.
		///     </para>
		///     <para>
		///         Note that the application is responsible for retrieving and dispatching input messages to the dialog box. Most applications use the main
		///         message loop for this. However, to permit the user to move to and to select controls by using the keyboard, the application must call
		///         <see cref="IsDialogMessage" />. For more information, see Dialog Box Keyboard Interface.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DispatchMessage")]
		[return: MarshalAs(UnmanagedType.SysInt)]
		public static extern int DispatchMessage([In] ref MSG lpmsg);

		/// <summary>
		///     Provides default processing for any window message that the window procedure of a multiple-document interface (MDI) child window does not
		///     process. A window message not processed by the window procedure must be passed to the <see cref="DefMDIChildProc" /> function, not to the
		///     <see cref="DefWindowProc" /> function.
		/// </summary>
		/// <param name="hWnd">A handle to the MDI child window.</param>
		/// <param name="uMsg">The message to be processed.</param>
		/// <param name="wParam">Additional message-specific information.</param>
		/// <param name="lParam">Additional message-specific information.</param>
		/// <returns>
		///     <para>The return value specifies the result of the message processing and depends on the message.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="DefMDIChildProc" /> function assumes that the parent window of the MDI child window identified by the <paramref name="hWnd" />
		///         parameter was created with the MDICLIENT class.
		///     </para>
		///     <para>
		///         When an application's window procedure does not handle a message, it typically passes the message to the <see cref="DefWindowProc" />
		///         function to process the message. MDI applications use the <see cref="DefFrameProc" /> and <see cref="DefMDIChildProc" /> functions instead of
		///         <see cref="DefWindowProc" /> to provide default message processing. All messages that an application would usually pass to
		///         <see cref="DefWindowProc" /> (such as nonclient messages and the <see cref="WM.WM_SETTEXT" /> message) should be passed to
		///         <see cref="DefMDIChildProc" /> instead. In addition, <see cref="DefMDIChildProc" /> also handles the following messages.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DefMDIChildProc")]
		[return: MarshalAs(UnmanagedType.SysInt)]
		public static extern int DefMDIChildProc(
			[In] IntPtr hWnd, uint uMsg, [MarshalAs(UnmanagedType.SysUInt)] uint wParam, [MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>
		///     Associates an application-defined value with a conversation handle or a transaction identifier. This is useful for simplifying the processing of
		///     asynchronous transactions. An application can use the <see cref="DdeQueryConvInfo" /> function to retrieve this value.
		/// </summary>
		/// <param name="hConv">A handle to the conversation.</param>
		/// <param name="id">
		///     The transaction identifier to associate with the value specified by the <paramref name="hUser" /> parameter. An application should set this
		///     parameter to QID_SYNC to associate <paramref name="hUser" /> with the conversation identified by the <paramref name="hConv" /> parameter.
		/// </param>
		/// <param name="hUser">The value to be associated with the conversation handle.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DdeSetUserHandle")]
		public static extern bool DdeSetUserHandle(IntPtr hConv, uint id, uint hUser);

		/// <summary>Retrieves information about a Dynamic Data Exchange (DDE) transaction and about the conversation in which the transaction takes place.</summary>
		/// <param name="hConv">A handle to the conversation.</param>
		/// <param name="idTransaction">
		///     The transaction. For asynchronous transactions, this parameter should be a transaction identifier returned by the
		///     <see cref="DdeClientTransaction" /> function. For synchronous transactions, this parameter should be QID_SYNC.
		/// </param>
		/// <param name="pConvInfo">
		///     A pointer to the <see cref="CONVINFO" /> structure that receives information about the transaction and conversation. The <paramref name="cb" />
		///     member of the <see cref="CONVINFO" /> structure must specify the length of the buffer allocated for the structure.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is the number of bytes copied into the <see cref="CONVINFO" /> structure.
		///     </para>
		///     <para>If the function fails, the return value is FALSE.</para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         An application should not free a string handle referenced by the <see cref="CONVINFO" /> structure. If an application must use one of these
		///         string handles, it should call the <see cref="DdeKeepStringHandle" /> function to create a copy of the handle.
		///     </para>
		///     <para>
		///         If the <paramref name="idTransaction" /> parameter is set to QID_SYNC, the <paramref name="CONVINFO.hUser" /> member of the <see cref="CONVINFO" />
		///         structure is associated with the conversation and can be used to hold data associated with the conversation. If
		///         <paramref name="idTransaction" /> is the identifier of an asynchronous transaction, the <paramref name="CONVINFO.hUser" /> member is associated only
		///         with the current transaction and is valid only for the duration of the transaction.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DdeQueryConvInfo")]
		public static extern uint DdeQueryConvInfo(IntPtr hConv, uint idTransaction, ref CONVINFO pConvInfo);

		/// <summary>Creates a multiple-document interface (MDI) child window.</summary>
		/// <param name="lpClassName">
		///     The window class of the MDI child window. The class name must have been registered by a call to the <see cref="RegisterClassEx" /> function.
		/// </param>
		/// <param name="lpWindowName">The window name. The system displays the name in the title bar of the child window.</param>
		/// <param name="dwStyle">
		///     <para>
		///         The style of the MDI child window. If the MDI client window is created with the MDIS_ALLCHILDSTYLES window style, this
		///         parameter can be any combination of the window styles listed in the Window Styles page. Otherwise, this parameter is limited to one or more
		///         of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>WS_MINIMIZE 0x20000000L</term>
		///             <description>Creates an MDI child window that is initially minimized.</description>
		///         </item>
		///         <item>
		///             <term>WS_MAXIMIZE 0x01000000L</term>
		///             <description>Creates an MDI child window that is initially maximized.</description>
		///         </item>
		///         <item>
		///             <term>WS_HSCROLL 0x00100000L</term>
		///             <description>Creates an MDI child window that has a horizontal scroll bar.</description>
		///         </item>
		///         <item>
		///             <term>WS_VSCROLL 0x00200000L</term>
		///             <description>Creates an MDI child window that has a vertical scroll bar.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="X">
		///     The initial horizontal position, in client coordinates, of the MDI child window. If this parameter is <see cref="CW_USEDEFAULT" />
		///     ((int)0x80000000), the MDI child window is assigned the default horizontal position.
		/// </param>
		/// <param name="Y">
		///     The initial vertical position, in client coordinates, of the MDI child window. If this parameter is <see cref="CW_USEDEFAULT" />, the MDI child
		///     window is assigned the default vertical position.
		/// </param>
		/// <param name="nWidth">
		///     The initial width, in device units, of the MDI child window. If this parameter is <see cref="CW_USEDEFAULT" />, the MDI child window is assigned
		///     the default width.
		/// </param>
		/// <param name="nHeight">
		///     The initial height, in device units, of the MDI child window. If this parameter is set to <see cref="CW_USEDEFAULT" />, the MDI child window is
		///     assigned the default height.
		/// </param>
		/// <param name="hWndParent">A handle to the MDI client window that will be the parent of the new MDI child window.</param>
		/// <param name="hInstance">A handle to the instance of the application creating the MDI child window.</param>
		/// <param name="lParam">An application-defined value.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the handle to the created window.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "CreateMDIWindow")]
		public static extern IntPtr CreateMDIWindow(
			[In] string lpClassName, [In] string lpWindowName, WS dwStyle, int X, int Y, int nWidth, int nHeight, [In] IntPtr hWndParent, [In] IntPtr hInstance,
			[MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>
		///     Adds a check mark to (checks) a specified radio button in a group and removes a check mark from (clears) all other radio buttons in the
		///     group.
		/// </summary>
		/// <param name="hDlg">A handle to the dialog box that contains the radio button.</param>
		/// <param name="nIDFirstButton">The identifier of the first radio button in the group.</param>
		/// <param name="nIDLastButton">The identifier of the last radio button in the group.</param>
		/// <param name="nIDCheckButton">The identifier of the radio button to select.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="CheckRadioButton" /> function sends a <see cref="BM_SETCHECK" /> message to each of the radio buttons in the indicated group.
		///     </para>
		///     <para>
		///         The <paramref name="nIDFirstButton" /> and <paramref name="nIDLastButton" /> parameters specify a range of button identifiers (normally the
		///         resource IDs of the buttons). The position of buttons in the tab order is irrelevant; if a button forms part of a group, but has an ID
		///         outside the specified range, it is not affected by this call.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "CheckRadioButton")]
		public static extern bool CheckRadioButton([In] IntPtr hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton);

		/// <summary>
		///     Brings the specified window to the top of the Z order. If the window is a top-level window, it is activated. If the window is a child window, the
		///     top-level parent window associated with the child window is activated.
		/// </summary>
		/// <param name="hWnd">A handle to the window to bring to the top of the Z order.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Use the <see cref="BringWindowToTop" /> function to uncover any window that is partially or completely obscured by other windows.
		///     </para>
		///     <para>
		///         Calling this function is similar to calling the <see cref="SetWindowPos" /> function to change a window's position in the Z order.
		///         <see cref="BringWindowToTop" /> does not make a window a top-level window.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "BringWindowToTop")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool BringWindowToTop([In] IntPtr hWnd);

		/// <summary>
		///     <para>
		///         Calculates the required size of the window rectangle, based on the desired client-rectangle size. The window rectangle can then be passed to
		///         the CreateWindow function to create a window whose client area is the desired size.
		///     </para>
		///     <para>
		///         To specify an extended window style, use the <see cref="AdjustWindowRectEx" /> function.
		///     </para>
		/// </summary>
		/// <param name="lpRect">
		///     A pointer to a <see cref="RECT" /> structure that contains the coordinates of the top-left and bottom-right corners of the desired client area.
		///     When the function returns, the structure contains the coordinates of the top-left and bottom-right corners of the window to accommodate the
		///     desired client area.
		/// </param>
		/// <param name="dwStyle">
		///     The window style of the window whose required size is to be calculated. Note that you cannot specify the <see cref="WS_OVERLAPPED" /> style.
		/// </param>
		/// <param name="bMenu">Indicates whether the window has a menu.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         A client rectangle is the smallest rectangle that completely encloses a client area. A window rectangle is the smallest rectangle that
		///         completely encloses the window, which includes the client area and the nonclient area.
		///     </para>
		///     <para>
		///         The <see cref="AdjustWindowRect" /> function does not add extra space when a menu bar wraps to two or more rows.
		///     </para>
		///     <para>
		///         The <see cref="AdjustWindowRect" /> function does not take the <see cref="WS_VSCROLL" /> or <see cref="WS_HSCROLL" /> styles into account. To
		///         account for the scroll bars, call the <see cref="GetSystemMetrics" /> function with <see cref="SM.SM_CXVSCROLL" /> or
		///         <see cref="SM.SM_CYHSCROLL" />.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "AdjustWindowRect")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool AdjustWindowRect(ref RECT lpRect, WS dwStyle, [MarshalAs(UnmanagedType.Bool)] bool bMenu);

		/// <summary>Retrieves a handle to the window that contains the specified point.</summary>
		/// <param name="Point">The point to be checked.</param>
		/// <returns>
		///     <para>
		///         The return value is a handle to the window that contains the point. If no window exists at the given point, the return value is NULL. If the
		///         point is over a static text control, the return value is a handle to the window under the static text control.
		///     </para>
		/// </returns>
		/// <remarks>
		///     The <see cref="WindowFromPoint" /> function does not retrieve a handle to a hidden or disabled window, even if the point is within the window. An
		///     application should use the <see cref="ChildWindowFromPoint" /> function for a nonrestrictive search.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "WindowFromPoint")]
		public static extern IntPtr WindowFromPoint(POINT Point);

		/// <summary>
		///     Unpacks a Dynamic Data Exchange (DDE)<paramref name="lParam" /> value received from a posted DDE message.
		/// </summary>
		/// <param name="msg">The posted DDE message.</param>
		/// <param name="lParam">
		///     The <paramref name="lParam" /> parameter of the posted DDE message that was received. The application must free the memory object specified by
		///     the <paramref name="lParam" /> parameter by calling the <see cref="FreeDDElParam" /> function.
		/// </param>
		/// <param name="puiLo">
		///     A pointer to a variable that receives the low-order word of <paramref name="lParam" />.
		/// </param>
		/// <param name="puiHi">
		///     A pointer to a variable that receives the high-order word of <paramref name="lParam" />.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <see cref="PackDDElParam" /> eases the porting of 16-bit DDE applications to 32-bit DDE applications.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "UnpackDDElParam")]
		public static extern bool UnpackDDElParam(uint msg, [MarshalAs(UnmanagedType.SysInt)] int lParam, ref uint puiLo, ref uint puiHi);

		/// <summary>
		///     <para>Posts messages when the mouse pointer leaves a window or hovers over a window for a specified amount of time.</para>
		///     <para>
		///         Note:  The <see cref="_TrackMouseEvent" /> function calls <see cref="TrackMouseEvent" /> if it exists, otherwise
		///         <see cref="_TrackMouseEvent" /> emulates <see cref="TrackMouseEvent" />.
		///     </para>
		/// </summary>
		/// <param name="lpEventTrack">
		///     A pointer to a <see cref="TRACKMOUSEEVENT" /> structure that contains tracking information.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero .</para>
		///     <para>If the function fails, return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The mouse pointer is considered to be hovering when it stays within a specified rectangle for a specified period of time. Call
		///         <see cref="SystemParametersInfo" />. and use the values <see cref="SPI.SPI_GETMOUSEHOVERWIDTH" />, <see cref="SPI.SPI_GETMOUSEHOVERHEIGHT" />, and
		///         <see cref="SPI.SPI_GETMOUSEHOVERTIME" /> to retrieve the size of the rectangle and the time.
		///     </para>
		///     <para>The function can post the following messages.</para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "TrackMouseEvent")]
		public static extern bool TrackMouseEvent(ref TRACKMOUSEEVENT lpEventTrack);

		/// <summary>Reverses or restores the meaning of the left and right mouse buttons.</summary>
		/// <param name="fSwap">
		///     If this parameter is TRUE, the left button generates right-button messages and the right button generates left-button messages. If this parameter
		///     is FALSE, the buttons are restored to their original meanings.
		/// </param>
		/// <returns>
		///     <para>If the meaning of the mouse buttons was reversed previously, before the function was called, the return value is nonzero.</para>
		///     <para>If the meaning of the mouse buttons was not reversed, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     Button swapping is provided as a convenience to people who use the mouse with their left hands. The <see cref="SwapMouseButton" /> function is
		///     usually called by Control Panel only. Although an application is free to call the function, the mouse is a shared resource and reversing the
		///     meaning of its buttons affects all applications.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SwapMouseButton")]
		public static extern bool SwapMouseButton([MarshalAs(UnmanagedType.Bool)] bool fSwap);

		/// <summary>Sets the show state of a window created by a different thread.</summary>
		/// <param name="hWnd">A handle to the window.</param>
		/// <param name="nCmdShow">
		///     Controls how the window is to be shown. For a list of possible values, see the description of the <see cref="ShowWindow" /> function.
		/// </param>
		/// <returns>
		///     <para>If the window was previously visible, the return value is nonzero.</para>
		///     <para>If the window was previously hidden, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     This function posts a show-window event to the message queue of the given window. An application can use this function to avoid becoming
		///     nonresponsive while waiting for a nonresponsive application to finish processing a show-window event.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "ShowWindowAsync")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool ShowWindowAsync([In] IntPtr hWnd, int nCmdShow);

		/// <summary>Shows or hides all pop-up windows owned by the specified window.</summary>
		/// <param name="hWnd">A handle to the window that owns the pop-up windows to be shown or hidden.</param>
		/// <param name="fShow">
		///     If this parameter is TRUE, all hidden pop-up windows are shown. If this parameter is FALSE, all visible pop-up windows are
		///     hidden.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <see cref="ShowOwnedPopups" /> shows only windows hidden by a previous call to <see cref="ShowOwnedPopups" />. For example, if a pop-up window is
		///     hidden by using the <see cref="ShowWindow" /> function, subsequently calling <see cref="ShowOwnedPopups" /> with the <paramref name="fShow" />
		///     parameter set to TRUE does not cause the window to be shown.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "ShowOwnedPopups")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool ShowOwnedPopups([In] IntPtr hWnd, [MarshalAs(UnmanagedType.Bool)] bool fShow);

		/// <summary>Sets an event hook function for a range of events.</summary>
		/// <param name="eventMin">
		///     Specifies the event constant for the lowest event value in the range of events that are handled by the hook function. This parameter can be set
		///     to <see cref="EVENT_MIN" /> to indicate the lowest possible event value.
		/// </param>
		/// <param name="eventMax">
		///     Specifies the event constant for the highest event value in the range of events that are handled by the hook function. This parameter can be set
		///     to <see cref="EVENT_MAX" /> to indicate the highest possible event value.
		/// </param>
		/// <param name="hmodWinEventProc">
		///     Handle to the DLL that contains the hook function at <paramref name="lpfnWinEventProc" />, if the WINEVENT_INCONTEXT flag is specified in the
		///     <paramref name="dwFlags" /> parameter. If the hook function is not located in a DLL, or if the WINEVENT_OUTOFCONTEXT flag is specified, this
		///     parameter is NULL.
		/// </param>
		/// <param name="lpfnWinEventProc">
		///     Pointer to the event hook function. For more information about this function, see <see cref="WinEventProc" />.
		/// </param>
		/// <param name="idProcess">
		///     Specifies the ID of the process from which the hook function receives events. Specify zero (0) to receive events from all processes on the
		///     current desktop.
		/// </param>
		/// <param name="idThread">
		///     Specifies the ID of the thread from which the hook function receives events. If this parameter is zero, the hook function is associated with all
		///     existing threads on the current desktop.
		/// </param>
		/// <param name="dwflags">
		///     <para>Flag values that specify the location of the hook function and of the events to be skipped. The following flags are valid:</para>
		///     <list type="table">
		///         <item>
		///             <term>WINEVENT_INCONTEXT</term>
		///             <description>
		///                 The DLL that contains the callback function is mapped into the address space of the process that generates the event. With this flag,
		///                 the system sends event notifications to the callback function as they occur. The hook function must be in a DLL when this flag is
		///                 specified. This flag has no effect when both the calling process and the generating process are not 32-bit or 64-bit processes, or
		///                 when the generating process is a console application. For more information, see In-Context Hook Functions.
		///             </description>
		///         </item>
		///         <item>
		///             <term>WINEVENT_OUTOFCONTEXT</term>
		///             <description>
		///                 The callback function is not mapped into the address space of the process that generates the event. Because the hook function is
		///                 called across process boundaries, the system must queue events. Although this method is asynchronous, events are guaranteed to be in
		///                 sequential order. For more information, see Out-of-Context Hook Functions.
		///             </description>
		///         </item>
		///         <item>
		///             <term>WINEVENT_SKIPOWNPROCESS</term>
		///             <description>
		///                 Prevents this instance of the hook from receiving the events that are generated by threads in this process. This flag does not
		///                 prevent threads from generating events.
		///             </description>
		///         </item>
		///         <item>
		///             <term>WINEVENT_SKIPOWNTHREAD</term>
		///             <description>Prevents this instance of the hook from receiving the events that are generated by the thread that is registering this hook.</description>
		///         </item>
		///     </list>
		///     <para>The following flag combinations are valid:</para>
		///     <para>Additionally, client applications can specify WINEVENT_INCONTEXT, or WINEVENT_OUTOFCONTEXT alone.</para>
		///     <para>See Remarks section for information on Windows Store app development.</para>
		/// </param>
		/// <returns>
		///     <para>
		///         If successful, returns an <see cref="HWINEVENTHOOK" /> value that identifies this event hook instance. Applications save this return value to
		///         use it with the <see cref="UnhookWinEvent" /> function.
		///     </para>
		///     <para>If unsuccessful, returns zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>This function allows clients to specify which processes and threads they are interested in.</para>
		///     <para>
		///         If the <paramref name="idProcess" /> parameter is nonzero and <paramref name="idThread" /> is zero, the hook function receives the specified
		///         events from all threads in that process. If the <paramref name="idProcess" /> parameter is zero and <paramref name="idThread" /> is nonzero,
		///         the hook function receives the specified events only from the thread specified by <paramref name="idThread" />. If both are zero, the hook
		///         function receives the specified events from all threads and processes.
		///     </para>
		///     <para>
		///         Clients can call <see cref="SetWinEventHook" /> multiple times if they want to register additional hook functions or listen for additional
		///         events.
		///     </para>
		///     <para>
		///         The client thread that calls <see cref="SetWinEventHook" /> must have a message loop in order to receive events.
		///     </para>
		///     <para>
		///         When you use <see cref="SetWinEventHook" /> to set a callback in managed code, you should use the <see cref="GCHandle" /> structure to avoid
		///         exceptions. This tells the garbage collector not to move the callback.
		///     </para>
		///     <para>
		///         For out-of-context events, the event is delivered on the same thread that called <see cref="SetWinEventHook" />. In some situations, even if
		///         you request WINEVENT_INCONTEXT events, the events will still be delivered out-of-context. These scenarios include events from console windows
		///         and events from processes that have a different bit-depth (64 bit versus 32 bits) than the caller.
		///     </para>
		///     <para>
		///         While a hook function processes an event, additional events may be triggered, which may cause the hook function to reenter before the
		///         processing for the original event is finished. The problem with reentrancy in hook functions is that events are completed out of sequence
		///         unless the hook function handles this situation. For more information, see Guarding Against Reentrancy.
		///     </para>
		///     <para>
		///         Windows Store app development If dwFlags is WINEVENT_INCONTEXT AND (idProcess = 0 | idThread = 0), then window hook DLLs are not loaded
		///         in-process for the Windows Store app processes and the Windows Runtime broker process unless they are installed by UIAccess processes
		///         (accessibility tools). The notification is delivered on the installer's thread.
		///     </para>
		///     <para>
		///         This behavior is similar to what happens when there is an architecture mismatch between the hook DLL and the target application process, for
		///         example, when the hook DLL is 32-bit and the application process 64-bit.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetWinEventHook")]
		public static extern IntPtr SetWinEventHook(
			uint eventMin, uint eventMax, [In] IntPtr hmodWinEventProc, WinEventProc lpfnWinEventProc, uint idProcess, uint idThread, WINEVENT dwflags);

		/// <summary>
		///     Installs an application-defined hook procedure into a hook chain. You would install a hook procedure to monitor the system for certain types of
		///     events. These events are associated either with a specific thread or with all threads in the same desktop as the calling thread.
		/// </summary>
		/// <param name="idHook">
		///     <para>The type of hook procedure to be installed. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>WH_CALLWNDPROC 4</term>
		///             <description>
		///                 Installs a hook procedure that monitors messages before the system sends them to the destination window procedure. For more
		///                 information, see the <see cref="CallWndProc" /> hook procedure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>WH_CALLWNDPROCRET 12</term>
		///             <description>
		///                 Installs a hook procedure that monitors messages after they have been processed by the destination window procedure. For more
		///                 information, see the <see cref="CallWndRetProc" /> hook procedure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>WH_CBT 5</term>
		///             <description>
		///                 Installs a hook procedure that receives notifications useful to a CBT application. For more information, see the
		///                 <see cref="CBTProc" /> hook procedure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>WH_DEBUG 9</term>
		///             <description>
		///                 Installs a hook procedure useful for debugging other hook procedures. For more information, see the <see cref="DebugProc" /> hook
		///                 procedure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>WH_FOREGROUNDIDLE 11</term>
		///             <description>
		///                 Installs a hook procedure that will be called when the application's foreground thread is about to become idle. This hook is useful
		///                 for performing low priority tasks during idle time. For more information, see the <see cref="ForegroundIdleProc" /> hook procedure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>WH_GETMESSAGE 3</term>
		///             <description>
		///                 Installs a hook procedure that monitors messages posted to a message queue. For more information, see the <see cref="GetMsgProc" />
		///                 hook procedure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>WH_JOURNALPLAYBACK 1</term>
		///             <description>
		///                 Installs a hook procedure that posts messages previously recorded by a <see cref="WH_JOURNALRECORD" /> hook procedure. For more
		///                 information, see the <see cref="JournalPlaybackProc" /> hook procedure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>WH_JOURNALRECORD 0</term>
		///             <description>
		///                 Installs a hook procedure that records input messages posted to the system message queue. This hook is useful for recording macros.
		///                 For more information, see the <see cref="JournalRecordProc" /> hook procedure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>WH_KEYBOARD 2</term>
		///             <description>
		///                 Installs a hook procedure that monitors keystroke messages. For more information, see the <see cref="KeyboardProc" /> hook procedure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>WH_KEYBOARD_LL 13</term>
		///             <description>
		///                 Installs a hook procedure that monitors low-level keyboard input events. For more information, see the
		///                 <see cref="LowLevelKeyboardProc" /> hook procedure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>WH_MOUSE 7</term>
		///             <description>
		///                 Installs a hook procedure that monitors mouse messages. For more information, see the <see cref="MouseProc" /> hook procedure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>WH_MOUSE_LL 14</term>
		///             <description>
		///                 Installs a hook procedure that monitors low-level mouse input events. For more information, see the <see cref="LowLevelMouseProc" />
		///                 hook procedure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>WH_MSGFILTER -1</term>
		///             <description>
		///                 Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or
		///                 scroll bar. For more information, see the <see cref="MessageProc" /> hook procedure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>WH_SHELL 10</term>
		///             <description>
		///                 Installs a hook procedure that receives notifications useful to shell applications. For more information, see the
		///                 <see cref="ShellProc" /> hook procedure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>WH_SYSMSGFILTER 6</term>
		///             <description>
		///                 Installs a hook procedure that monitors messages generated as a result of an input event in a dialog box, message box, menu, or
		///                 scroll bar. The hook procedure monitors these messages for all applications in the same desktop as the calling thread. For more
		///                 information, see the <see cref="SysMsgProc" /> hook procedure.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="lpfn">
		///     A pointer to the hook procedure. If the <paramref name="dwThreadId" /> parameter is zero or specifies the identifier of a thread created by a
		///     different process, the <paramref name="lpfn" /> parameter must point to a hook procedure in a DLL. Otherwise, <paramref name="lpfn" /> can point
		///     to a hook procedure in the code associated with the current process.
		/// </param>
		/// <param name="hMod">
		///     A handle to the DLL containing the hook procedure pointed to by the <paramref name="lpfn" /> parameter. The <paramref name="hMod" /> parameter
		///     must be set to NULL if the <paramref name="dwThreadId" /> parameter specifies a thread created by the current process and if the hook procedure
		///     is within the code associated with the current process.
		/// </param>
		/// <param name="dwThreadId">
		///     The identifier of the thread with which the hook procedure is to be associated. For desktop apps, if this parameter is zero, the hook procedure
		///     is associated with all existing threads running in the same desktop as the calling thread. For Windows Store apps, see the Remarks section.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the handle to the hook procedure.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         <see cref="SetWindowsHookEx" /> can be used to inject a DLL into another process. A 32-bit DLL cannot be injected into a 64-bit process, and
		///         a 64-bit DLL cannot be injected into a 32-bit process. If an application requires the use of hooks in other processes, it is required that a
		///         32-bit application call <see cref="SetWindowsHookEx" /> to inject a 32-bit DLL into 32-bit processes, and a 64-bit application call
		///         <see cref="SetWindowsHookEx" /> to inject a 64-bit DLL into 64-bit processes. The 32-bit and 64-bit DLLs must have different names.
		///     </para>
		///     <para>
		///         Because hooks run in the context of an application, they must match the "bitness" of the application. If a 32-bit application installs a
		///         global hook on 64-bit Windows, the 32-bit hook is injected into each 32-bit process (the usual security boundaries apply). In a 64-bit
		///         process, the threads are still marked as "hooked." However, because a 32-bit application must run the hook code, the system executes the hook
		///         in the hooking app's context; specifically, on the thread that called <see cref="SetWindowsHookEx" />. This means that the hooking
		///         application must continue to pump messages or it might block the normal functioning of the 64-bit processes.
		///     </para>
		///     <para>
		///         If a 64-bit application installs a global hook on 64-bit Windows, the 64-bit hook is injected into each 64-bit process, while all 32-bit
		///         processes use a callback to the hooking application.
		///     </para>
		///     <para>
		///         To hook all applications on the desktop of a 64-bit Windows installation, install a 32-bit global hook and a 64-bit global hook, each from
		///         appropriate processes, and be sure to keep pumping messages in the hooking application to avoid blocking normal functioning. If you already
		///         have a 32-bit global hooking application and it doesn't need to run in each application's context, you may not need to create a 64-bit
		///         version.
		///     </para>
		///     <para>
		///         An error may occur if the <paramref name="hMod" /> parameter is NULL and the <paramref name="dwThreadId" /> parameter is zero or specifies
		///         the identifier of a thread created by another process.
		///     </para>
		///     <para>
		///         Calling the <see cref="CallNextHookEx" /> function to chain to the next hook procedure is optional, but it is highly recommended; otherwise,
		///         other applications that have installed hooks will not receive hook notifications and may behave incorrectly as a result. You should call
		///         <see cref="CallNextHookEx" /> unless you absolutely need to prevent the notification from being seen by other applications.
		///     </para>
		///     <para>
		///         Before terminating, an application must call the <see cref="UnhookWindowsHookEx" /> function to free system resources associated with the
		///         hook.
		///     </para>
		///     <para>
		///         The scope of a hook depends on the hook type. Some hooks can be set only with global scope; others can also be set for only a specific
		///         thread, as shown in the following table.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetWindowsHook")]
		public static extern IntPtr SetWindowsHook(int nFilterType, HOOKPROC pfnFilterProc);

		/// <summary>
		///     Enables an application to customize the system cursors. It replaces the contents of the system cursor specified by the <paramref name="id" />
		///     parameter with the contents of the cursor specified by the <paramref name="hcur" /> parameter and then destroys <paramref name="hcur" />.
		/// </summary>
		/// <param name="hcur">
		///     <para>
		///         A handle to the cursor. The function replaces the contents of the system cursor specified by <paramref name="id" /> with the contents of the
		///         cursor handled by <paramref name="hcur" />.
		///     </para>
		///     <para>
		///         The system destroys <paramref name="hcur" /> by calling the <see cref="DestroyCursor" /> function. Therefore, <paramref name="hcur" /> cannot
		///         be a cursor loaded using the <see cref="LoadCursor" /> function. To specify a cursor loaded from a resource, copy the cursor using the
		///         <see cref="CopyCursor" /> function, then pass the copy to <see cref="SetSystemCursor" />.
		///     </para>
		/// </param>
		/// <param name="id">
		///     <para>
		///         The system cursor to replace with the contents of <paramref name="hcur" />. This parameter can be one of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>OCR_APPSTARTING 32650</term>
		///             <description>Standard arrow and small hourglass</description>
		///         </item>
		///         <item>
		///             <term>OCR_NORMAL 32512</term>
		///             <description>Standard arrow</description>
		///         </item>
		///         <item>
		///             <term>OCR_CROSS 32515</term>
		///             <description>Crosshair</description>
		///         </item>
		///         <item>
		///             <term>OCR_HAND 32649</term>
		///             <description>Hand</description>
		///         </item>
		///         <item>
		///             <term>OCR_HELP 32651</term>
		///             <description>Arrow and question mark</description>
		///         </item>
		///         <item>
		///             <term>OCR_IBEAM 32513</term>
		///             <description>I-beam</description>
		///         </item>
		///         <item>
		///             <term>OCR_NO 32648</term>
		///             <description>Slashed circle</description>
		///         </item>
		///         <item>
		///             <term>OCR_SIZEALL 32646</term>
		///             <description>Four-pointed arrow pointing north, south, east, and west</description>
		///         </item>
		///         <item>
		///             <term>OCR_SIZENESW 32643</term>
		///             <description>Double-pointed arrow pointing northeast and southwest</description>
		///         </item>
		///         <item>
		///             <term>OCR_SIZENS 32645</term>
		///             <description>Double-pointed arrow pointing north and south</description>
		///         </item>
		///         <item>
		///             <term>OCR_SIZENWSE 32642</term>
		///             <description>Double-pointed arrow pointing northwest and southeast</description>
		///         </item>
		///         <item>
		///             <term>OCR_SIZEWE 32644</term>
		///             <description>Double-pointed arrow pointing west and east</description>
		///         </item>
		///         <item>
		///             <term>OCR_UP 32516</term>
		///             <description>Vertical arrow</description>
		///         </item>
		///         <item>
		///             <term>OCR_WAIT 32514</term>
		///             <description>Hourglass</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     For an application to use any of the OCR_ constants, the constant <see cref="OEMRESOURCE" /> must be defined before the Windows.h header file is
		///     included.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetSystemCursor")]
		public static extern bool SetSystemCursor([In] IntPtr hcur, uint id);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetMessageQueue")]
		public static extern bool SetMessageQueue(int cMessagesMax);

		/// <summary>Sets the title or text of a control in a dialog box.</summary>
		/// <param name="hDlg">A handle to the dialog box that contains the control.</param>
		/// <param name="nIDDlgItem">The control with a title or text to be set.</param>
		/// <param name="lpString">The text to be copied to the control.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     The <see cref="SetDlgItemText" /> function sends a <see cref="WM.WM_SETTEXT" /> message to the specified control.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetDlgItemText")]
		public static extern bool SetDlgItemText([In] IntPtr hDlg, int nIDDlgItem, [In] string lpString);

		/// <summary>Activates a window. The window must be attached to the calling thread's message queue.</summary>
		/// <param name="hWnd">A handle to the top-level window to be activated.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the handle to the window that was previously active.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="SetActiveWindow" /> function activates a window, but not if the application is in the background. The window will be brought
		///         into the foreground (top of <see cref="Z-Order" />) if its application is in the foreground when the system activates the window.
		///     </para>
		///     <para>
		///         If the window identified by the <paramref name="hWnd" /> parameter was created by the calling thread, the active window status of the calling
		///         thread is set to <paramref name="hWnd" />. Otherwise, the active window status of the calling thread is set to NULL.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetActiveWindow")]
		public static extern IntPtr SetActiveWindow([In] IntPtr hWnd);

		/// <summary>
		///     Indicates to the system that a thread has made a request to terminate (quit). It is typically used in response to a <see cref="WM.WM_DESTROY" />
		///     message.
		/// </summary>
		/// <param name="nExitCode">
		///     The application exit code. This value is used as the <paramref name="wParam" /> parameter of the <see cref="WM.WM_QUIT" /> message.
		/// </param>
		/// <returns>This function does not return a value.</returns>
		/// <remarks>
		///     <para>
		///         The <see cref="PostQuitMessage" /> function posts a <see cref="WM.WM_QUIT" /> message to the thread's message queue and returns immediately;
		///         the function simply indicates to the system that the thread is requesting to quit at some time in the future.
		///     </para>
		///     <para>
		///         When the thread retrieves the <see cref="WM.WM_QUIT" /> message from its message queue, it should exit its message loop and return control to
		///         the system. The exit value returned to the system must be the <paramref name="wParam" /> parameter of the <see cref="WM.WM_QUIT" /> message.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "PostQuitMessage")]
		public static extern void PostQuitMessage(int nExitCode);

		/// <summary>
		///     The <see cref="MonitorFromRect" /> function retrieves a handle to the display monitor that has the largest area of intersection with a specified
		///     rectangle.
		/// </summary>
		/// <param name="lprc">
		///     A pointer to a <see cref="RECT" /> structure that specifies the rectangle of interest in virtual-screen coordinates.
		/// </param>
		/// <param name="dwFlags">
		///     <para>Determines the function's return value if the rectangle does not intersect any display monitor.</para>
		///     <para>This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MONITOR_DEFAULTTONEAREST</term>
		///             <description>Returns a handle to the display monitor that is nearest to the rectangle.</description>
		///         </item>
		///         <item>
		///             <term>MONITOR_DEFAULTTONULL</term>
		///             <description>Returns NULL.</description>
		///         </item>
		///         <item>
		///             <term>MONITOR_DEFAULTTOPRIMARY</term>
		///             <description>Returns a handle to the primary display monitor.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>
		///         If the rectangle intersects one or more display monitor rectangles, the return value is an <see cref="HMONITOR" /> handle to the display
		///         monitor that has the largest area of intersection with the rectangle.
		///     </para>
		///     <para>
		///         If the rectangle does not intersect a display monitor, the return value depends on the value of <paramref name="dwFlags" />.
		///     </para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "MonitorFromRect")]
		public static extern IntPtr MonitorFromRect([In] ref RECT lprc, MONITOR dwFlags);

		/// <summary>
		///     The <see cref="MapWindowPoints" /> function converts (maps) a set of points from a coordinate space relative to one window to a coordinate space
		///     relative to another window.
		/// </summary>
		/// <param name="hWndFrom">
		///     A handle to the window from which points are converted. If this parameter is NULL or HWND_DESKTOP, the points are presumed to be in screen
		///     coordinates.
		/// </param>
		/// <param name="hWndTo">
		///     A handle to the window to which points are converted. If this parameter is NULL or HWND_DESKTOP, the points are converted to
		///     screen coordinates.
		/// </param>
		/// <param name="lpPoints">
		///     A pointer to an array of <see cref="POINT" /> structures that contain the set of points to be converted. The points are in device units. This
		///     parameter can also point to a <see cref="RECT" /> structure, in which case the <paramref name="cPoints" /> parameter should be set to 2.
		/// </param>
		/// <param name="cPoints">
		///     The number of <see cref="POINT" /> structures in the array pointed to by the <paramref name="lpPoints" /> parameter.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the low-order word of the return value is the number of pixels added to the horizontal coordinate of each source
		///         point in order to compute the horizontal coordinate of each destination point. (In addition to that, if precisely one of
		///         <paramref name="hWndFrom" /> and <paramref name="hWndTo" /> is mirrored, then each resulting horizontal coordinate is multiplied by -1.) The
		///         high-order word is the number of pixels added to the vertical coordinate of each source point in order to compute the vertical coordinate of
		///         each destination point.
		///     </para>
		///     <para>
		///         If the function fails, the return value is zero. Call SetLastError prior to calling this method to differentiate an error
		///         return value from a legitimate "0" return value.
		///     </para>
		/// </returns>
		/// <remarks>
		///     If <paramref name="hWndFrom" /> or <paramref name="hWndTo" /> (or both) are mirrored windows (that is, have <see cref="WS_EX.WS_EX_LAYOUTRTL" />
		///     extended style) and precisely two points are passed in <paramref name="lpPoints" />, <see cref="MapWindowPoints" /> will interpret those two
		///     points as a <see cref="RECT" /> and possibly automatically swap the left and right fields of that rectangle to ensure that left is not greater
		///     than right. If any number of points other than 2 is passed in <paramref name="lpPoints" />, then <see cref="MapWindowPoints" /> will correctly
		///     map the coordinates of each of those points separately, so if you pass in a pointer to an array of more than one rectangle in
		///     <paramref name="lpPoints" />, the new rectangles may get their left field greater than right. Thus, to guarantee the correct transformation of
		///     rectangle coordinates, you must call <see cref="MapWindowPoints" /> with one <see cref="RECT" /> pointer at a time, as shown in the following
		///     example:
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "MapWindowPoints")]
		public static extern int MapWindowPoints([In] IntPtr hWndFrom, [In] IntPtr hWndTo, ref POINT[] lpPoints, uint cPoints);

		/// <summary>Locks the workstation's display. Locking a workstation protects it from unauthorized use.</summary>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is nonzero. Because the function executes asynchronously, a nonzero return value indicates that
		///         the operation has been initiated. It does not indicate whether the workstation has been successfully locked.
		///     </para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="LockWorkStation" /> function is callable only by processes running on the interactive desktop. In addition, the user must be
		///         logged on, and the workstation cannot already be locked.
		///     </para>
		///     <para>
		///         Common reasons the workstation might not be locked even if the function succeeds include the following: no user is logged on, the workstation
		///         is already locked, the process is not running on the interactive desktop, or the request is denied by the Graphical Identification and
		///         Authentication (GINA) DLL.
		///     </para>
		///     <para>
		///         This function has the same result as pressing Ctrl+Alt+Del and clicking Lock Workstation. To unlock the workstation, the user must log in.
		///         There is no function you can call to determine whether the workstation is locked. To receive notification when the user logs in, use the
		///         <see cref="WTSRegisterSessionNotification" /> function to receive <see cref="WM.WM_WTSSESSION_CHANGE" /> messages. You can use session
		///         notifications to track the desktop state so you know whether it is possible to interact with the user.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "LockWorkStation")]
		public static extern bool LockWorkStation();

		/// <summary>Determines the visibility state of the specified window.</summary>
		/// <param name="hWnd">A handle to the window to be tested.</param>
		/// <returns>
		///     <para>
		///         If the specified window, its parent window, its parent's parent window, and so forth, have the <see cref="WS.WS_VISIBLE" /> style, the return
		///         value is nonzero. Otherwise, the return value is zero.
		///     </para>
		///     <para>
		///         Because the return value specifies whether the window has the <see cref="WS.WS_VISIBLE" /> style, it may be nonzero even if the window is
		///         totally obscured by other windows.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The visibility state of a window is indicated by the <see cref="WS.WS_VISIBLE" /> style bit. When <see cref="WS.WS_VISIBLE" /> is set, the window
		///         is displayed and subsequent drawing into it is displayed as long as the window has the <see cref="WS.WS_VISIBLE" /> style.
		///     </para>
		///     <para>
		///         Any drawing to a window with the <see cref="WS.WS_VISIBLE" /> style will not be displayed if the window is obscured by other windows or is
		///         clipped by its parent window.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "IsWindowVisible")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool IsWindowVisible([In] IntPtr hWnd);

		/// <summary>Determines whether the specified window is a native Unicode window.</summary>
		/// <param name="hWnd">A handle to the window to be tested.</param>
		/// <returns>
		///     <para>If the window is a native Unicode window, the return value is nonzero.</para>
		///     <para>If the window is not a native Unicode window, the return value is zero. The window is a native ANSI window.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The character set of a window is determined by the use of the <see cref="RegisterClass" /> function. If the window class was registered with
		///         the ANSI version of <see cref="RegisterClass" /> (<see cref="RegisterClassA" />), the character set of the window is ANSI. If the window
		///         class was registered with the Unicode version of <see cref="RegisterClass" /> (<see cref="RegisterClassW" />), the character set of the
		///         window is Unicode.
		///     </para>
		///     <para>
		///         The system does automatic two-way translation (Unicode to ANSI) for window messages. For example, if an ANSI window message is sent to a
		///         window that uses the Unicode character set, the system translates that message into a Unicode message before calling the window procedure.
		///         The system calls <see cref="IsWindowUnicode" /> to determine whether to translate the message.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "IsWindowUnicode")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool IsWindowUnicode([In] IntPtr hWnd);

		/// <summary>Determines whether the specified window is enabled for mouse and keyboard input.</summary>
		/// <param name="hWnd">A handle to the window to be tested.</param>
		/// <returns>
		///     <para>If the window is enabled, the return value is nonzero.</para>
		///     <para>If the window is not enabled, the return value is zero.</para>
		/// </returns>
		/// <remarks>A child window receives input only if it is both enabled and visible.</remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "IsWindowEnabled")]
		public static extern bool IsWindowEnabled([In] IntPtr hWnd);

		/// <summary>
		///     <para>[This function is not intended for general use. It may be altered or unavailable in subsequent versions of Windows.]</para>
		///     <para>
		///         Determines whether the system considers that a specified application is not responding. An application is considered to be not responding if
		///         it is not waiting for input, is not in startup processing, and has not called <see cref="PeekMessage" /> within the internal timeout period
		///         of 5 seconds.
		///     </para>
		/// </summary>
		/// <param name="hWnd">A handle to the window to be tested.</param>
		/// <returns>
		///     <para>The return value is TRUE if the window stops responding; otherwise, it is FALSE. Ghost windows always return TRUE.</para>
		/// </returns>
		/// <remarks>
		///     <para>The Windows timeout criteria of 5 seconds is subject to change.</para>
		///     <para>
		///         This function was not included in the SDK headers and libraries until Windows XP Service Pack 1 (SP1) and Windows Server 2003. If you do not
		///         have a header file and import library for this function, you can call the function using LoadLibrary and
		///         GetProcAddress.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "IsHungAppWindow")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool IsHungAppWindow([In] IntPtr hwnd);

		/// <summary>
		///     <para>Inserts a new menu item into a menu, moving other items down the menu.</para>
		///     <para>
		///         Note:  The <see cref="InsertMenu" /> function has been superseded by the <see cref="InsertMenuItem" /> function. You can still
		///         use <see cref="InsertMenu" />, however, if you do not need any of the extended features of <see cref="InsertMenuItem" />.
		///     </para>
		/// </summary>
		/// <param name="hMenu">A handle to the menu to be changed.</param>
		/// <param name="uPosition">
		///     The menu item before which the new menu item is to be inserted, as determined by the <paramref name="uFlags" /> parameter.
		/// </param>
		/// <param name="uFlags">
		///     <para>
		///         Controls the interpretation of the <paramref name="uPosition" /> parameter and the content, appearance, and behavior of the new menu item.
		///         This parameter must include one of the following required values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BYCOMMAND 0x00000000L</term>
		///             <description>
		///                 Indicates that the <paramref name="uPosition" /> parameter gives the identifier of the menu item. The <see cref="MF.MF_BYCOMMAND" />
		///                 flag is the default if neither the <see cref="MF.MF_BYCOMMAND" /> nor <see cref="MF.MF_BYPOSITION" /> flag is specified.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_BYPOSITION 0x00000400L</term>
		///             <description>
		///                 Indicates that the <paramref name="uPosition" /> parameter gives the zero-based relative position of the new menu item. If
		///                 <paramref name="uPosition" /> is -1, the new menu item is appended to the end of the menu.
		///             </description>
		///         </item>
		///     </list>
		///     <para>The parameter must also include at least one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BITMAP 0x00000004L</term>
		///             <description>
		///                 Uses a bitmap as the menu item. The <paramref name="lpNewItem" /> parameter contains a handle to the bitmap.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_CHECKED 0x00000008L</term>
		///             <description>
		///                 Places a check mark next to the menu item. If the application provides check-mark bitmaps (see <see cref="SetMenuItemBitmaps" />),
		///                 this flag displays the check-mark bitmap next to the menu item.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_DISABLED 0x00000002L</term>
		///             <description>Disables the menu item so that it cannot be selected, but does not gray it.</description>
		///         </item>
		///         <item>
		///             <term>MF_ENABLED 0x00000000L</term>
		///             <description>Enables the menu item so that it can be selected and restores it from its grayed state.</description>
		///         </item>
		///         <item>
		///             <term>MF_GRAYED 0x00000001L</term>
		///             <description>Disables the menu item and grays it so it cannot be selected.</description>
		///         </item>
		///         <item>
		///             <term>MF_MENUBARBREAK 0x00000020L</term>
		///             <description>
		///                 Functions the same as the <see cref="MF.MF_MENUBREAK" /> flag for a menu bar. For a drop-down menu, submenu, or shortcut menu, the new
		///                 column is separated from the old column by a vertical line.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_MENUBREAK 0x00000040L</term>
		///             <description>
		///                 Places the item on a new line (for menu bars) or in a new column (for a drop-down menu, submenu, or shortcut menu) without
		///                 separating columns.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_OWNERDRAW 0x00000100L</term>
		///             <description>
		///                 Specifies that the item is an owner-drawn item. Before the menu is displayed for the first time, the window that owns the menu
		///                 receives a <see cref="WM.WM_MEASUREITEM" /> message to retrieve the width and height of the menu item. The
		///                 <see cref="WM.WM_DRAWITEM" />
		///                 message is then sent to the window procedure of the owner window whenever the appearance of the menu item must be updated.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_POPUP 0x00000010L</term>
		///             <description>
		///                 Specifies that the menu item opens a drop-down menu or submenu. The <paramref name="uIDNewItem" /> parameter specifies a handle to
		///                 the drop-down menu or submenu. This flag is used to add a menu name to a menu bar or a menu item that opens a submenu to a drop-down
		///                 menu, submenu, or shortcut menu.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_SEPARATOR 0x00000800L</term>
		///             <description>
		///                 Draws a horizontal dividing line. This flag is used only in a drop-down menu, submenu, or shortcut menu. The line cannot be grayed,
		///                 disabled, or highlighted. The <paramref name="lpNewItem" /> and <paramref name="uIDNewItem" /> parameters are ignored.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_STRING 0x00000000L</term>
		///             <description>
		///                 Specifies that the menu item is a text string; the <paramref name="lpNewItem" /> parameter is a pointer to the string.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_UNCHECKED 0x00000000L</term>
		///             <description>
		///                 Does not place a check mark next to the menu item (default). If the application supplies check-mark bitmaps (see the
		///                 <see cref="SetMenuItemBitmaps" /> function), this flag displays the clear bitmap next to the menu item.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="uIDNewItem">
		///     The identifier of the new menu item or, if the <paramref name="uFlags" /> parameter has the <see cref="MF.MF_POPUP" /> flag set, a handle to the
		///     drop-down menu or submenu.
		/// </param>
		/// <param name="lpNewItem">
		///     <para>
		///         The content of the new menu item. The interpretation of <paramref name="lpNewItem" /> depends on whether the <paramref name="uFlags" />
		///         parameter includes the <see cref="MF.MF_BITMAP" />, <see cref="MF.MF_OWNERDRAW" />, or <see cref="MF.MF_STRING" /> flag, as follows.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BITMAP 0x00000004L</term>
		///             <description>Contains a bitmap handle.</description>
		///         </item>
		///         <item>
		///             <term>MF_OWNERDRAW 0x00000100L</term>
		///             <description>
		///                 Contains an application-supplied value that can be used to maintain additional data related to the menu item. The value is in the
		///                 <see cref="itemData" /> member of the structure pointed to by the <paramref name="lParam" /> parameter of the
		///                 <see cref="WM.WM_MEASUREITEM" /> or <see cref="WM.WM_DRAWITEM" /> message sent when the menu item is created or its appearance is
		///                 updated.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_STRING 0x00000000L</term>
		///             <description>Contains a pointer to a null-terminated string (the default).</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The application must call the <see cref="DrawMenuBar" /> function whenever a menu changes, whether the menu is in a displayed window.
		///     </para>
		///     <para>The following groups of flags cannot be used together:</para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "InsertMenuItem")]
		public static extern bool InsertMenuItem(
			[In] IntPtr hmenu, uint item, [MarshalAs(UnmanagedType.Bool)] bool fByPosition, [In] ref MENUITEMINFO lpmi);

		/// <summary>
		///     Determines whether the current window procedure is processing a message that was sent from another thread (in the same process or a different
		///     process).
		/// </summary>
		/// <param name="lpReserved">Reserved; must be NULL.</param>
		/// <returns>
		///     <para>
		///         If the message was not sent, the return value is <see cref="ISMEX_NOSEND" /> (0x00000000). Otherwise, the return value is one or more of the
		///         following values.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>To determine if the sender is blocked, use the following test:</para>
		///     <para>fBlocked = ( InSendMessageEx(NULL) &amp; (ISMEX_REPLIED|ISMEX_SEND) ) == ISMEX_SEND;</para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "InSendMessageEx")]
		public static extern uint InSendMessageEx(IntPtr lpReserved);

		/// <summary>
		///     The <see cref="GetWindowRgnBox" /> function retrieves the dimensions of the tightest bounding rectangle for the window region of a window.
		/// </summary>
		/// <param name="hWnd">Handle to the window.</param>
		/// <param name="lprc">
		///     Pointer to a <see cref="RECT" /> structure that receives the rectangle dimensions, in device units relative to the upper-left corner of the
		///     window.
		/// </param>
		/// <returns>The return value specifies the type of the region that the function obtains. It can be one of the following values.</returns>
		/// <remarks>
		///     <para>
		///         The window region determines the area within the window where the system permits drawing. The system does not display any portion of a window
		///         that lies outside of the window region. The coordinates of a window's window region are relative to the upper-left corner of the window, not
		///         the client area of the window.
		///     </para>
		///     <para>
		///         To set the window region of a window, call the <see cref="SetWindowRgn" /> function.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetWindowRgnBox")]
		public static extern int GetWindowRgnBox([In] IntPtr hWnd, [Out] out RECT lprc);

		/// <summary>Retrieves information about the specified title bar.</summary>
		/// <param name="hwnd">A handle to the title bar whose information is to be retrieved.</param>
		/// <param name="pti">
		///     A pointer to a <see cref="TITLEBARINFO" /> structure to receive the information. Note that you must set the <see cref="cbSize" /> member to
		///     sizeof(TITLEBARINFO) before calling this function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetTitleBarInfo")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool GetTitleBarInfo([In] IntPtr hwnd, ref TITLEBARINFO pti);

		/// <summary>Retrieves the raw input from the specified device.</summary>
		/// <param name="hRawInput">
		///     A handle to the <see cref="RAWINPUT" /> structure. This comes from the <paramref name="lParam" /> in <see cref="WM.WM_INPUT" />.
		/// </param>
		/// <param name="uiCommand">
		///     <para>The command flag. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>RID_HEADER 0x10000005</term>
		///             <description>
		///                 Get the header information from the <see cref="RAWINPUT" /> structure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>RID_INPUT 0x10000003</term>
		///             <description>
		///                 Get the raw data from the <see cref="RAWINPUT" /> structure.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="pData">
		///     A pointer to the data that comes from the <see cref="RAWINPUT" /> structure. This depends on the value of <paramref name="uiCommand" />. If
		///     <paramref name="pData" /> is NULL, the required size of the buffer is returned in *<paramref name="pcbSize" />.
		/// </param>
		/// <param name="pcbSize">
		///     The size, in bytes, of the data in <paramref name="pData" />.
		/// </param>
		/// <param name="cbSizeHeader">
		///     The size, in bytes, of the <see cref="RAWINPUTHEADER" /> structure.
		/// </param>
		/// <returns>
		///     <para>
		///         If <paramref name="pData" /> is NULL and the function is successful, the return value is 0. If <paramref name="pData" /> is not NULL and the
		///         function is successful, the return value is the number of bytes copied into pData.
		///     </para>
		///     <para>
		///         If there is an error, the return value is (UINT)-1.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <see cref="GetRawInputData" /> gets the raw input one <see cref="RAWINPUT" /> structure at a time. In contrast, <see cref="GetRawInputBuffer" />
		///     gets an array of <see cref="RAWINPUT" /> structures.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetRawInputData")]
		public static extern uint GetRawInputData([In] IntPtr hRawInput, uint uiCommand, IntPtr pData, ref uint pcbSize, uint cbSizeHeader);

		/// <summary>
		///     The <see cref="GetMonitorInfo" /> function retrieves information about a display monitor.
		/// </summary>
		/// <param name="hMonitor">A handle to the display monitor of interest.</param>
		/// <param name="lpmi">
		///     <para>
		///         A pointer to a <see cref="MONITORINFO" /> or <see cref="MONITORINFOEX" /> structure that receives information about the specified display
		///         monitor.
		///     </para>
		///     <para>
		///         You must set the <see cref="MONITORINFO.cbSize" /> member of the structure to sizeof(MONITORINFO) or sizeof(MONITORINFOEX) before calling the
		///         <see cref="GetMonitorInfo" /> function. Doing so lets the function determine the type of structure you are passing to it.
		///     </para>
		///     <para>
		///         The <see cref="MONITORINFOEX" /> structure is a superset of the <see cref="MONITORINFO" /> structure. It has one additional member: a string
		///         that contains a name for the display monitor. Most applications have no use for a display monitor name, and so can save some bytes by using a
		///         <see cref="MONITORINFO" /> structure.
		///     </para>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetMonitorInfo")]
		public static extern bool GetMonitorInfo([In] IntPtr hMonitor, ref MONITORINFO lpmi);

		/// <summary>Retrieves the bounding rectangle for the specified menu item.</summary>
		/// <param name="hWnd">
		///     <para>A handle to the window containing the menu.</para>
		///     <para>
		///         If this value is NULL and the <paramref name="hMenu" /> parameter represents a popup menu, the function will find the menu window.
		///     </para>
		/// </param>
		/// <param name="hMenu">A handle to a menu.</param>
		/// <param name="uItem">The zero-based position of the menu item.</param>
		/// <param name="lprcItem">
		///     A pointer to a <see cref="RECT" /> structure that receives the bounding rectangle of the specified menu item expressed in screen coordinates.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, use the GetLastError function.</para>
		/// </returns>
		/// <remarks>
		///     In order for the returned rectangle to be meaningful, the menu must be popped up if a popup menu or attached to a window if a menu bar. Menu item
		///     positions are not determined until the menu is displayed.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetMenuItemRect")]
		public static extern bool GetMenuItemRect([In] IntPtr hWnd, [In] IntPtr hMenu, uint uItem, [Out] out RECT lprcItem);

		/// <summary>Retrieves a string that represents the name of a key.</summary>
		/// <param name="lParam">
		///     <para>
		///         The second parameter of the keyboard message (such as <see cref="WM.WM_KEYDOWN" />) to be processed. The function interprets the following
		///         bit positions in the <paramref name="lParam" />.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>16-23</term>
		///             <description>Scan code.</description>
		///         </item>
		///         <item>
		///             <term>24</term>
		///             <description>Extended-key flag. Distinguishes some keys on an enhanced keyboard.</description>
		///         </item>
		///         <item>
		///             <term>25</term>
		///             <description>
		///                 "Do not care" bit. The application calling this function sets this bit to indicate that the function should not distinguish between
		///                 left and right CTRL and SHIFT keys, for example.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="lpString">The buffer that will receive the key name.</param>
		/// <param name="cchSize">
		///     The maximum length, in characters, of the key name, including the terminating null character. (This parameter should be equal to the size of the
		///     buffer pointed to by the <paramref name="lpString" /> parameter.)
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, a null-terminated string is copied into the specified buffer, and the return value is the length of the string, in
		///         characters, not counting the terminating null character.
		///     </para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     The format of the key-name string depends on the current keyboard layout. The keyboard driver maintains a list of names in the form of character
		///     strings for keys with names longer than a single character. The key name is translated according to the layout of the currently installed
		///     keyboard, thus the function may give different results for different input locales. The name of a character key is the character itself. The
		///     names of dead keys are spelled out in full.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetKeyNameText")]
		public static extern int GetKeyNameText(int lParam, [Out] StringBuilder lpString, int cchSize);

		/// <summary>Retrieves information about the current keyboard.</summary>
		/// <param name="nTypeFlag">
		///     <para>The type of keyboard information to be retrieved. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>0</term>
		///             <description>Keyboard type</description>
		///         </item>
		///         <item>
		///             <term>1</term>
		///             <description>Keyboard subtype</description>
		///         </item>
		///         <item>
		///             <term>2</term>
		///             <description>The number of function keys on the keyboard</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value specifies the requested information.</para>
		///     <para>
		///         If the function fails and <paramref name="nTypeFlag" /> is not one, the return value is zero; zero is a valid return value when
		///         <paramref name="nTypeFlag" /> is one (keyboard subtype). To get extended error information, call GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>The type may be one of the following values.</remarks>
		[DllImport("user32.dll", EntryPoint = "GetKeyboardType")]
		public static extern int GetKeyboardType(int nTypeFlag);

		/// <summary>Retrieves the count of handles to graphical user interface (GUI) objects in use by the specified process.</summary>
		/// <param name="hProcess">
		///     A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION access right. For more information, see Process
		///     Security and Access Rights.
		/// </param>
		/// <param name="uiFlags">
		///     <para>The GUI object type. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>GR_GDIOBJECTS 0</term>
		///             <description>Return the count of GDI objects.</description>
		///         </item>
		///         <item>
		///             <term>GR_GDIOBJECTS_PEAK 2</term>
		///             <description>
		///                 <para>Return the peak count of GDI objects.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>GR_USEROBJECTS 1</term>
		///             <description>Return the count of USER objects.</description>
		///         </item>
		///         <item>
		///             <term>GR_USEROBJECTS_PEAK 4</term>
		///             <description>
		///                 <para>Return the peak count of USER objects.</para>
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is the count of handles to GUI objects in use by the process. If no GUI objects are in use, the
		///         return value is zero.
		///     </para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     A process without a graphical user interface does not use GUI resources, therefore, <see cref="GetGuiResources" /> will return zero.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetGuiResources")]
		public static extern uint GetGuiResources([In] IntPtr hProcess, GR uiFlags);

		/// <summary>Retrieves the title or text associated with a control in a dialog box.</summary>
		/// <param name="hDlg">A handle to the dialog box that contains the control.</param>
		/// <param name="nIDDlgItem">The identifier of the control whose title or text is to be retrieved.</param>
		/// <param name="lpString">The buffer to receive the title or text.</param>
		/// <param name="nMaxCount">
		///     The maximum length, in characters, of the string to be copied to the buffer pointed to by <paramref name="lpString" />. If the length of the
		///     string, including the null character, exceeds the limit, the string is truncated.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value specifies the number of characters copied to the buffer, not including the terminating null
		///         character.
		///     </para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>If the string is as long or longer than the buffer, the buffer will contain the truncated string with a terminating null character.</para>
		///     <para>
		///         The <see cref="GetDlgItemText" /> function sends a <see cref="WM.WM_GETTEXT" /> message to the control.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetDlgItemText")]
		public static extern uint GetDlgItemText([In] IntPtr hDlg, int nIDDlgItem, [Out] StringBuilder lpString, int nMaxCount);

		/// <summary>Retrieves information about the specified combo box.</summary>
		/// <param name="hwndCombo">A handle to the combo box.</param>
		/// <param name="pcbi">
		///     A pointer to a <see cref="COMBOBOXINFO" /> structure that receives the information. You must set <see cref="COMBOBOXINFO.cbSize" /> before
		///     calling this function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     The CB_GETCOMBOBOXINFO message is equivalent to this function.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetComboBoxInfo")]
		public static extern bool GetComboBoxInfo([In] IntPtr hwndCombo, ref COMBOBOXINFO pcbi);

		/// <summary>
		///     Retrieves information about a window class, including a handle to the small icon associated with the window class. The
		///     <see cref="GetClassInfo" /> function does not retrieve a handle to the small icon.
		/// </summary>
		/// <param name="hinst">
		///     A handle to the instance of the application that created the class. To retrieve information about classes defined by the system (such as buttons
		///     or list boxes), set this parameter to NULL.
		/// </param>
		/// <param name="lpszClass">
		///     The class name. The name must be that of a preregistered class or a class registered by a previous call to the <see cref="RegisterClass" /> or
		///     <see cref="RegisterClassEx" /> function. Alternatively, this parameter can be a class atom created by a previous call to
		///     <see cref="RegisterClass" /> or <see cref="RegisterClassEx" />. The atom must be in the low-order word of <paramref name="lpszClass" />; the
		///     high-order word must be zero.
		/// </param>
		/// <param name="lpwcx">
		///     A pointer to a <see cref="WNDCLASSEX" /> structure that receives the information about the class.
		/// </param>
		/// <returns>
		///     <para>If the function finds a matching class and successfully copies the data, the return value is nonzero.</para>
		///     <para>
		///         If the function does not find a matching class and successfully copy the data, the return value is zero. To get extended error information,
		///         call GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     Class atoms are created using the <see cref="RegisterClass" /> or <see cref="RegisterClassEx" /> function, not the GlobalAddAtom
		///     function.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetClassInfoEx")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool GetClassInfoEx([In] IntPtr hinst, [In] string lpszClass, [Out] out WNDCLASSEX lpwcx);

		/// <summary>Retrieves the window handle to the active window attached to the calling thread's message queue.</summary>
		/// <returns>The return value is the handle to the active window attached to the calling thread's message queue. Otherwise, the return value is NULL.</returns>
		/// <remarks>
		///     <para>
		///         To get the handle to the foreground window, you can use <see cref="GetForegroundWindow" />.
		///     </para>
		///     <para>
		///         To get the window handle to the active window in the message queue for another thread, use <see cref="GetGUIThreadInfo" />.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetActiveWindow")]
		public static extern IntPtr GetActiveWindow();

		/// <summary>
		///     The <see cref="EnableScrollBar" /> function enables or disables one or both scroll bar arrows.
		/// </summary>
		/// <param name="hWnd">
		///     Handle to a window or a scroll bar control, depending on the value of the <paramref name="wSBflags" /> parameter.
		/// </param>
		/// <param name="wSBflags">
		///     <para>Specifies the scroll bar type. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>SB_BOTH</term>
		///             <description>
		///                 Enables or disables the arrows on the horizontal and vertical scroll bars associated with the specified window. The
		///                 <paramref name="hWnd" /> parameter must be the handle to the window.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SB_CTL</term>
		///             <description>
		///                 Indicates that the scroll bar is a scroll bar control. The <paramref name="hWnd" /> must be the handle to the scroll bar control.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SB_HORZ</term>
		///             <description>
		///                 Enables or disables the arrows on the horizontal scroll bar associated with the specified window. The <paramref name="hWnd" />
		///                 parameter must be the handle to the window.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SB_VERT</term>
		///             <description>
		///                 Enables or disables the arrows on the vertical scroll bar associated with the specified window. The <paramref name="hWnd" />
		///                 parameter must be the handle to the window.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="wArrows">
		///     <para>
		///         Specifies whether the scroll bar arrows are enabled or disabled and indicates which arrows are enabled or disabled. This parameter can be one
		///         of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>ESB_DISABLE_BOTH</term>
		///             <description>Disables both arrows on a scroll bar.</description>
		///         </item>
		///         <item>
		///             <term>ESB_DISABLE_DOWN</term>
		///             <description>Disables the down arrow on a vertical scroll bar.</description>
		///         </item>
		///         <item>
		///             <term>ESB_DISABLE_LEFT</term>
		///             <description>Disables the left arrow on a horizontal scroll bar.</description>
		///         </item>
		///         <item>
		///             <term>ESB_DISABLE_LTUP</term>
		///             <description>Disables the left arrow on a horizontal scroll bar or the up arrow of a vertical scroll bar.</description>
		///         </item>
		///         <item>
		///             <term>ESB_DISABLE_RIGHT</term>
		///             <description>Disables the right arrow on a horizontal scroll bar.</description>
		///         </item>
		///         <item>
		///             <term>ESB_DISABLE_RTDN</term>
		///             <description>Disables the right arrow on a horizontal scroll bar or the down arrow of a vertical scroll bar.</description>
		///         </item>
		///         <item>
		///             <term>ESB_DISABLE_UP</term>
		///             <description>Disables the up arrow on a vertical scroll bar.</description>
		///         </item>
		///         <item>
		///             <term>ESB_ENABLE_BOTH</term>
		///             <description>Enables both arrows on a scroll bar.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the arrows are enabled or disabled as specified, the return value is nonzero.</para>
		///     <para>
		///         If the arrows are already in the requested state or an error occurs, the return value is zero. To get extended error information, call
		///         GetLastError.
		///     </para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "EnableScrollBar")]
		public static extern bool EnableScrollBar([In] IntPtr hWnd, SB wSBflags, ESB wArrows);

		/// <summary>
		///     Retrieves the current selection from a single-selection list box. It assumes that the list box has been filled by the <see cref="DlgDirList" />
		///     function and that the selection is a drive letter, filename, or directory name.
		/// </summary>
		/// <param name="hDlg">A handle to the dialog box that contains the list box.</param>
		/// <param name="lpString">A pointer to a buffer that receives the selected path.</param>
		/// <param name="nCount">
		///     The length, in TCHARs, of the buffer pointed to by <paramref name="lpString" />.
		/// </param>
		/// <param name="nIDListBox">The identifier of a list box in the dialog box.</param>
		/// <returns>
		///     <para>If the current selection is a directory name, the return value is nonzero.</para>
		///     <para>If the current selection is not a directory name, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="DlgDirSelectEx" /> function copies the selection to the buffer pointed to by the <paramref name="lpString" /> parameter. If
		///         the current selection is a directory name or drive letter, <see cref="DlgDirSelectEx" /> removes the enclosing square brackets (and hyphens,
		///         for drive letters), so that the name or letter is ready to be inserted into a new path. If there is no selection,
		///         <paramref name="lpString" /> does not change.
		///     </para>
		///     <para>If the string is as long or longer than the buffer, the buffer will contain the truncated string with a terminating null character.</para>
		///     <para>
		///         <see cref="DlgDirSelectEx" /> sends LB_GETCURSEL and LB_GETTEXT messages to the list box. The function does not
		///         allow more than one filename to be returned from a list box. The list box must not be a multiple-selection list box. If it is, this function
		///         does not return a zero value and <paramref name="lpString" /> remains unchanged.
		///     </para>
		///     <para>
		///         Windows 95 or later: <see cref="DlgDirSelectEx" /> is supported by the Microsoft Layer for Unicode. To use this, you must add certain files
		///         to your application, as outlined in Microsoft Layer for Unicode on Windows Me/98/95 Systems.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DlgDirSelectEx")]
		public static extern bool DlgDirSelectEx([In] IntPtr hDlg, [Out] StringBuilder lpString, int nCount, int nIDListBox);

		/// <summary>
		///     Creates a modal dialog box from a dialog box template resource. Before displaying the dialog box, the function passes an application-defined
		///     value to the dialog box procedure as the lParam parameter of the <see cref="WM.WM_INITDIALOG" /> message. An application can
		///     use this value to initialize dialog box controls.
		/// </summary>
		/// <param name="hInstance">A handle to the module whose executable file contains the dialog box template.</param>
		/// <param name="lpTemplateName">
		///     The dialog box template. This parameter is either the pointer to a null-terminated character string that specifies the name of the dialog box
		///     template or an integer value that specifies the resource identifier of the dialog box template. If the parameter specifies a resource identifier,
		///     its high-order word must be zero and its low-order word must contain the identifier. You can use the MAKEINTRESOURCE macro to
		///     create this value.
		/// </param>
		/// <param name="hWndParent">A handle to the window that owns the dialog box.</param>
		/// <param name="lpDialogFunc">
		///     A pointer to the dialog box procedure. For more information about the dialog box procedure, see <see cref="DialogProc" />.
		/// </param>
		/// <param name="dwInitParam">
		///     The value to pass to the dialog box in the lParam parameter of the <see cref="WM.WM_INITDIALOG" /> message.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is the value of the <paramref name="nResult" /> parameter specified in the call to the
		///         <see cref="EndDialog" /> function used to terminate the dialog box.
		///     </para>
		///     <para>
		///         If the function fails because the <paramref name="hWndParent" /> parameter is invalid, the return value is zero. The function returns zero in
		///         this case for compatibility with previous versions of Windows. If the function fails for any other reason, the return value is –1. To get
		///         extended error information, call GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="DialogBoxParam" /> function uses the <see cref="CreateWindowEx" /> function to create the dialog box.
		///         <see cref="DialogBoxParam" /> then sends a <see cref="WM.WM_INITDIALOG" /> message (and a <see cref="WM.WM_SETFONT" /> message if the
		///         template specifies the <see cref="DS_SETFONT" /> or DS_SHELLFONT style) to the dialog box procedure. The function displays the dialog box
		///         (regardless of whether the template specifies the <see cref="WS.WS_VISIBLE" /> style), disables the owner window, and starts its own message
		///         loop to retrieve and dispatch messages for the dialog box.
		///     </para>
		///     <para>
		///         When the dialog box procedure calls the <see cref="EndDialog" /> function, <see cref="DialogBoxParam" /> destroys the dialog box, ends the
		///         message loop, enables the owner window (if previously enabled), and returns the <paramref name="nResult" /> parameter specified by the dialog
		///         box procedure when it called <see cref="EndDialog" />.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DialogBoxParam")]
		public static extern int DialogBoxParam(
			[In] IntPtr hInstance, [In] string lpTemplateName, [In] IntPtr hWndParent, DialogProc lpDialogFunc, [MarshalAs(UnmanagedType.SysInt)] int dwInitParam);

		/// <summary>
		///     Calls the default raw input procedure to provide default processing for any raw input messages that an application does not process. This
		///     function ensures that every message is processed. <see cref="DefRawInputProc" /> is called with the same parameters received by the window
		///     procedure.
		/// </summary>
		/// <param name="paRawInput">
		///     An array of <see cref="RAWINPUT" /> structures.
		/// </param>
		/// <param name="nInput">
		///     The number of <see cref="RAWINPUT" /> structures pointed to by <paramref name="paRawInput" />.
		/// </param>
		/// <param name="cbSizeHeader">
		///     The size, in bytes, of the <see cref="RAWINPUTHEADER" /> structure.
		/// </param>
		/// <returns>
		///     If successful, the function returns <see cref="S_OK" />. Otherwise it returns an error value.
		/// </returns>
		[return: MarshalAs(UnmanagedType.SysInt)]
		[DllImport("user32.dll", EntryPoint = "DefRawInputProc")]
		public static extern int DefRawInputProc(ref RAWINPUT[] paRawInput, int nInput, uint cbSizeHeader);

		/// <summary>Frees all Dynamic Data Exchange Management Library (DDEML) resources associated with the calling application.</summary>
		/// <param name="idInst">
		///     The application instance identifier obtained by a previous call to the <see cref="DdeInitialize" /> function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <see cref="DdeUninitialize" /> terminates any conversations currently open for the application.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DdeUninitialize")]
		public static extern bool DdeUninitialize(uint idInst);

		/// <summary>Unaccesses a Dynamic Data Exchange (DDE) object. An application must call this function after it has finished accessing the object.</summary>
		/// <param name="hData">A handle to the DDE object.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DdeUnaccessData")]
		public static extern bool DdeUnaccessData(IntPtr hData);

		/// <summary>Copies text associated with a string handle into a buffer.</summary>
		/// <param name="idInst">
		///     The application instance identifier obtained by a previous call to the <see cref="DdeInitialize" /> function.
		/// </param>
		/// <param name="hsz">
		///     A handle to the string to copy. This handle must have been created by a previous call to the <see cref="DdeCreateStringHandle" /> function.
		/// </param>
		/// <param name="psz">A pointer to a buffer that receives the string. To obtain the length of the string, this parameter should be set to NULL.</param>
		/// <param name="cchMax">
		///     The length, in characters, of the buffer pointed to by the <paramref name="psz" /> parameter. For the ANSI version of the function, this is the
		///     number of bytes; for the Unicode version, this is the number of characters. If the string is longer than ( <paramref name="cchMax" />– 1), it
		///     will be truncated. If the <paramref name="psz" /> parameter is set to NULL, this parameter is ignored.
		/// </param>
		/// <param name="iCodePage">
		///     The code page used to render the string. This value should be either <see cref="CP_WINANSI" /> or <see cref="CP_WINUNICODE" />.
		/// </param>
		/// <returns>
		///     If the <paramref name="psz" /> parameter specified a valid pointer, the return value is the length, in characters, of the returned text (not
		///     including the terminating null character). If the <paramref name="psz" /> parameter specified a NULL pointer, the return value is the length of
		///     the text associated with the <paramref name="hsz" /> parameter (not including the terminating null character). If an error occurs, the return
		///     value is 0L.
		/// </returns>
		/// <remarks>
		///     <para>
		///         The string returned in the buffer is always null-terminated. If the string is longer than ( <paramref name="cchMax" />– 1), only the first (
		///         <paramref name="cchMax" />– 1) characters of the string are copied.
		///     </para>
		///     <para>
		///         If the <paramref name="psz" /> parameter is NULL, the <see cref="DdeQueryString" /> function obtains the length, in bytes, of the string
		///         associated with the string handle. The length does not include the terminating null character.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DdeQueryString")]
		public static extern uint DdeQueryString(uint idInst, IntPtr hsz, StringBuilder psz, uint cchMax, int iCodePage);

		/// <summary>
		///     Retrieves the most recent error code set by the failure of a Dynamic Data Exchange Management Library (DDEML) function and resets the error code
		///     to DMLERR_NO_ERROR.
		/// </summary>
		/// <param name="idInst">
		///     The application instance identifier obtained by a previous call to the <see cref="DdeInitialize" /> function.
		/// </param>
		/// <returns>If the function succeeds, the return value is the last error code, which can be one of the following values.</returns>
		[DllImport("user32.dll", EntryPoint = "DdeGetLastError")]
		public static extern uint DdeGetLastError(uint idInst);

		/// <summary>
		///     Creates an overlapped, pop-up, or child window with an extended window style; otherwise, this function is identical to the
		///     CreateWindow function. For more information about creating a window and for full descriptions of the other parameters of
		///     <see cref="CreateWindowEx" />, see CreateWindow.
		/// </summary>
		/// <param name="dwExStyle">The extended window style of the window being created. For a list of possible values,see Extended Window Styles.</param>
		/// <param name="lpClassName">
		///     A <see cref="null" />-terminated string or a class atom created by a previous call to the <see cref="RegisterClass" /> or
		///     <see cref="RegisterClassEx" /> function. The atom must be in the low-order word of <paramref name="lpClassName" />; the high-order word must be
		///     zero. If <paramref name="lpClassName" /> is a string, it specifies the window class name. The class name can be any name registered with
		///     <see cref="RegisterClass" /> or <see cref="RegisterClassEx" />, provided that the module that registers the class is also the module that creates
		///     the window. The class name can also be any of the predefined system class names.
		/// </param>
		/// <param name="lpWindowName">
		///     The window name. If the window style specifies a title bar, the window title pointed to by <paramref name="lpWindowName" /> is displayed in the
		///     title bar. When using CreateWindow to create controls, such as buttons, check boxes, and static controls, use
		///     <paramref name="lpWindowName" /> to specify the text of the control. When creating a static control with the <see cref="SS_ICON" /> style, use
		///     <paramref name="lpWindowName" /> to specify the icon name or identifier. To specify an identifier, use the syntax "#<paramref name="num" />".
		/// </param>
		/// <param name="dwStyle">
		///     The style of the window being created. This parameter can be a combination of the window style values, plus the control styles indicated in the
		///     Remarks section.
		/// </param>
		/// <param name="x">
		///     The initial horizontal position of the window. For an overlapped or pop-up window, the <paramref name="x" /> parameter is the initial
		///     x-coordinate of the window's upper-left corner, in screen coordinates. For a child window, <paramref name="x" /> is the x-coordinate of the
		///     upper-left corner of the window relative to the upper-left corner of the parent window's client area. If <paramref name="x" /> is set to
		///     <see cref="CW_USEDEFAULT" />, the system selects the default position for the window's upper-left corner and ignores the <paramref name="y" />
		///     parameter. <see cref="CW_USEDEFAULT" /> is valid only for overlapped windows; if it is specified for a pop-up or child window, the
		///     <paramref name="x" /> and <paramref name="y" /> parameters are set to zero.
		/// </param>
		/// <param name="y">
		///     <para>
		///         The initial vertical position of the window. For an overlapped or pop-up window, the <paramref name="y" /> parameter is the initial
		///         y-coordinate of the window's upper-left corner, in screen coordinates. For a child window, <paramref name="y" /> is the initial y-coordinate
		///         of the upper-left corner of the child window relative to the upper-left corner of the parent window's client area. For a list box
		///         <paramref name="y" /> is the initial y-coordinate of the upper-left corner of the list box's client area relative to the upper-left corner of
		///         the parent window's client area.
		///     </para>
		///     <para>
		///         If an overlapped window is created with the <see cref="WS.WS_VISIBLE" /> style bit set and the <paramref name="x" /> parameter is set to
		///         <see cref="CW_USEDEFAULT" />, then the <paramref name="y" /> parameter determines how the window is shown. If the <paramref name="y" />
		///         parameter is <see cref="CW_USEDEFAULT" />, then the window manager calls <see cref="ShowWindow" /> with the <see cref="SW_SHOW" /> flag after
		///         the window has been created. If the <paramref name="y" /> parameter is some other value, then the window manager calls
		///         <see cref="ShowWindow" /> with that value as the <paramref name="nCmdShow" /> parameter.
		///     </para>
		/// </param>
		/// <param name="nWidth">
		///     The width, in device units, of the window. For overlapped windows, <paramref name="nWidth" /> is the window's width, in screen coordinates, or
		///     <see cref="CW_USEDEFAULT" />. If <paramref name="nWidth" /> is <see cref="CW_USEDEFAULT" />, the system selects a default width and height for
		///     the window; the default width extends from the initial x-coordinates to the right edge of the screen; the default height extends from the initial
		///     y-coordinate to the top of the icon area. <see cref="CW_USEDEFAULT" /> is valid only for overlapped windows; if <see cref="CW_USEDEFAULT" /> is
		///     specified for a pop-up or child window, the <paramref name="nWidth" /> and <paramref name="nHeight" /> parameter are set to zero.
		/// </param>
		/// <param name="nHeight">
		///     The height, in device units, of the window. For overlapped windows, <paramref name="nHeight" /> is the window's height, in screen coordinates. If
		///     the <paramref name="nWidth" /> parameter is set to <see cref="CW_USEDEFAULT" />, the system ignores <paramref name="nHeight" />.
		/// </param>
		/// <param name="hWndParent">
		///     <para>
		///         A handle to the parent or owner window of the window being created. To create a child window or an owned window, supply a valid window
		///         handle. This parameter is optional for pop-up windows.
		///     </para>
		///     <para>
		///         To create a message-only window, supply <see cref="HWND_MESSAGE" /> or a handle to an existing message-only window.
		///     </para>
		/// </param>
		/// <param name="hMenu">
		///     A handle to a menu, or specifies a child-window identifier, depending on the window style. For an overlapped or pop-up window,
		///     <paramref name="hMenu" /> identifies the menu to be used with the window; it can be NULL if the class menu is to be used. For a child window,
		///     <paramref name="hMenu" /> specifies the child-window identifier, an integer value used by a dialog box control to notify its parent about events.
		///     The application determines the child-window identifier; it must be unique for all child windows with the same parent window.
		/// </param>
		/// <param name="hInstance">A handle to the instance of the module to be associated with the window.</param>
		/// <param name="lpParam">
		///     <para>
		///         Pointer to a value to be passed to the window through the <see cref="CREATESTRUCT" /> structure (<see cref="lpCreateParams" /> member)
		///         pointed to by the <paramref name="lParam" /> param of the <see cref="WM.WM_CREATE" /> message. This message is sent to the created window by
		///         this function before it returns.
		///     </para>
		///     <para>
		///         If an application calls CreateWindow to create a MDI client window, <paramref name="lpParam" /> should point to a
		///         <see cref="CLIENTCREATESTRUCT" /> structure. If an MDI client window calls CreateWindow to create an MDI child window,
		///         <paramref name="lpParam" /> should point to a <see cref="MDICREATESTRUCT" /> structure. <paramref name="lpParam" /> may be NULL if no
		///         additional data is needed.
		///     </para>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to the new window.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		///     <para>This function typically fails for one of the following reasons:</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="CreateWindowEx" /> function sends <see cref="WM.WM_NCCREATE" />, <see cref="WM.WM_NCCALCSIZE" />, and
		///         <see cref="WM.WM_CREATE" />
		///         messages to the window being created.
		///     </para>
		///     <para>
		///         If the created window is a child window, its default position is at the bottom of the Z-order. If the created window is a top-level window,
		///         its default position is at the top of the Z-order (but beneath all topmost windows unless the created window is itself topmost).
		///     </para>
		///     <para>For information on controlling whether the Taskbar displays a button for the created window, see Managing Taskbar Buttons.</para>
		///     <para>
		///         For information on removing a window, see the <see cref="DestroyWindow" /> function.
		///     </para>
		///     <para>
		///         The following predefined control classes can be specified in the <paramref name="lpClassName" /> parameter. Note the corresponding control
		///         styles you can use in the <paramref name="dwStyle" /> parameter.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CreateWindowEx")]
		public static extern IntPtr CreateWindowEx(
			WS_EX dwExStyle, [In] string lpClassName, [In] string lpWindowName, WS dwStyle, int X, int Y, int nWidth, int nHeight, [In] IntPtr hWndParent,
			[In] IntPtr hMenu, [In] IntPtr hInstance, [In] IntPtr lpParam);

		/// <summary>
		///     Creates a drop-down menu, submenu, or shortcut menu. The menu is initially empty. You can insert or append menu items by using the
		///     <see cref="InsertMenuItem" /> function. You can also use the <see cref="InsertMenu" /> function to insert menu items and the
		///     <see cref="AppendMenu" /> function to append menu items.
		/// </summary>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to the newly created menu.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The application can add the new menu to an existing menu, or it can display a shortcut menu by calling the <see cref="TrackPopupMenuEx" /> or
		///         <see cref="TrackPopupMenu" /> functions.
		///     </para>
		///     <para>
		///         Resources associated with a menu that is assigned to a window are freed automatically. If the menu is not assigned to a window, an
		///         application must free system resources associated with the menu before closing. An application frees menu resources by calling the
		///         <see cref="DestroyMenu" /> function.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CreatePopupMenu")]
		public static extern IntPtr CreatePopupMenu();

		/// <summary>Passes message information to the specified window procedure.</summary>
		/// <param name="lpPrevWndFunc">
		///     The previous window procedure. If this value is obtained by calling the <see cref="GetWindowLong" /> function with the <paramref name="nIndex" />
		///     parameter set to <see cref="GWL_WNDPROC" /> or <see cref="DWL_DLGPROC" />, it is actually either the address of a window or dialog box procedure,
		///     or a special internal value meaningful only to <see cref="CallWindowProc" />.
		/// </param>
		/// <param name="hWnd">A handle to the window procedure to receive the message.</param>
		/// <param name="Msg">The message.</param>
		/// <param name="wParam">
		///     Additional message-specific information. The contents of this parameter depend on the value of the <paramref name="Msg" /> parameter.
		/// </param>
		/// <param name="lParam">
		///     Additional message-specific information. The contents of this parameter depend on the value of the <paramref name="Msg" /> parameter.
		/// </param>
		/// <returns>
		///     <para>The return value specifies the result of the message processing and depends on the message sent.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Use the <see cref="CallWindowProc" /> function for window subclassing. Usually, all windows with the same class share one window procedure. A
		///         subclass is a window or set of windows with the same class whose messages are intercepted and processed by another window procedure (or
		///         procedures) before being passed to the window procedure of the class.
		///     </para>
		///     <para>
		///         The <see cref="SetWindowLong" /> function creates the subclass by changing the window procedure associated with a particular window, causing
		///         the system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the new
		///         window procedure to the previous window procedure by calling <see cref="CallWindowProc" />. This allows the application to create a chain of
		///         window procedures.
		///     </para>
		///     <para>
		///         If <see cref="STRICT" /> is defined, the <paramref name="lpPrevWndFunc" /> parameter has the data type <see cref="WNDPROC" />. The
		///         <see cref="WNDPROC" /> type is declared as follows:
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CallWindowProc")]
		[return: MarshalAs(UnmanagedType.SysInt)]
		public static extern int CallWindowProc(
			WindowProc lpPrevWndFunc, [In] IntPtr hWnd, uint Msg, [MarshalAs(UnmanagedType.SysUInt)] uint wParam, [MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>
		///     Removes an event hook function created by a previous call to <see cref="SetWinEventHook" />.
		/// </summary>
		/// <param name="hWinEventHook">
		///     Handle to the event hook returned in the previous call to <see cref="SetWinEventHook" />.
		/// </param>
		/// <returns>
		///     <para>If successful, returns TRUE; otherwise, returns FALSE.</para>
		///     <para>Three common errors cause this function to fail:</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         This function removes the event hook specified by <paramref name="hWinEventHook" /> that prevents the corresponding callback function from
		///         receiving further event notifications. If the client's thread ends, the system automatically calls this function.
		///     </para>
		///     <para>
		///         Call this function from the same thread that installed the event hook. <see cref="UnhookWinEvent" /> fails if called from a thread different
		///         from the call that corresponds to <see cref="SetWinEventHook" />.
		///     </para>
		///     <para>
		///         If WINEVENT_INCONTEXT was specified when this event hook was installed, the system attempts to unload the corresponding DLL from all
		///         processes that loaded it. Although unloading does not occur immediately, the hook function is not called after <see cref="UnhookWinEvent" />
		///         returns. For more information on WINEVENT_INCONTEXT, see In-Context Hook Functions.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "UnhookWinEvent")]
		public static extern bool UnhookWinEvent([In] IntPtr hWinEventHook);

		/// <summary>
		///     Displays a shortcut menu at the specified location and tracks the selection of items on the menu. The shortcut menu can appear anywhere on the
		///     screen.
		/// </summary>
		/// <param name="hMenu">
		///     A handle to the shortcut menu to be displayed. The handle can be obtained by calling <see cref="CreatePopupMenu" /> to create a new shortcut
		///     menu, or by calling <see cref="GetSubMenu" /> to retrieve a handle to a submenu associated with an existing menu item.
		/// </param>
		/// <param name="uFlags">
		///     <para>Use zero of more of these flags to specify function options.</para>
		///     <para>Use one of the following flags to specify how the function positions the shortcut menu horizontally.</para>
		///     <list type="table">
		///         <item>
		///             <term>TPM_CENTERALIGN 0x0004L</term>
		///             <description>
		///                 Centers the shortcut menu horizontally relative to the coordinate specified by the <paramref name="x" /> parameter.
		///             </description>
		///         </item>
		///         <item>
		///             <term>TPM_LEFTALIGN 0x0000L</term>
		///             <description>
		///                 Positions the shortcut menu so that its left side is aligned with the coordinate specified by the <paramref name="x" /> parameter.
		///             </description>
		///         </item>
		///         <item>
		///             <term>TPM_RIGHTALIGN 0x0008L</term>
		///             <description>
		///                 Positions the shortcut menu so that its right side is aligned with the coordinate specified by the <paramref name="x" /> parameter.
		///             </description>
		///         </item>
		///     </list>
		///     <para>Use one of the following flags to specify how the function positions the shortcut menu vertically.</para>
		///     <list type="table">
		///         <item>
		///             <term>TPM_BOTTOMALIGN 0x0020L</term>
		///             <description>
		///                 Positions the shortcut menu so that its bottom side is aligned with the coordinate specified by the <paramref name="y" /> parameter.
		///             </description>
		///         </item>
		///         <item>
		///             <term>TPM_TOPALIGN 0x0000L</term>
		///             <description>
		///                 Positions the shortcut menu so that its top side is aligned with the coordinate specified by the <paramref name="y" /> parameter.
		///             </description>
		///         </item>
		///         <item>
		///             <term>TPM_VCENTERALIGN 0x0010L</term>
		///             <description>
		///                 Centers the shortcut menu vertically relative to the coordinate specified by the <paramref name="y" /> parameter.
		///             </description>
		///         </item>
		///     </list>
		///     <para>Use the following flags to control discovery of the user selection without having to set up a parent window for the menu.</para>
		///     <list type="table">
		///         <item>
		///             <term>TPM_NONOTIFY 0x0080L</term>
		///             <description>The function does not send notification messages when the user clicks a menu item.</description>
		///         </item>
		///         <item>
		///             <term>TPM_RETURNCMD 0x0100L</term>
		///             <description>The function returns the menu item identifier of the user's selection in the return value.</description>
		///         </item>
		///     </list>
		///     <para>Use one of the following flags to specify which mouse button the shortcut menu tracks.</para>
		///     <list type="table">
		///         <item>
		///             <term>TPM_LEFTBUTTON 0x0000L</term>
		///             <description>The user can select menu items with only the left mouse button.</description>
		///         </item>
		///         <item>
		///             <term>TPM_RIGHTBUTTON 0x0002L</term>
		///             <description>The user can select menu items with both the left and right mouse buttons.</description>
		///         </item>
		///     </list>
		///     <para>
		///         Use any reasonable combination of the following flags to modify the animation of a menu. For example, by selecting a horizontal and a
		///         vertical flag, you can achieve diagonal animation.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>TPM_HORNEGANIMATION 0x0800L</term>
		///             <description>Animates the menu from right to left.</description>
		///         </item>
		///         <item>
		///             <term>TPM_HORPOSANIMATION 0x0400L</term>
		///             <description>Animates the menu from left to right.</description>
		///         </item>
		///         <item>
		///             <term>TPM_NOANIMATION 0x4000L</term>
		///             <description>Displays menu without animation.</description>
		///         </item>
		///         <item>
		///             <term>TPM_VERNEGANIMATION 0x2000L</term>
		///             <description>Animates the menu from bottom to top.</description>
		///         </item>
		///         <item>
		///             <term>TPM_VERPOSANIMATION 0x1000L</term>
		///             <description>Animates the menu from top to bottom.</description>
		///         </item>
		///     </list>
		///     <para>
		///         For any animation to occur, the <see cref="SystemParametersInfo" /> function must set <see cref="SPI.SPI_SETMENUANIMATION" />. Also, all the
		///         TPM_*ANIMATION flags, except <see cref="TPM.TPM_NOANIMATION" />, are ignored if menu fade animation is on. For more information, see the
		///         <see cref="SPI.SPI_GETMENUFADE" /> flag in <see cref="SystemParametersInfo" />.
		///     </para>
		///     <para>
		///         Use the <see cref="TPM.TPM_RECURSE" /> flag to display a menu when another menu is already displayed. This is intended to support context menus
		///         within a menu.
		///     </para>
		///     <para>
		///         For right-to-left text layout, use <see cref="TPM.TPM_LAYOUTRTL" />. By default, the text layout is left-to-right.
		///     </para>
		/// </param>
		/// <param name="x">The horizontal location of the shortcut menu, in screen coordinates.</param>
		/// <param name="y">The vertical location of the shortcut menu, in screen coordinates.</param>
		/// <param name="nReserved">Reserved; must be zero.</param>
		/// <param name="hWnd">
		///     A handle to the window that owns the shortcut menu. This window receives all messages from the menu. The window does not receive a
		///     <see cref="WM.WM_COMMAND" /> message from the menu until the function returns. If you specify TPM_NONOTIFY in the <paramref name="uFlags" />
		///     parameter, the function does not send messages to the window identified by <paramref name="hWnd" />. However, you must still pass a window handle
		///     in <paramref name="hWnd" />. It can be any window handle from your application.
		/// </param>
		/// <param name="prcRect">Ignored.</param>
		/// <returns>
		///     <para>
		///         If you specify <see cref="TPM.TPM_RETURNCMD" /> in the <paramref name="uFlags" /> parameter, the return value is the menu-item identifier of the
		///         item that the user selected. If the user cancels the menu without making a selection, or if an error occurs, the return value is zero.
		///     </para>
		///     <para>
		///         If you do not specify <see cref="TPM.TPM_RETURNCMD" /> in the <paramref name="uFlags" /> parameter, the return value is nonzero if the function
		///         succeeds and zero if it fails. To get extended error information, call GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Call <see cref="GetSystemMetrics" /> with <see cref="SM.SM_MENUDROPALIGNMENT" /> to determine the correct horizontal alignment flag (
		///         <see cref="TPM.TPM_LEFTALIGN" /> or <see cref="TPM.TPM_RIGHTALIGN" />) and/or horizontal animation direction flag (<see cref="TPM.TPM_HORPOSANIMATION" />
		///         or <see cref="TPM.TPM_HORNEGANIMATION" />) to pass to <see cref="TrackPopupMenu" /> or <see cref="TrackPopupMenuEx" />. This is essential for
		///         creating an optimal user experience, especially when developing Microsoft Tablet PC applications.
		///     </para>
		///     <para>
		///         To specify an area of the screen that the menu should not overlap, use the <see cref="TrackPopupMenuEx" /> function
		///     </para>
		///     <para>
		///         To display a context menu for a notification icon, the current window must be the foreground window before the application calls
		///         <see cref="TrackPopupMenu" /> or <see cref="TrackPopupMenuEx" />. Otherwise, the menu will not disappear when the user clicks outside of the
		///         menu or the window that created the menu (if it is visible). If the current window is a child window, you must set the (top-level) parent
		///         window as the foreground window.
		///     </para>
		///     <para>
		///         However, when the current window is the foreground window, the second time this menu is displayed, it appears and then immediately
		///         disappears. To correct this, you must force a task switch to the application that called <see cref="TrackPopupMenu" />. This is done by
		///         posting a benign message to the window or thread, as shown in the following code sample:
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "TrackPopupMenu")]
		public static extern bool TrackPopupMenu([In] IntPtr hMenu, TPM uFlags, int x, int y, int nReserved, [In] IntPtr hWnd, [In] IntPtr prcRect);

		/// <summary>
		///     The <see cref="TabbedTextOut" /> function writes a character string at a specified location, expanding tabs to the values specified in an array
		///     of tab-stop positions. Text is written in the currently selected font, background color, and text color.
		/// </summary>
		/// <param name="hDC">A handle to the device context.</param>
		/// <param name="X">The x-coordinate of the starting point of the string, in logical units.</param>
		/// <param name="Y">The y-coordinate of the starting point of the string, in logical units.</param>
		/// <param name="lpString">
		///     A pointer to the character string to draw. The string does not need to be zero-terminated, since <paramref name="nCount" /> specifies the length
		///     of the string.
		/// </param>
		/// <param name="nCount">
		///     The length of the string pointed to by <paramref name="lpString" />.
		/// </param>
		/// <param name="nTabPositions">The number of values in the array of tab-stop positions.</param>
		/// <param name="lpnTabStopPositions">
		///     A pointer to an array containing the tab-stop positions, in logical units. The tab stops must be sorted in increasing order; the smallest x-value
		///     should be the first item in the array.
		/// </param>
		/// <param name="nTabOrigin">The x-coordinate of the starting position from which tabs are expanded, in logical units.</param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is the dimensions, in logical units, of the string. The height is in the high-order word and the
		///         width is in the low-order word.
		///     </para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If the <paramref name="nTabPositions" /> parameter is zero and the <paramref name="lpnTabStopPositions" /> parameter is NULL, tabs are
		///         expanded to eight times the average character width.
		///     </para>
		///     <para>
		///         If <paramref name="nTabPositions" /> is 1, the tab stops are separated by the distance specified by the first value in the
		///         <paramref name="lpnTabStopPositions" /> array.
		///     </para>
		///     <para>
		///         If the <paramref name="lpnTabStopPositions" /> array contains more than one value, a tab stop is set for each value in the array, up to the
		///         number specified by <paramref name="nTabPositions" />.
		///     </para>
		///     <para>
		///         The <paramref name="nTabOrigin" /> parameter allows an application to call the <see cref="TabbedTextOut" /> function several times for a
		///         single line. If the application calls <see cref="TabbedTextOut" /> more than once with the <paramref name="nTabOrigin" /> set to the same
		///         value each time, the function expands all tabs relative to the position specified by <paramref name="nTabOrigin" />.
		///     </para>
		///     <para>
		///         By default, the current position is not used or updated by the <see cref="TabbedTextOut" /> function. If an application needs to update the
		///         current position when it calls <see cref="TabbedTextOut" />, the application can call the <see cref="SetTextAlign" /> function with the
		///         <paramref name="wFlags" /> parameter set to TA_UPDATECP. When this flag is set, the system ignores the <paramref name="X" /> and
		///         <paramref name="Y" /> parameters on subsequent calls to the <see cref="TabbedTextOut" /> function, using the current position instead.
		///     </para>
		///     <para>
		///         Note:  For Windows Vista and later, <see cref="TabbedTextOut" /> ignores text alignment when it draws text.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "TabbedTextOut")]
		public static extern int TabbedTextOut(
			[In] IntPtr hdc, int x, int y, [In] string lpString, int chCount, int nTabPositions, [In] IntPtr lpnTabStopPositions, int nTabOrigin);

		/// <summary>
		///     Changes the text of the specified window's title bar (if it has one). If the specified window is a control, the text of the control is changed.
		///     However, <see cref="SetWindowText" /> cannot change the text of a control in another application.
		/// </summary>
		/// <param name="hWnd">A handle to the window or control whose text is to be changed.</param>
		/// <param name="lpString">The new title or control text.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If the target window is owned by the current process, <see cref="SetWindowText" /> causes a <see cref="WM.WM_SETTEXT" /> message to be sent
		///         to the specified window or control. If the control is a list box control created with the <see cref="WS_CAPTION" /> style, however,
		///         <see cref="SetWindowText" /> sets the text for the control, not for the list box entries.
		///     </para>
		///     <para>
		///         To set the text of a control in another process, send the <see cref="WM.WM_SETTEXT" /> message directly instead of calling
		///         <see cref="SetWindowText" />.
		///     </para>
		///     <para>
		///         The <see cref="SetWindowText" /> function does not expand tab characters (ASCII code 0x09). Tab characters are displayed as vertical bar (|)
		///         characters.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetWindowText")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool SetWindowText([In] IntPtr hWnd, [In] string lpString);

		/// <summary>
		///     <para>
		///         Changes an attribute of the specified window. The function also sets the 32-bit (long) value at the specified offset into the extra window
		///         memory.
		///     </para>
		///     <para>
		///         Note:  This function has been superseded by the <see cref="SetWindowLongPtr" /> function. To write code that is compatible with
		///         both 32-bit and 64-bit versions of Windows, use the <see cref="SetWindowLongPtr" /> function.
		///     </para>
		/// </summary>
		/// <param name="hWnd">A handle to the window and, indirectly, the class to which the window belongs.</param>
		/// <param name="nIndex">
		///     <para>
		///         The zero-based offset to the value to be set. Valid values are in the range zero through the number of bytes of extra window memory, minus
		///         the size of an integer. To set any other value, specify one of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>GWL_EXSTYLE -20</term>
		///             <description>Sets a new extended window style.</description>
		///         </item>
		///         <item>
		///             <term>GWL_HINSTANCE -6</term>
		///             <description>Sets a new application instance handle.</description>
		///         </item>
		///         <item>
		///             <term>GWL_ID -12</term>
		///             <description>Sets a new identifier of the child window. The window cannot be a top-level window.</description>
		///         </item>
		///         <item>
		///             <term>GWL_STYLE -16</term>
		///             <description>Sets a new window style.</description>
		///         </item>
		///         <item>
		///             <term>GWL_USERDATA -21</term>
		///             <description>
		///                 Sets the user data associated with the window. This data is intended for use by the application that created the window. Its value is
		///                 initially zero.
		///             </description>
		///         </item>
		///         <item>
		///             <term>GWL_WNDPROC -4</term>
		///             <description>
		///                 <para>Sets a new address for the window procedure.</para>
		///                 <para>You cannot change this attribute if the window does not belong to the same process as the calling thread.</para>
		///             </description>
		///         </item>
		///     </list>
		///     <para>
		///         The following values are also available when the <paramref name="hWnd" /> parameter identifies a dialog box.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>DWL_DLGPROC DWLP_MSGRESULT + sizeof(LRESULT)</term>
		///             <description>Sets the new address of the dialog box procedure.</description>
		///         </item>
		///         <item>
		///             <term>DWL_MSGRESULT 0</term>
		///             <description>Sets the return value of a message processed in the dialog box procedure.</description>
		///         </item>
		///         <item>
		///             <term>DWL_USER DWLP_DLGPROC + sizeof(DLGPROC)</term>
		///             <description>Sets new extra information that is private to the application, such as handles or pointers.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="dwNewLong">The replacement value.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the previous value of the specified 32-bit integer.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		///     <para>
		///         If the previous value of the specified 32-bit integer is zero, and the function succeeds, the return value is zero, but the function does not
		///         clear the last error information. This makes it difficult to determine success or failure. To deal with this, you should clear the last error
		///         information by calling SetLastError with 0 before calling <see cref="SetWindowLong" />. Then, function failure will be
		///         indicated by a return value of zero and a GetLastError result that is nonzero.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Certain window data is cached, so changes you make using <see cref="SetWindowLong" /> will not take effect until you call the
		///         <see cref="SetWindowPos" /> function. Specifically, if you change any of the frame styles, you must call <see cref="SetWindowPos" /> with the
		///         <see cref="SWP.SWP_FRAMECHANGED" /> flag for the cache to be updated properly.
		///     </para>
		///     <para>
		///         If you use <see cref="SetWindowLong" /> with the <see cref="GWL_WNDPROC" /> index to replace the window procedure, the window procedure must
		///         conform to the guidelines specified in the description of the <see cref="WindowProc" /> callback function.
		///     </para>
		///     <para>
		///         If you use <see cref="SetWindowLong" /> with the <see cref="DWL_MSGRESULT" /> index to set the return value for a message processed by a
		///         dialog procedure, you should return TRUE directly afterward. Otherwise, if you call any function that results in your dialog procedure
		///         receiving a window message, the nested window message could overwrite the return value you set using <see cref="DWL_MSGRESULT" />.
		///     </para>
		///     <para>
		///         Calling <see cref="SetWindowLong" /> with the <see cref="GWL_WNDPROC" /> index creates a subclass of the window class used to create the
		///         window. An application can subclass a system class, but should not subclass a window class created by another process. The
		///         <see cref="SetWindowLong" /> function creates the window subclass by changing the window procedure associated with a particular window class,
		///         causing the system to call the new window procedure instead of the previous one. An application must pass any messages not processed by the
		///         new window procedure to the previous window procedure by calling <see cref="CallWindowProc" />. This allows the application to create a chain
		///         of window procedures.
		///     </para>
		///     <para>
		///         Reserve extra window memory by specifying a nonzero value in the <see cref="cbWndExtra" /> member of the <see cref="WNDCLASSEX" /> structure
		///         used with the <see cref="RegisterClassEx" /> function.
		///     </para>
		///     <para>
		///         You must not call <see cref="SetWindowLong" /> with the <see cref="GWL_HWNDPARENT" /> index to change the parent of a child window. Instead,
		///         use the <see cref="SetParent" /> function.
		///     </para>
		///     <para>
		///         If the window has a class style of <see cref="CS.CS_CLASSDC" /> or <see cref="CS.CS_OWNDC" />, do not set the extended window styles
		///         <see cref="WS_EX.WS_EX_COMPOSITED" /> or <see cref="WS_EX.WS_EX_LAYERED" />.
		///     </para>
		///     <para>
		///         Calling <see cref="SetWindowLong" /> to set the style on a progressbar will reset its position.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetWindowLong")]
		public static extern int SetWindowLong([In] IntPtr hWnd, int nIndex, int dwNewLong);

		/// <summary>
		///     <para>
		///         The <see cref="SetScrollRange" /> function sets the minimum and maximum scroll box positions for the specified scroll bar.
		///     </para>
		///     <para>
		///         Note:  The <see cref="SetScrollRange" /> function is provided for backward compatibility. New applications should use the
		///         <see cref="SetScrollInfo" /> function.
		///     </para>
		/// </summary>
		/// <param name="hWnd">
		///     Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the <paramref name="nBar" /> parameter.
		/// </param>
		/// <param name="nBar">
		///     <para>Specifies the scroll bar to be set. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>SB_CTL</term>
		///             <description>
		///                 Sets the range of a scroll bar control. The <paramref name="hWnd" /> parameter must be the handle to the scroll bar control.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SB_HORZ</term>
		///             <description>Sets the range of a window's standard horizontal scroll bar.</description>
		///         </item>
		///         <item>
		///             <term>SB_VERT</term>
		///             <description>Sets the range of a window's standard vertical scroll bar.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="nMinPos">Specifies the minimum scrolling position.</param>
		/// <param name="nMaxPos">Specifies the maximum scrolling position.</param>
		/// <param name="bRedraw">
		///     Specifies whether the scroll bar should be redrawn to reflect the change. If this parameter is TRUE, the scroll bar is redrawn. If it is FALSE,
		///     the scroll bar is not redrawn.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         You can use <see cref="SetScrollRange" /> to hide the scroll bar by setting <paramref name="nMinPos" /> and <paramref name="nMaxPos" /> to
		///         the same value. An application should not call the <see cref="SetScrollRange" /> function to hide a scroll bar while processing a scroll bar
		///         message. New applications should use the <see cref="ShowScrollBar" /> function to hide the scroll bar.
		///     </para>
		///     <para>
		///         If the call to <see cref="SetScrollRange" /> immediately follows a call to the <see cref="SetScrollPos" /> function, the
		///         <paramref name="bRedraw" /> parameter in <see cref="SetScrollPos" /> must be zero to prevent the scroll bar from being drawn twice.
		///     </para>
		///     <para>
		///         The default range for a standard scroll bar is 0 through 100. The default range for a scroll bar control is empty (both the
		///         <paramref name="nMinPos" /> and <paramref name="nMaxPos" /> parameter values are zero). The difference between the values specified by the
		///         <paramref name="nMinPos" /> and <paramref name="nMaxPos" /> parameters must not be greater than the value of MAXLONG.
		///     </para>
		///     <para>
		///         Because the messages that indicate scroll bar position, <see cref="WM.WM_HSCROLL" /> and <see cref="WM.WM_VSCROLL" />, are limited to 16 bits
		///         of position data, applications that rely solely on those messages for position data have a practical maximum value of 65,535 for the
		///         <see cref="SetScrollRange" /> function's <paramref name="nMaxPos" /> parameter.
		///     </para>
		///     <para>
		///         However, because the <see cref="SetScrollInfo" />, <see cref="SetScrollPos" />, <see cref="SetScrollRange" />, <see cref="GetScrollInfo" />,
		///         <see cref="GetScrollPos" />, and <see cref="GetScrollRange" /> functions support 32-bit scroll bar position data, there is a way to
		///         circumvent the 16-bit barrier of the <see cref="WM.WM_HSCROLL" /> and <see cref="WM.WM_VSCROLL" /> messages. See <see cref="GetScrollInfo" />
		///         for a description of the technique.
		///     </para>
		///     <para>
		///         If the <paramref name="nBar" /> parameter is SB_CTL and the window specified by the <paramref name="hWnd" /> parameter is not a system scroll
		///         bar control, the system sends the <see cref="SBM_SETRANGE" /> message to the window to set scroll bar information. This allows
		///         <see cref="SetScrollRange" /> to operate on a custom control that mimics a scroll bar. If the window does not handle the
		///         <see cref="SBM_SETRANGE" /> message, the <see cref="SetScrollRange" /> function fails.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetScrollRange")]
		public static extern bool SetScrollRange([In] IntPtr hWnd, int nBar, int nMinPos, int nMaxPos, [MarshalAs(UnmanagedType.Bool)] bool bRedraw);

		/// <summary>
		///     <para>Sets the last-error code.</para>
		///     <para>
		///         Currently, this function is identical to the SetLastError function. The second parameter is ignored.
		///     </para>
		/// </summary>
		/// <param name="dwErrCode">The last-error code for the thread.</param>
		/// <param name="dwType">This parameter is ignored.</param>
		/// <returns>This function does not return a value.</returns>
		/// <remarks>
		///     <para>The last-error code is kept in thread local storage so that multiple threads do not overwrite each other's values.</para>
		///     <para>
		///         Most functions call SetLastError or <see cref="SetLastErrorEx" /> only when they fail. However, some system functions call
		///         SetLastError or <see cref="SetLastErrorEx" /> under conditions of success; those cases are noted in each function's
		///         documentation.
		///     </para>
		///     <para>Applications can optionally retrieve the value set by this function by using the GetLastError function immediately after a function fails.</para>
		///     <para>
		///         Error codes are 32-bit values (bit 31 is the most significant bit). Bit 29 is reserved for application-defined error codes; no system error
		///         code has this bit set. If you are defining an error code for your application, set this bit to indicate that the error code has been defined
		///         by the application and to ensure that your error code does not conflict with any system-defined error codes.
		///     </para>
		///     <para>
		///         <see cref="Windows Phone 8:" /> This API is supported.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetLastErrorEx")]
		public static extern void SetLastErrorEx(uint dwErrCode, uint dwType);

		/// <summary>
		///     The <see cref="ScrollWindowEx" /> function scrolls the contents of the specified window's client area.
		/// </summary>
		/// <param name="hWnd">Handle to the window where the client area is to be scrolled.</param>
		/// <param name="dx">Specifies the amount, in device units, of horizontal scrolling. This parameter must be a negative value to scroll to the left.</param>
		/// <param name="dy">Specifies the amount, in device units, of vertical scrolling. This parameter must be a negative value to scroll up.</param>
		/// <param name="prcScroll">
		///     Pointer to a <see cref="RECT" /> structure that specifies the portion of the client area to be scrolled. If this parameter is NULL, the entire
		///     client area is scrolled.
		/// </param>
		/// <param name="prcClip">
		///     Pointer to a <see cref="RECT" /> structure that contains the coordinates of the clipping rectangle. Only device bits within the clipping
		///     rectangle are affected. Bits scrolled from the outside of the rectangle to the inside are painted; bits scrolled from the inside of the rectangle
		///     to the outside are not painted. This parameter may be NULL.
		/// </param>
		/// <param name="hrgnUpdate">Handle to the region that is modified to hold the region invalidated by scrolling. This parameter may be NULL.</param>
		/// <param name="prcUpdate">
		///     Pointer to a <see cref="RECT" /> structure that receives the boundaries of the rectangle invalidated by scrolling. This parameter may be NULL.
		/// </param>
		/// <param name="flags">
		///     <para>Specifies flags that control scrolling. This parameter can be a combination of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>SW_ERASE</term>
		///             <description>
		///                 Erases the newly invalidated region by sending a <see cref="WM.WM_ERASEBKGND" /> message to the window when specified with the
		///                 SW_INVALIDATE flag.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SW_INVALIDATE</term>
		///             <description>
		///                 Invalidates the region identified by the <paramref name="hrgnUpdate" /> parameter after scrolling.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SW_SCROLLCHILDREN</term>
		///             <description>
		///                 Scrolls all child windows that intersect the rectangle pointed to by the <paramref name="prcScroll" /> parameter. The child windows
		///                 are scrolled by the number of pixels specified by the <paramref name="dx" /> and <paramref name="dy" /> parameters. The system sends
		///                 a <see cref="WM.WM_MOVE" /> message to all child windows that intersect the <paramref name="prcScroll" /> rectangle, even if they do
		///                 not move.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SW_SMOOTHSCROLL</term>
		///             <description>
		///                 Windows 98/Me, Windows 2000/XP: Scrolls using smooth scrolling. Use the HIWORD portion of the
		///                 <paramref name="flags" /> parameter to indicate how much time, in milliseconds, the smooth-scrolling operation should take.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is SIMPLEREGION (rectangular invalidated region), COMPLEXREGION (nonrectangular invalidated
		///         region; overlapping rectangles), or NULLREGION (no invalidated region).
		///     </para>
		///     <para>If the function fails, the return value is ERROR. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If the SW_INVALIDATE and SW_ERASE flags are not specified, <see cref="ScrollWindowEx" /> does not invalidate the area that is scrolled from.
		///         If either of these flags is set, <see cref="ScrollWindowEx" /> invalidates this area. The area is not updated until the application calls the
		///         <see cref="UpdateWindow" /> function, calls the <see cref="RedrawWindow" /> function (specifying the RDW_UPDATENOW or RDW_ERASENOW flag), or
		///         retrieves the <see cref="WM.WM_PAINT" /> message from the application queue.
		///     </para>
		///     <para>
		///         If the window has the <see cref="WS.WS_CLIPCHILDREN" /> style, the returned areas specified by <paramref name="hrgnUpdate" /> and
		///         <paramref name="prcUpdate" /> represent the total area of the scrolled window that must be updated, including any areas in child windows that
		///         need updating.
		///     </para>
		///     <para>
		///         If the SW_SCROLLCHILDREN flag is specified, the system does not properly update the screen if part of a child window is scrolled. The part of
		///         the scrolled child window that lies outside the source rectangle is not erased and is not properly redrawn in its new destination. To move
		///         child windows that do not lie completely within the rectangle specified by <paramref name="prcScroll" />, use the
		///         <see cref="DeferWindowPos" /> function. The cursor is repositioned if the SW_SCROLLCHILDREN flag is set and the caret rectangle intersects
		///         the scroll rectangle.
		///     </para>
		///     <para>
		///         All input and output coordinates (for <paramref name="prcScroll" />, <paramref name="prcClip" />, <paramref name="prcUpdate" />, and
		///         <paramref name="hrgnUpdate" />) are determined as client coordinates, regardless of whether the window has the <see cref="CS.CS_OWNDC" /> or
		///         <see cref="CS.CS_CLASSDC" /> class style. Use the <see cref="LPtoDP" /> and <see cref="DPtoLP" /> functions to convert to and from logical
		///         coordinates, if necessary.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "ScrollWindowEx")]
		public static extern int ScrollWindowEx(
			[In] IntPtr hWnd, int dx, int dy, [In] ref RECT prcScroll, [In] ref RECT prcClip, [In] IntPtr hrgnUpdate, ref RECT prcUpdate, SW flags);

		/// <summary>
		///     The <see cref="ScreenToClient" /> function converts the screen coordinates of a specified point on the screen to client-area coordinates.
		/// </summary>
		/// <param name="hWnd">A handle to the window whose client area will be used for the conversion.</param>
		/// <param name="lpPoint">
		///     A pointer to a <see cref="POINT" /> structure that specifies the screen coordinates to be converted.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The function uses the window identified by the <paramref name="hWnd" /> parameter and the screen coordinates given in the
		///         <see cref="POINT" /> structure to compute client coordinates. It then replaces the screen coordinates with the client coordinates. The new
		///         coordinates are relative to the upper-left corner of the specified window's client area.
		///     </para>
		///     <para>
		///         The <see cref="ScreenToClient" /> function assumes the specified point is in screen coordinates.
		///     </para>
		///     <para>All coordinates are in device units.</para>
		///     <para>
		///         Do not use <see cref="ScreenToClient" /> when in a mirroring situation, that is, when changing from left-to-right layout to right-to-left
		///         layout. Instead, use <see cref="MapWindowPoints" />. For more information, see "Window Layout and Mirroring" in Window Features.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "ScreenToClient")]
		public static extern bool ScreenToClient([In] IntPtr hWnd, ref POINT lpPoint);

		/// <summary>
		///     Enables an application to reuse a packed Dynamic Data Exchange (DDE) <paramref name="lParam" /> parameter, rather than allocating a new packed
		///     <paramref name="lParam" />. Using this function reduces reallocations for applications that pass packed DDE messages.
		/// </summary>
		/// <param name="lParam">
		///     The <paramref name="lParam" /> parameter of the posted DDE message being reused.
		/// </param>
		/// <param name="msgIn">The identifier of the received DDE message.</param>
		/// <param name="msgOut">
		///     The identifier of the DDE message to be posted. The DDE message will reuse the packed <paramref name="lParam" /> parameter.
		/// </param>
		/// <param name="uiLo">
		///     The value to be packed into the low-order word of the reused <paramref name="lParam" /> parameter.
		/// </param>
		/// <param name="uiHi">
		///     The value to be packed into the high-order word of the reused <paramref name="lParam" /> parameter.
		/// </param>
		/// <returns>
		///     The return value is the new <paramref name="lParam" /> value.
		/// </returns>
		/// <remarks>
		///     <para>
		///         The return value must be posted as the <paramref name="lParam" /> parameter of a DDE message; it must not be used for any other purpose. Once
		///         the return value is posted, the posting application need not perform any action to dispose of the <paramref name="lParam" /> parameter.
		///     </para>
		///     <para>
		///         Use <see cref="ReuseDDElParam" /> instead of <see cref="FreeDDElParam" /> if the <paramref name="lParam" /> parameter will be reused in a
		///         responding message. <see cref="ReuseDDElParam" /> returns the <paramref name="lParam" /> appropriate for reuse.
		///     </para>
		///     <para>
		///         This function allocates or frees <paramref name="lParam" /> parameters as needed, depending on the packing requirements of the incoming and
		///         outgoing messages. This reduces reallocations in passing DDE messages.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.SysInt)]
		[DllImport("user32.dll", EntryPoint = "ReuseDDElParam")]
		public static extern int ReuseDDElParam(
			[MarshalAs(UnmanagedType.SysInt)] int lParam, uint msgIn, uint msgOut, [MarshalAs(UnmanagedType.SysUInt)] uint uiLo,
			[MarshalAs(UnmanagedType.SysUInt)] uint uiHi);

		/// <summary>
		///     Releases the mouse capture from a window in the current thread and restores normal mouse input processing. A window that has captured the mouse
		///     receives all mouse input, regardless of the position of the cursor, except when a mouse button is clicked while the cursor hot spot is in the
		///     window of another thread.
		/// </summary>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     An application calls this function after calling the <see cref="SetCapture" /> function.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "ReleaseCapture")]
		public static extern bool ReleaseCapture();

		/// <summary>Defines a system-wide hot key.</summary>
		/// <param name="hWnd">
		///     A handle to the window that will receive <see cref="WM.WM_HOTKEY" /> messages generated by the hot key. If this parameter is NULL,
		///     <see cref="WM.WM_HOTKEY" /> messages are posted to the message queue of the calling thread and must be processed in the message loop.
		/// </param>
		/// <param name="id">
		///     The identifier of the hot key. If the <paramref name="hWnd" /> parameter is NULL, then the hot key is associated with the current thread rather
		///     than with a particular window. If a hot key already exists with the same <paramref name="hWnd" /> and <paramref name="id" /> parameters, see
		///     Remarks for the action taken.
		/// </param>
		/// <param name="fsModifiers">
		///     <para>
		///         The keys that must be pressed in combination with the key specified by the <paramref name="vk" /> parameter in order to generate the
		///         <see cref="WM.WM_HOTKEY" /> message. The <paramref name="fsModifiers" /> parameter can be a combination of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MOD_ALT 0x0001</term>
		///             <description>Either ALT key must be held down.</description>
		///         </item>
		///         <item>
		///             <term>MOD_CONTROL 0x0002</term>
		///             <description>Either CTRL key must be held down.</description>
		///         </item>
		///         <item>
		///             <term>MOD_NOREPEAT 0x4000</term>
		///             <description>
		///                 <para>Changes the hotkey behavior so that the keyboard auto-repeat does not yield multiple hotkey notifications.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>MOD_SHIFT 0x0004</term>
		///             <description>Either SHIFT key must be held down.</description>
		///         </item>
		///         <item>
		///             <term>MOD_WIN 0x0008</term>
		///             <description>
		///                 Either WINDOWS key was held down. These keys are labeled with the Windows logo. Keyboard shortcuts that involve the WINDOWS key are
		///                 reserved for use by the operating system.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="vk">The virtual-key code of the hot key. See Virtual Key Codes.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         When a key is pressed, the system looks for a match against all hot keys. Upon finding a match, the system posts the
		///         <see cref="WM.WM_HOTKEY" />
		///         message to the message queue of the window with which the hot key is associated. If the hot key is not associated with a window, then the
		///         <see cref="WM.WM_HOTKEY" /> message is posted to the thread associated with the hot key.
		///     </para>
		///     <para>This function cannot associate a hot key with a window created by another thread.</para>
		///     <para>
		///         <see cref="RegisterHotKey" /> fails if the keystrokes specified for the hot key have already been registered by another hot key.
		///     </para>
		///     <para>
		///         If a hot key already exists with the same <paramref name="hWnd" /> and <paramref name="id" /> parameters, it is maintained along with the new
		///         hot key. The application must explicitly call <see cref="UnregisterHotKey" /> to unregister the old hot key.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "RegisterHotKey")]
		public static extern bool RegisterHotKey([In] IntPtr hWnd, int id, uint fsModifiers, uint vk);

		/// <summary>
		///     <para>
		///         Registers a window class for subsequent use in calls to the CreateWindow or <see cref="CreateWindowEx" /> function.
		///     </para>
		///     <para>
		///         Note:  The <see cref="RegisterClass" /> function has been superseded by the <see cref="RegisterClassEx" /> function. You can
		///         still use <see cref="RegisterClass" />, however, if you do not need to set the class small icon.
		///     </para>
		/// </summary>
		/// <param name="lpWndClass">
		///     A pointer to a <see cref="WNDCLASS" /> structure. You must fill the structure with the appropriate class attributes before passing it to the
		///     function.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is a class atom that uniquely identifies the class being registered. This atom can only be used by
		///         the CreateWindow, <see cref="CreateWindowEx" />, <see cref="GetClassInfo" />, <see cref="GetClassInfoEx" />,
		///         <see cref="FindWindow" />, <see cref="FindWindowEx" />, and <see cref="UnregisterClass" /> functions and the
		///         IActiveIMMap::FilterClientWindows method.
		///     </para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If you register the window class by using RegisterClassA, the application tells the system that the windows of the created
		///         class expect messages with text or character parameters to use the ANSI character set; if you register it by using
		///         RegisterClassW, the application requests that the system pass text parameters of messages as Unicode. The
		///         <see cref="IsWindowUnicode" /> function enables applications to query the nature of each window. For more information on ANSI and Unicode
		///         functions, see Conventions for Function Prototypes.
		///     </para>
		///     <para>All window classes that an application registers are unregistered when it terminates.</para>
		///     <para>
		///         No window classes registered by a DLL are unregistered when the DLL is unloaded. A DLL must explicitly unregister its classes when it is
		///         unloaded.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "RegisterClass")]
		public static extern ushort RegisterClass([In] ref WNDCLASS lpWndClass);

		/// <summary>Translates a specified number of characters in a string from the OEM-defined character set into either an ANSI or a wide-character string.</summary>
		/// <param name="lpszSrc">One or more characters from the OEM-defined character set.</param>
		/// <param name="lpszDst">
		///     The destination buffer, which receives the translated string. If the <see cref="OemToCharBuff" /> function is being used as an ANSI function, the
		///     string can be translated in place by setting the <paramref name="lpszDst" /> parameter to the same address as the <paramref name="lpszSrc" />
		///     parameter. This cannot be done if the <see cref="OemToCharBuff" /> function is being used as a wide-character function.
		/// </param>
		/// <param name="cchDstLength">
		///     The number of characters to be translated in the buffer identified by the <paramref name="lpszSrc" /> parameter.
		/// </param>
		/// <returns>
		///     The return value is always nonzero except when you pass the same address to <paramref name="lpszSrc" /> and <paramref name="lpszDst" /> in the
		///     wide-character version of the function. In this case the function returns zero and GetLastError returns
		///     ERROR_INVALID_ADDRESS.
		/// </returns>
		/// <remarks>
		///     Unlike the <see cref="OemToChar" /> function, the <see cref="OemToCharBuff" /> function does not stop converting characters when it encounters a
		///     null character in the buffer pointed to by <paramref name="lpszSrc" />. The <see cref="OemToCharBuff" /> function converts all
		///     <paramref name="cchDstLength" /> characters.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "OemToCharBuff")]
		public static extern bool OemToCharBuff([In] [MarshalAs(UnmanagedType.LPStr)] string lpszSrc, [Out] StringBuilder lpszDst, uint cchDstLength);

		/// <summary>
		///     Signals the system that a predefined event occurred. If any client applications have registered a hook function for the event, the system calls
		///     the client's hook function.
		/// </summary>
		/// <param name="event">Specifies the event that occurred. This value must be one of the event constants.</param>
		/// <param name="hwnd">Handle to the window that contains the object that generated the event.</param>
		/// <param name="idObject">
		///     Identifies the object that generated the event. This value is either one of the predefined object identifiers or a custom
		///     object ID value.
		/// </param>
		/// <param name="idChild">
		///     Identifies whether the event was generated by an object or by a child element of the object. If this value is CHILDID_SELF, the event was
		///     generated by the object itself. If not CHILDID_SELF, this value is the child ID of the element that generated the event.
		/// </param>
		/// <returns>This function does not return a value.</returns>
		/// <remarks>
		///     <para>
		///         Servers call this function to notify the system that an event has occurred. Microsoft Active Accessibility checks to see if any client
		///         applications have set hook procedures for the event and, if so, calls the appropriate hook procedures.
		///     </para>
		///     <para>If no hook procedures are registered for the event, the performance penalty for calling this function is minor.</para>
		///     <para>
		///         Servers call <see cref="NotifyWinEvent" /> to announce the event to the system after the event has occurred; they must never notify the
		///         system of an event before the event has occurred.
		///     </para>
		///     <para>
		///         When the client's hook procedure is called, it receives a number of parameters that describe the event and the object that generated the
		///         event. The hook procedure uses the AccessibleObjectFromEvent function to retrieve a pointer to the IAccessible
		///         interface of the object that generated the event.
		///     </para>
		///     <para>
		///         Servers may receive a <see cref="WM.WM_GETOBJECT" /> message immediately after calling this function. This can happen if there are any
		///         in-context clients that call AccessibleObjectFromEvent in the event callback.
		///     </para>
		///     <para>
		///         When servers call this function, they must be ready to handle <see cref="WM.WM_GETOBJECT" />, return an IAccessible interface
		///         pointer, and handle any of the IAccessible methods.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "NotifyWinEvent")]
		public static extern void NotifyWinEvent(uint @event, [In] IntPtr hwnd, int idObject, int idChild);

		/// <summary>
		///     <para>Translates (maps) a virtual-key code into a scan code or character value, or translates a scan code into a virtual-key code.</para>
		///     <para>
		///         To specify a handle to the keyboard layout to use for translating the specified code, use the <see cref="MapVirtualKeyEx" /> function.
		///     </para>
		/// </summary>
		/// <param name="uCode">
		///     The virtual key code or scan code for a key. How this value is interpreted depends on the value of the <paramref name="uMapType" /> parameter.
		/// </param>
		/// <param name="uMapType">
		///     <para>
		///         The translation to be performed. The value of this parameter depends on the value of the <paramref name="uCode" /> parameter.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MAPVK_VK_TO_CHAR 2</term>
		///             <description>
		///                 <paramref name="uCode" /> is a virtual-key code and is translated into an unshifted character value in the low-order word of the
		///                 return value. Dead keys (diacritics) are indicated by setting the top bit of the return value. If there is no translation, the
		///                 function returns 0.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MAPVK_VK_TO_VSC 0</term>
		///             <description>
		///                 <paramref name="uCode" /> is a virtual-key code and is translated into a scan code. If it is a virtual-key code that does not
		///                 distinguish between left- and right-hand keys, the left-hand scan code is returned. If there is no translation, the function returns
		///                 0.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MAPVK_VSC_TO_VK 1</term>
		///             <description>
		///                 <paramref name="uCode" /> is a scan code and is translated into a virtual-key code that does not distinguish between left- and
		///                 right-hand keys. If there is no translation, the function returns 0.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MAPVK_VSC_TO_VK_EX 3</term>
		///             <description>
		///                 <paramref name="uCode" /> is a scan code and is translated into a virtual-key code that distinguishes between left- and right-hand
		///                 keys. If there is no translation, the function returns 0.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     The return value is either a scan code, a virtual-key code, or a character value, depending on the value of <paramref name="uCode" /> and
		///     <paramref name="uMapType" />. If there is no translation, the return value is zero.
		/// </returns>
		/// <remarks>
		///     <para>
		///         An application can use <see cref="MapVirtualKey" /> to translate scan codes to the virtual-key code constants <see cref="VK.VK_SHIFT" />,
		///         <see cref="VK.VK_CONTROL" />, and <see cref="VK.VK_MENU" />, and vice versa. These translations do not distinguish between the left and right
		///         instances of the SHIFT, CTRL, or ALT keys.
		///     </para>
		///     <para>
		///         An application can get the scan code corresponding to the left or right instance of one of these keys by calling <see cref="MapVirtualKey" />
		///         with <paramref name="uCode" /> set to one of the following virtual-key code constants.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "MapVirtualKey")]
		public static extern uint MapVirtualKey(uint uCode, uint uMapType);

		/// <summary>
		///     The <see cref="InvalidateRect" /> function adds a rectangle to the specified window's update region. The update region represents the portion of
		///     the window's client area that must be redrawn.
		/// </summary>
		/// <param name="hWnd">
		///     A handle to the window whose update region has changed. If this parameter is NULL, the system invalidates and redraws all windows, not just the
		///     windows for this application, and sends the <see cref="WM.WM_ERASEBKGND" /> and <see cref="WM.WM_NCPAINT" /> messages before the function
		///     returns. Setting this parameter to NULL is not recommended.
		/// </param>
		/// <param name="lpRect">
		///     A pointer to a <see cref="RECT" /> structure that contains the client coordinates of the rectangle to be added to the update region. If this
		///     parameter is NULL, the entire client area is added to the update region.
		/// </param>
		/// <param name="bErase">
		///     Specifies whether the background within the update region is to be erased when the update region is processed. If this parameter is TRUE, the
		///     background is erased when the <see cref="BeginPaint" /> function is called. If this parameter is FALSE, the background remains unchanged.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The invalidated areas accumulate in the update region until the region is processed when the next <see cref="WM.WM_PAINT" /> message occurs
		///         or until the region is validated by using the <see cref="ValidateRect" /> or <see cref="ValidateRgn" /> function.
		///     </para>
		///     <para>
		///         The system sends a <see cref="WM.WM_PAINT" /> message to a window whenever its update region is not empty and there are no other messages in
		///         the application queue for that window.
		///     </para>
		///     <para>
		///         If the <paramref name="bErase" /> parameter is TRUE for any part of the update region, the background is erased in the entire region, not
		///         just in the specified part.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "InvalidateRect")]
		public static extern bool InvalidateRect([In] IntPtr hWnd, [In] ref RECT lpRect, [MarshalAs(UnmanagedType.Bool)] bool bErase);

		/// <summary>Adds or removes highlighting from an item in a menu bar.</summary>
		/// <param name="hwnd">A handle to the window that contains the menu.</param>
		/// <param name="hmenu">A handle to the menu bar that contains the item.</param>
		/// <param name="uItemHilite">
		///     The menu item. This parameter is either the identifier of the menu item or the offset of the menu item in the menu bar, depending on the value of
		///     the <paramref name="uHilite" /> parameter.
		/// </param>
		/// <param name="uHilite">
		///     <para>
		///         Controls the interpretation of the <paramref name="uItemHilite" /> parameter and indicates whether the menu item is highlighted. This
		///         parameter must be a combination of either <see cref="MF.MF_BYCOMMAND" /> or <see cref="MF.MF_BYPOSITION" /> and <see cref="MF.MF_HILITE" /> or
		///         <see cref="MF.MF_UNHILITE" />.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BYCOMMAND 0x00000000L</term>
		///             <description>
		///                 Indicates that <paramref name="uItemHilite" /> gives the identifier of the menu item.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_BYPOSITION 0x00000400L</term>
		///             <description>
		///                 Indicates that <paramref name="uItemHilite" /> gives the zero-based relative position of the menu item.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_HILITE 0x00000080L</term>
		///             <description>Highlights the menu item. If this flag is not specified, the highlighting is removed from the item.</description>
		///         </item>
		///         <item>
		///             <term>MF_UNHILITE 0x00000000L</term>
		///             <description>Removes highlighting from the menu item.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the menu item is set to the specified highlight state, the return value is nonzero.</para>
		///     <para>If the menu item is not set to the specified highlight state, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     The <see cref="MF.MF_HILITE" /> and <see cref="MF.MF_UNHILITE" /> flags can be used only with the <see cref="HiliteMenuItem" /> function; they cannot
		///     be used with the <see cref="ModifyMenu" /> function.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "HiliteMenuItem")]
		public static extern bool HiliteMenuItem([In] IntPtr hwnd, [In] IntPtr hmenu, uint uItemHilite, uint uHilite);

		/// <summary>
		///     Copies the text of the specified window's title bar (if it has one) into a buffer. If the specified window is a control, the text of the control
		///     is copied. However, <see cref="GetWindowText" /> cannot retrieve the text of a control in another application.
		/// </summary>
		/// <param name="hWnd">A handle to the window or control containing the text.</param>
		/// <param name="lpString">
		///     The buffer that will receive the text. If the string is as long or longer than the buffer, the string is truncated and terminated with a null
		///     character.
		/// </param>
		/// <param name="nMaxCount">
		///     The maximum number of characters to copy to the buffer, including the null character. If the text exceeds this limit, it is
		///     truncated.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is the length, in characters, of the copied string, not including the terminating null character.
		///         If the window has no title bar or text, if the title bar is empty, or if the window or control handle is invalid, the return value is zero.
		///         To get extended error information, call GetLastError.
		///     </para>
		///     <para>This function cannot retrieve the text of an edit control in another application.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If the target window is owned by the current process, <see cref="GetWindowText" /> causes a <see cref="WM.WM_GETTEXT" /> message to be sent
		///         to the specified window or control. If the target window is owned by another process and has a caption, <see cref="GetWindowText" />
		///         retrieves the window caption text. If the window does not have a caption, the return value is a null string. This behavior is by design. It
		///         allows applications to call <see cref="GetWindowText" /> without becoming unresponsive if the process that owns the target window is not
		///         responding. However, if the target window is not responding and it belongs to the calling application, <see cref="GetWindowText" /> will
		///         cause the calling application to become unresponsive.
		///     </para>
		///     <para>
		///         To retrieve the text of a control in another process, send a <see cref="WM.WM_GETTEXT" /> message directly instead of calling
		///         <see cref="GetWindowText" />.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetWindowText")]
		public static extern int GetWindowText([In] IntPtr hWnd, [Out] StringBuilder lpString, int nMaxCount);

		/// <summary>
		///     <para>
		///         Retrieves information about the specified window. The function also retrieves the 32-bit (DWORD) value at the specified offset
		///         into the extra window memory.
		///     </para>
		///     <para>
		///         Note:  If you are retrieving a pointer or a handle, this function has been superseded by the GetWindowLongPtr
		///         function. (Pointers and handles are 32 bits on 32-bit Windows and 64 bits on 64-bit Windows.) To write code that is compatible with both
		///         32-bit and 64-bit versions of Windows, use GetWindowLongPtr.
		///     </para>
		/// </summary>
		/// <param name="hWnd">A handle to the window and, indirectly, the class to which the window belongs.</param>
		/// <param name="nIndex">
		///     <para>
		///         The zero-based offset to the value to be retrieved. Valid values are in the range zero through the number of bytes of extra window memory,
		///         minus four; for example, if you specified 12 or more bytes of extra memory, a value of 8 would be an index to the third 32-bit integer. To
		///         retrieve any other value, specify one of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>GWL_EXSTYLE -20</term>
		///             <description>Retrieves the extended window styles.</description>
		///         </item>
		///         <item>
		///             <term>GWL_HINSTANCE -6</term>
		///             <description>Retrieves a handle to the application instance.</description>
		///         </item>
		///         <item>
		///             <term>GWL_HWNDPARENT -8</term>
		///             <description>Retrieves a handle to the parent window, if any.</description>
		///         </item>
		///         <item>
		///             <term>GWL_ID -12</term>
		///             <description>Retrieves the identifier of the window.</description>
		///         </item>
		///         <item>
		///             <term>GWL_STYLE -16</term>
		///             <description>Retrieves the window styles.</description>
		///         </item>
		///         <item>
		///             <term>GWL_USERDATA -21</term>
		///             <description>
		///                 Retrieves the user data associated with the window. This data is intended for use by the application that created the window. Its
		///                 value is initially zero.
		///             </description>
		///         </item>
		///         <item>
		///             <term>GWL_WNDPROC -4</term>
		///             <description>
		///                 Retrieves the address of the window procedure, or a handle representing the address of the window procedure. You must use the
		///                 <see cref="CallWindowProc" /> function to call the window procedure.
		///             </description>
		///         </item>
		///     </list>
		///     <para>
		///         The following values are also available when the <paramref name="hWnd" /> parameter identifies a dialog box.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>DWL_DLGPROC DWLP_MSGRESULT + sizeof(LRESULT)</term>
		///             <description>
		///                 Retrieves the address of the dialog box procedure, or a handle representing the address of the dialog box procedure. You must use the
		///                 <see cref="CallWindowProc" /> function to call the dialog box procedure.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DWL_MSGRESULT 0</term>
		///             <description>Retrieves the return value of a message processed in the dialog box procedure.</description>
		///         </item>
		///         <item>
		///             <term>DWL_USER DWLP_DLGPROC + sizeof(DLGPROC)</term>
		///             <description>Retrieves extra information private to the application, such as handles or pointers.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the requested value.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		///     <para>
		///         If <see cref="SetWindowLong" /> has not been called previously, <see cref="GetWindowLong" /> returns zero for values in the extra window or
		///         class memory.
		///     </para>
		/// </returns>
		/// <remarks>
		///     Reserve extra window memory by specifying a nonzero value in the <see cref="WNDCLASSEX.cbWndExtra" /> member of the <see cref="WNDCLASSEX" /> structure used
		///     with the <see cref="RegisterClassEx" /> function.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetWindowLong")]
		public static extern int GetWindowLong([In] IntPtr hWnd, int nIndex);

		/// <summary>Retrieves a handle to the Shell's desktop window.</summary>
		/// <returns>
		///     <para>The return value is the handle of the Shell's desktop window. If no Shell process is present, the return value is NULL.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetShellWindow")]
		public static extern IntPtr GetShellWindow();

		/// <summary>
		///     <para>
		///         The <see cref="GetScrollRange" /> function retrieves the current minimum and maximum scroll box (thumb) positions for the specified scroll
		///         bar.
		///     </para>
		///     <para>
		///         Note:  The <see cref="GetScrollRange" /> function is provided for compatibility only. New applications should use the
		///         <see cref="GetScrollInfo" /> function.
		///     </para>
		/// </summary>
		/// <param name="hWnd">
		///     Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the <paramref name="nBar" /> parameter.
		/// </param>
		/// <param name="nBar">
		///     <para>Specifies the scroll bar from which the positions are retrieved. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>SB_CTL</term>
		///             <description>
		///                 Retrieves the positions of a scroll bar control. The <paramref name="hWnd" /> parameter must be the handle to the scroll bar control.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SB_HORZ</term>
		///             <description>Retrieves the positions of the window's standard horizontal scroll bar.</description>
		///         </item>
		///         <item>
		///             <term>SB_VERT</term>
		///             <description>Retrieves the positions of the window's standard vertical scroll bar.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="lpMinPos">Pointer to the integer variable that receives the minimum position.</param>
		/// <param name="lpMaxPos">Pointer to the integer variable that receives the maximum position.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If the specified window does not have standard scroll bars or is not a scroll bar control, the <see cref="GetScrollRange" /> function copies
		///         zero to the <paramref name="lpMinPos" /> and <paramref name="lpMaxPos" /> parameters.
		///     </para>
		///     <para>The default range for a standard scroll bar is 0 through 100. The default range for a scroll bar control is empty (both values are zero).</para>
		///     <para>
		///         The messages that indicate scroll bar position, <see cref="WM.WM_HSCROLL" /> and <see cref="WM.WM_VSCROLL" />, are limited to 16 bits of
		///         position data. However, because <see cref="SetScrollInfo" />, <see cref="SetScrollPos" />, <see cref="SetScrollRange" />,
		///         <see cref="GetScrollInfo" />
		///         , <see cref="GetScrollPos" />, and <see cref="GetScrollRange" /> support 32-bit scroll bar position data, there is a way to circumvent the
		///         16-bit barrier of the <see cref="WM.WM_HSCROLL" /> and <see cref="WM.WM_VSCROLL" /> messages. See the <see cref="GetScrollInfo" /> function
		///         for a description of the technique.
		///     </para>
		///     <para>
		///         If the <paramref name="nBar" /> parameter is SB_CTL and the window specified by the <paramref name="hWnd" /> parameter is not a system scroll
		///         bar control, the system sends the <see cref="SBM_GETRANGE" /> message to the window to obtain scroll bar information. This allows
		///         <see cref="GetScrollRange" /> to operate on a custom control that mimics a scroll bar. If the window does not handle the
		///         <see cref="SBM_GETRANGE" /> message, the <see cref="GetScrollRange" /> function fails.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetScrollRange")]
		public static extern bool GetScrollRange([In] IntPtr hWnd, int nBar, [Out] out int lpMinPos, [Out] out int lpMaxPos);

		/// <summary>Retrieves the type of messages found in the calling thread's message queue.</summary>
		/// <param name="flags">
		///     <para>The types of messages for which to check. This parameter can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>QS_ALLEVENTS (QS_INPUT | QS_POSTMESSAGE | QS_TIMER | QS_PAINT | QS_HOTKEY)</term>
		///             <description>
		///                 An input, <see cref="WM.WM_TIMER" />, <see cref="WM.WM_PAINT" />, <see cref="WM.WM_HOTKEY" />, or posted message is in the queue.
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_ALLINPUT (QS_INPUT | QS_POSTMESSAGE | QS_TIMER | QS_PAINT | QS_HOTKEY | QS_SENDMESSAGE)</term>
		///             <description>Any message is in the queue.</description>
		///         </item>
		///         <item>
		///             <term>QS_ALLPOSTMESSAGE 0x0100</term>
		///             <description>A posted message (other than those listed here) is in the queue.</description>
		///         </item>
		///         <item>
		///             <term>QS_HOTKEY 0x0080</term>
		///             <description>
		///                 A <see cref="WM.WM_HOTKEY" /> message is in the queue.
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_INPUT (QS_MOUSE | QS_KEY | QS_RAWINPUT)</term>
		///             <description>An input message is in the queue.</description>
		///         </item>
		///         <item>
		///             <term>QS_KEY 0x0001</term>
		///             <description>
		///                 A <see cref="WM.WM_KEYUP" />, <see cref="WM.WM_KEYDOWN" />, <see cref="WM.WM_SYSKEYUP" />, or <see cref="WM.WM_SYSKEYDOWN" /> message
		///                 is in the queue.
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_MOUSE (QS_MOUSEMOVE | QS_MOUSEBUTTON)</term>
		///             <description>
		///                 A <see cref="WM.WM_MOUSEMOVE" /> message or mouse-button message (<see cref="WM.WM_LBUTTONUP" />, <see cref="WM.WM_RBUTTONDOWN" />,
		///                 and so on).
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_MOUSEBUTTON 0x0004</term>
		///             <description>
		///                 A mouse-button message (<see cref="WM.WM_LBUTTONUP" />, <see cref="WM.WM_RBUTTONDOWN" />, and so on).
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_MOUSEMOVE 0x0002</term>
		///             <description>
		///                 A <see cref="WM.WM_MOUSEMOVE" /> message is in the queue.
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_PAINT 0x0020</term>
		///             <description>
		///                 A <see cref="WM.WM_PAINT" /> message is in the queue.
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_POSTMESSAGE 0x0008</term>
		///             <description>A posted message (other than those listed here) is in the queue.</description>
		///         </item>
		///         <item>
		///             <term>QS_RAWINPUT 0x0400</term>
		///             <description>
		///                 <para>A raw input message is in the queue. For more information, see Raw Input.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>QS_SENDMESSAGE 0x0040</term>
		///             <description>A message sent by another thread or application is in the queue.</description>
		///         </item>
		///         <item>
		///             <term>QS_TIMER 0x0010</term>
		///             <description>
		///                 A <see cref="WM.WM_TIMER" /> message is in the queue.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>
		///         The high-order word of the return value indicates the types of messages currently in the queue. The low-order word indicates the types of
		///         messages that have been added to the queue and that are still in the queue since the last call to the <see cref="GetQueueStatus" />,
		///         <see cref="GetMessage" />, or <see cref="PeekMessage" /> function.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The presence of a QS_ flag in the return value does not guarantee that a subsequent call to the <see cref="GetMessage" /> or
		///         <see cref="PeekMessage" /> function will return a message. <see cref="GetMessage" /> and <see cref="PeekMessage" /> perform some internal
		///         filtering that may cause the message to be processed internally. For this reason, the return value from <see cref="GetQueueStatus" /> should
		///         be considered only a hint as to whether <see cref="GetMessage" /> or <see cref="PeekMessage" /> should be called.
		///     </para>
		///     <para>
		///         The <see cref="QS.QS_ALLPOSTMESSAGE" /> and <see cref="QS.QS_POSTMESSAGE" /> flags differ in when they are cleared. <see cref="QS.QS_POSTMESSAGE" />
		///         is cleared when you call <see cref="GetMessage" /> or <see cref="PeekMessage" />, whether or not you are filtering messages.
		///         <see cref="QS.QS_ALLPOSTMESSAGE" /> is cleared when you call <see cref="GetMessage" /> or <see cref="PeekMessage" /> without filtering messages
		///         (wMsgFilterMin and wMsgFilterMax are 0). This can be useful when you call <see cref="PeekMessage" />
		///         multiple times to get messages in different ranges.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetQueueStatus")]
		public static extern uint GetQueueStatus(QS flags);

		/// <summary>
		///     Retrieves the message time for the last message retrieved by the <see cref="GetMessage" /> function. The time is a long integer that specifies
		///     the elapsed time, in milliseconds, from the time the system was started to the time the message was created (that is, placed in the thread's
		///     message queue).
		/// </summary>
		/// <returns>
		///     <para>The return value specifies the message time.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The return value from the <see cref="GetMessageTime" /> function does not necessarily increase between subsequent messages, because the value
		///         wraps to zero if the timer count exceeds the maximum value for a long integer.
		///     </para>
		///     <para>
		///         To calculate time delays between messages, verify that the time of the second message is greater than the time of the first message; then,
		///         subtract the time of the first message from the time of the second message.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetMessageTime")]
		public static extern int GetMessageTime();

		/// <summary>
		///     <para>Copies the text string of the specified menu item into the specified buffer.</para>
		///     <para>
		///         Note:  The <see cref="GetMenuString" /> function has been superseded. Use the <see cref="GetMenuItemInfo" /> function to
		///         retrieve the menu item text.
		///     </para>
		/// </summary>
		/// <param name="hMenu">A handle to the menu.</param>
		/// <param name="uIDItem">
		///     The menu item to be changed, as determined by the <paramref name="uFlag" /> parameter.
		/// </param>
		/// <param name="lpString">
		///     The buffer that receives the null-terminated string. If the string is as long or longer than <paramref name="lpString" />, the string is
		///     truncated and the terminating null character is added. If <paramref name="lpString" /> is NULL, the function returns the length of the menu
		///     string.
		/// </param>
		/// <param name="nMaxCount">
		///     The maximum length, in characters, of the string to be copied. If the string is longer than the maximum specified in the
		///     <paramref name="nMaxCount" /> parameter, the extra characters are truncated. If <paramref name="nMaxCount" /> is 0, the function returns the
		///     length of the menu string.
		/// </param>
		/// <param name="uFlag">
		///     <para>
		///         Indicates how the <paramref name="uIDItem" /> parameter is interpreted. This parameter must be one of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BYCOMMAND 0x00000000L</term>
		///             <description>
		///                 Indicates that <paramref name="uIDItem" /> gives the identifier of the menu item. If neither the <see cref="MF.MF_BYCOMMAND" /> nor
		///                 <see cref="MF.MF_BYPOSITION" /> flag is specified, the <see cref="MF.MF_BYCOMMAND" /> flag is the default flag.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_BYPOSITION 0x00000400L</term>
		///             <description>
		///                 Indicates that <paramref name="uIDItem" /> gives the zero-based relative position of the menu item.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value specifies the number of characters copied to the buffer, not including the terminating null
		///         character.
		///     </para>
		///     <para>If the function fails, the return value is zero.</para>
		///     <para>
		///         If the specified item is not of type MIIM_STRING or MFT_STRING, then the return value is zero.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <paramref name="nMaxCount" /> parameter must be one larger than the number of characters in the text string to accommodate the
		///         terminating null character.
		///     </para>
		///     <para>
		///         If <paramref name="nMaxCount" /> is 0, the function returns the length of the menu string.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetMenuString")]
		public static extern int GetMenuString([In] IntPtr hMenu, uint uIDItem, [Out] StringBuilder lpString, int nMaxCount, MF uFlag);

		/// <summary>Retrieves information about the specified menu bar.</summary>
		/// <param name="hwnd">A handle to the window (menu bar) whose information is to be retrieved.</param>
		/// <param name="idObject">
		///     <para>The menu object. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>OBJID_CLIENT ((LONG)0xFFFFFFFC)</term>
		///             <description>The popup menu associated with the window.</description>
		///         </item>
		///         <item>
		///             <term>OBJID_MENU ((LONG)0xFFFFFFFD)</term>
		///             <description>
		///                 The menu bar associated with the window (see the <see cref="GetMenu" /> function).
		///             </description>
		///         </item>
		///         <item>
		///             <term>OBJID_SYSMENU ((LONG)0xFFFFFFFF)</term>
		///             <description>
		///                 The system menu associated with the window (see the <see cref="GetSystemMenu" /> function).
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="idItem">
		///     The item for which to retrieve information. If this parameter is zero, the function retrieves information about the menu itself. If this
		///     parameter is 1, the function retrieves information about the first item on the menu, and so on.
		/// </param>
		/// <param name="pmbi">
		///     A pointer to a <see cref="MENUBARINFO" /> structure that receives the information. Note that you must set the <see cref="MENUBARINFO.cbSize" /> member to
		///     sizeof(MENUBARINFO) before calling this function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetMenuBarInfo")]
		public static extern bool GetMenuBarInfo([In] IntPtr hwnd, int idObject, int idItem, ref MENUBARINFO pmbi);

		/// <summary>Retrieves the number of items per column in a specified list box.</summary>
		/// <param name="hwnd">A handle to the list box whose number of items per column is to be retrieved.</param>
		/// <returns>The return value is the number of items per column.</returns>
		[DllImport("user32.dll", EntryPoint = "GetListBoxInfo")]
		public static extern uint GetListBoxInfo([In] IntPtr hwnd);

		/// <summary>Retrieves status information for the specified window if it is the application-switching (ALT+TAB) window.</summary>
		/// <param name="hwnd">A handle to the window for which status information will be retrieved. This window must be the application-switching window.</param>
		/// <param name="iItem">
		///     The index of the icon in the application-switching window. If the <paramref name="pszItemText" /> parameter is not NULL, the name of the item is
		///     copied to the <paramref name="pszItemText" /> string. If this parameter is –1, the name of the item is not copied.
		/// </param>
		/// <param name="pati">
		///     A pointer to an <see cref="ALTTABINFO" /> structure to receive the status information. Note that you must set the <see cref="ALTTABINFO.csSize" /> member to
		///     sizeof(ALTTABINFO) before calling this function.
		/// </param>
		/// <param name="pszItemText">The name of the item. If this parameter is NULL, the name of the item is not copied.</param>
		/// <param name="cchItemText">
		///     The size, in characters, of the <paramref name="pszItemText" /> buffer.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     The application-switching window enables you to switch to the most recently used application window. To display the application-switching window,
		///     press ALT+TAB. To select an application from the list, continue to hold ALT down and press TAB to move through the list. Add SHIFT to reverse
		///     direction through the list.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetAltTabInfo")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool GetAltTabInfo([In] IntPtr hwnd, int iItem, ref ALTTABINFO pati, [Out] StringBuilder pszItemText, uint cchItemText);

		/// <summary>Enables, disables, or grays the specified menu item.</summary>
		/// <param name="hMenu">A handle to the menu.</param>
		/// <param name="uIDEnableItem">
		///     The menu item to be enabled, disabled, or grayed, as determined by the <paramref name="uEnable" /> parameter. This parameter specifies an item in
		///     a menu bar, menu, or submenu.
		/// </param>
		/// <param name="uEnable">
		///     <para>
		///         Controls the interpretation of the <paramref name="uIDEnableItem" /> parameter and indicate whether the menu item is enabled, disabled, or
		///         grayed. This parameter must be a combination of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BYCOMMAND 0x00000000L</term>
		///             <description>
		///                 Indicates that <paramref name="uIDEnableItem" /> gives the identifier of the menu item. If neither the <see cref="MF.MF_BYCOMMAND" />
		///                 nor <see cref="MF.MF_BYPOSITION" /> flag is specified, the <see cref="MF.MF_BYCOMMAND" /> flag is the default flag.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_BYPOSITION 0x00000400L</term>
		///             <description>
		///                 Indicates that <paramref name="uIDEnableItem" /> gives the zero-based relative position of the menu item.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_DISABLED 0x00000002L</term>
		///             <description>Indicates that the menu item is disabled, but not grayed, so it cannot be selected.</description>
		///         </item>
		///         <item>
		///             <term>MF_ENABLED 0x00000000L</term>
		///             <description>Indicates that the menu item is enabled and restored from a grayed state so that it can be selected.</description>
		///         </item>
		///         <item>
		///             <term>MF_GRAYED 0x00000001L</term>
		///             <description>Indicates that the menu item is disabled and grayed so that it cannot be selected.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     The return value specifies the previous state of the menu item (it is either <see cref="MF.MF_DISABLED" />, <see cref="MF.MF_ENABLED" />, or
		///     <see cref="MF.MF_GRAYED" />). If the menu item does not exist, the return value is -1.
		/// </returns>
		/// <remarks>
		///     <para>
		///         An application must use the <see cref="MF.MF_BYPOSITION" /> flag to specify the correct menu handle. If the menu handle to the menu bar is
		///         specified, the top-level menu item (an item in the menu bar) is affected. To set the state of an item in a drop-down menu or submenu by
		///         position, an application must specify a handle to the drop-down menu or submenu.
		///     </para>
		///     <para>
		///         When an application specifies the <see cref="MF.MF_BYCOMMAND" /> flag, the system checks all items that open submenus in the menu identified by
		///         the specified menu handle. Therefore, unless duplicate menu items are present, specifying the menu handle to the menu bar is sufficient.
		///     </para>
		///     <para>
		///         The <see cref="InsertMenu" />, <see cref="InsertMenuItem" />, <see cref="LoadMenuIndirect" />, <see cref="ModifyMenu" />, and
		///         <see cref="SetMenuItemInfo" /> functions can also set the state (enabled, disabled, or grayed) of a menu item.
		///     </para>
		///     <para>
		///         When you change a window menu, the menu bar is not immediately updated. To force the update, call <see cref="DrawMenuBar" />.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "EnableMenuItem")]
		public static extern bool EnableMenuItem([In] IntPtr hMenu, uint uIDEnableItem, uint uEnable);

		/// <summary>
		///     Empties the clipboard and frees handles to data in the clipboard. The function then assigns ownership of the clipboard to the window that
		///     currently has the clipboard open.
		/// </summary>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     Before calling <see cref="EmptyClipboard" />, an application must open the clipboard by using the <see cref="OpenClipboard" /> function. If the
		///     application specifies a NULL window handle when opening the clipboard, <see cref="EmptyClipboard" /> succeeds but sets the clipboard owner to
		///     NULL. Note that this causes <see cref="SetClipboardData" /> to fail.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "EmptyClipboard")]
		public static extern bool EmptyClipboard();

		/// <summary>
		///     Calls the default window procedure to provide default processing for any window messages that an application does not process. This function
		///     ensures that every message is processed. <see cref="DefWindowProc" /> is called with the same parameters received by the window procedure.
		/// </summary>
		/// <param name="hWnd">A handle to the window procedure that received the message.</param>
		/// <param name="Msg">The message.</param>
		/// <param name="wParam">
		///     Additional message information. The content of this parameter depends on the value of the <paramref name="Msg" /> parameter.
		/// </param>
		/// <param name="lParam">
		///     Additional message information. The content of this parameter depends on the value of the <paramref name="Msg" /> parameter.
		/// </param>
		/// <returns>
		///     <para>The return value is the result of the message processing and depends on the message.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "DefWindowProc")]
		[return: MarshalAs(UnmanagedType.SysInt)]
		public static extern int DefWindowProc(
			[In] IntPtr hWnd, uint Msg, [MarshalAs(UnmanagedType.SysUInt)] uint wParam, [MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>
		///     Updates the specified multiple-window – position structure for the specified window. The function then returns a handle to the updated structure.
		///     The <see cref="EndDeferWindowPos" /> function uses the information in this structure to change the position and size of a number of windows
		///     simultaneously. The <see cref="BeginDeferWindowPos" /> function creates the structure.
		/// </summary>
		/// <param name="hWinPosInfo">
		///     A handle to a multiple-window – position structure that contains size and position information for one or more windows. This structure is
		///     returned by <see cref="BeginDeferWindowPos" /> or by the most recent call to <see cref="DeferWindowPos" />.
		/// </param>
		/// <param name="hWnd">
		///     A handle to the window for which update information is stored in the structure. All windows in a multiple-window – position structure must have
		///     the same parent.
		/// </param>
		/// <param name="hWndInsertAfter">
		///     <para>
		///         A handle to the window that precedes the positioned window in the Z order. This parameter must be a window handle or one of the following
		///         values. This parameter is ignored if the <see cref="SWP.SWP_NOZORDER" /> flag is set in the <paramref name="uFlags" /> parameter.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>HWND_BOTTOM ((HWND)1)</term>
		///             <description>
		///                 Places the window at the bottom of the Z order. If the <paramref name="hWnd" /> parameter identifies a topmost window, the window
		///                 loses its topmost status and is placed at the bottom of all other windows.
		///             </description>
		///         </item>
		///         <item>
		///             <term>HWND_NOTOPMOST ((HWND)-2)</term>
		///             <description>
		///                 Places the window above all non-topmost windows (that is, behind all topmost windows). This flag has no effect if the window is
		///                 already a non-topmost window.
		///             </description>
		///         </item>
		///         <item>
		///             <term>HWND_TOP ((HWND)0)</term>
		///             <description>Places the window at the top of the Z order.</description>
		///         </item>
		///         <item>
		///             <term>HWND_TOPMOST ((HWND)-1)</term>
		///             <description>Places the window above all non-topmost windows. The window maintains its topmost position even when it is deactivated.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="x">The x-coordinate of the window's upper-left corner.</param>
		/// <param name="y">The y-coordinate of the window's upper-left corner.</param>
		/// <param name="cx">The window's new width, in pixels.</param>
		/// <param name="cy">The window's new height, in pixels.</param>
		/// <param name="uFlags">
		///     <para>A combination of the following values that affect the size and position of the window.</para>
		///     <list type="table">
		///         <item>
		///             <term>SWP_DRAWFRAME 0x0020</term>
		///             <description>Draws a frame (defined in the window's class description) around the window.</description>
		///         </item>
		///         <item>
		///             <term>SWP_FRAMECHANGED 0x0020</term>
		///             <description>
		///                 Sends a <see cref="WM.WM_NCCALCSIZE" /> message to the window, even if the window's size is not being changed. If this flag is not
		///                 specified, <see cref="WM.WM_NCCALCSIZE" /> is sent only when the window's size is being changed.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_HIDEWINDOW 0x0080</term>
		///             <description>Hides the window.</description>
		///         </item>
		///         <item>
		///             <term>SWP_NOACTIVATE 0x0010</term>
		///             <description>
		///                 Does not activate the window. If this flag is not set, the window is activated and moved to the top of either the topmost or
		///                 non-topmost group (depending on the setting of the <paramref name="hWndInsertAfter" /> parameter).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_NOCOPYBITS 0x0100</term>
		///             <description>
		///                 Discards the entire contents of the client area. If this flag is not specified, the valid contents of the client area are saved and
		///                 copied back into the client area after the window is sized or repositioned.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_NOMOVE 0x0002</term>
		///             <description>
		///                 Retains the current position (ignores the <paramref name="x" /> and <paramref name="y" /> parameters).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_NOOWNERZORDER 0x0200</term>
		///             <description>Does not change the owner window's position in the Z order.</description>
		///         </item>
		///         <item>
		///             <term>SWP_NOREDRAW 0x0008</term>
		///             <description>
		///                 Does not redraw changes. If this flag is set, no repainting of any kind occurs. This applies to the client area, the nonclient area
		///                 (including the title bar and scroll bars), and any part of the parent window uncovered as a result of the window being moved. When
		///                 this flag is set, the application must explicitly invalidate or redraw any parts of the window and parent window that need redrawing.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_NOREPOSITION 0x0200</term>
		///             <description>
		///                 Same as the <see cref="SWP.SWP_NOOWNERZORDER" /> flag.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_NOSENDCHANGING 0x0400</term>
		///             <description>
		///                 Prevents the window from receiving the <see cref="WM.WM_WINDOWPOSCHANGING" /> message.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_NOSIZE 0x0001</term>
		///             <description>
		///                 Retains the current size (ignores the <paramref name="cx" /> and <paramref name="cy" /> parameters).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_NOZORDER 0x0004</term>
		///             <description>
		///                 Retains the current Z order (ignores the <paramref name="hWndInsertAfter" /> parameter).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_SHOWWINDOW 0x0040</term>
		///             <description>Displays the window.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>
		///         The return value identifies the updated multiple-window – position structure. The handle returned by this function may differ from the handle
		///         passed to the function. The new handle that this function returns should be passed during the next call to the <see cref="DeferWindowPos" />
		///         or <see cref="EndDeferWindowPos" /> function.
		///     </para>
		///     <para>
		///         If insufficient system resources are available for the function to succeed, the return value is NULL. To get extended error information, call
		///         GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If a call to <see cref="DeferWindowPos" /> fails, the application should abandon the window-positioning operation and not call
		///         <see cref="EndDeferWindowPos" />.
		///     </para>
		///     <para>
		///         If <see cref="SWP.SWP_NOZORDER" /> is not specified, the system places the window identified by the <paramref name="hWnd" /> parameter in the
		///         position following the window identified by the <paramref name="hWndInsertAfter" /> parameter. If <paramref name="hWndInsertAfter" /> is NULL
		///         or <see cref="HWND_TOP" />, the system places the <paramref name="hWnd" /> window at the top of the Z order. If
		///         <paramref name="hWndInsertAfter" /> is set to <see cref="HWND_BOTTOM" />, the system places the <paramref name="hWnd" /> window at the bottom
		///         of the Z order.
		///     </para>
		///     <para>All coordinates for child windows are relative to the upper-left corner of the parent window's client area.</para>
		///     <para>
		///         A window can be made a topmost window either by setting <paramref name="hWndInsertAfter" /> to the <see cref="HWND_TOPMOST" /> flag and
		///         ensuring that the <see cref="SWP.SWP_NOZORDER" /> flag is not set, or by setting the window's position in the Z order so that it is above any
		///         existing topmost windows. When a non-topmost window is made topmost, its owned windows are also made topmost. Its owners, however, are not
		///         changed.
		///     </para>
		///     <para>
		///         If neither the <see cref="SWP.SWP_NOACTIVATE" /> nor <see cref="SWP.SWP_NOZORDER" /> flag is specified (that is, when the application requests that a
		///         window be simultaneously activated and its position in the Z order changed), the value specified in <paramref name="hWndInsertAfter" /> is
		///         used only in the following circumstances:
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DeferWindowPos")]
		public static extern IntPtr DeferWindowPos(
			[In] IntPtr hWinPosInfo, [In] IntPtr hWnd, [In] IntPtr hWndInsertAfter, int x, int y, int cx, int cy, SWP uFlags);

		/// <summary>
		///     Registers or unregisters the service names a Dynamic Data Exchange (DDE) server supports. This function causes the system to send
		///     <see cref="XTYP_REGISTER" /> or <see cref="XTYP_UNREGISTER" /> transactions to other running Dynamic Data Exchange Management Library (DDEML)
		///     client applications.
		/// </summary>
		/// <param name="idInst">
		///     The application instance identifier obtained by a previous call to the <see cref="DdeInitialize" /> function.
		/// </param>
		/// <param name="hsz1">
		///     A handle to the string that specifies the service name the server is registering or unregistering. An application that is unregistering all of
		///     its service names should set this parameter to 0L.
		/// </param>
		/// <param name="hsz2">Reserved; should be set to 0L.</param>
		/// <param name="afCmd">
		///     <para>The service name options. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>DNS_REGISTER 0x0001</term>
		///             <description>Registers the error code service name.</description>
		///         </item>
		///         <item>
		///             <term>DNS_UNREGISTER 0x0002</term>
		///             <description>
		///                 Unregisters the error code service name. If the <paramref name="hsz1" /> parameter is 0L, all service names registered by the server
		///                 will be unregistered.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DNS_FILTERON 0x0004</term>
		///             <description>
		///                 <para>
		///                     Turns on service name initiation filtering. The filter prevents a server from receiving <see cref="XTYP_CONNECT" /> transactions
		///                     for service names it has not registered. This is the default setting for this filter.
		///                 </para>
		///                 <para>
		///                     If a server application does not register any service names, the application cannot receive <see cref="XTYP_WILDCONNECT" />
		///                     transactions.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>DNS_FILTEROFF 0x0008</term>
		///             <description>
		///                 Turns off service name initiation filtering. If this flag is specified, the server receives an <see cref="XTYP_CONNECT" />
		///                 transaction whenever another DDE application calls the <see cref="DdeConnect" /> function, regardless of the service name.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, it returns a nonzero value. That value is not a true <see cref="HDDEDATA" /> value, merely a Boolean indicator of
		///         success. The function is typed <see cref="HDDEDATA" /> to allow for possible future expansion of the function and a more sophisticated return
		///         value.
		///     </para>
		///     <para>If the function fails, the return value is 0L.</para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		/// <remarks>
		///     The service name identified by the <paramref name="hsz1" /> parameter should be a base name (that is, the name should contain no
		///     instance-specific information). The system generates an instance-specific name and sends it along with the base name during the
		///     <see cref="XTYP_REGISTER" /> and <see cref="XTYP_UNREGISTER" /> transactions. The receiving applications can then connect to the specific
		///     application instance.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DdeNameService")]
		public static extern IntPtr DdeNameService(uint idInst, IntPtr hsz1, IntPtr hsz2, uint afCmd);

		/// <summary>
		///     Registers an application with the Dynamic Data Exchange Management Library (DDEML). An application must call this function before calling any
		///     other Dynamic Data Exchange Management Library (DDEML) function.
		/// </summary>
		/// <param name="pidInst">
		///     <para>
		///         The application instance identifier. At initialization, this parameter should point to 0. If the function succeeds, this parameter points to
		///         the instance identifier for the application. This value should be passed as the <paramref name="idInst" /> parameter in all other DDEML
		///         functions that require it. If an application uses multiple instances of the DDEML dynamic-link library (DLL), the application should provide
		///         a different callback function for each instance.
		///     </para>
		///     <para>
		///         If <paramref name="pidInst" /> points to a nonzero value, reinitialization of the DDEML is implied. In this case, <paramref name="pidInst" />
		///         must point to a valid application-instance identifier.
		///     </para>
		/// </param>
		/// <param name="pfnCallback">
		///     A pointer to the application-defined DDE callback function. This function processes DDE transactions sent by the system. For more information,
		///     see the <see cref="DdeCallback" /> callback function.
		/// </param>
		/// <param name="afCmd">
		///     <para>
		///         A set of <see cref="APPCMD_" />, <see cref="CBF_" />, and <see cref="MF.MF_" /> flags. The <see cref="APPCMD_" /> flags provide special
		///         instructions to <see cref="DdeInitialize" />. The <see cref="CBF_" /> flags specify filters that prevent specific types of transactions from
		///         reaching the callback function. The <see cref="MF.MF_" /> flags specify the types of DDE activity that a DDE monitoring application monitors.
		///         Using these flags enhances the performance of a DDE application by eliminating unnecessary calls to the callback function.
		///     </para>
		///     <para>This parameter can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>APPCLASS_MONITOR 0x00000001L</term>
		///             <description>
		///                 Makes it possible for the application to monitor DDE activity in the system. This flag is for use by DDE monitoring applications. The
		///                 application specifies the types of DDE activity to monitor by combining one or more monitor flags with the
		///                 <see cref="APPCLASS_MONITOR" /> flag. For details, see the following Remarks section.
		///             </description>
		///         </item>
		///         <item>
		///             <term>APPCLASS_STANDARD 0x00000000L</term>
		///             <description>Registers the application as a standard (nonmonitoring) DDEML application.</description>
		///         </item>
		///         <item>
		///             <term>APPCMD_CLIENTONLY 0x00000010L</term>
		///             <description>
		///                 Prevents the application from becoming a server in a DDE conversation. The application can only be a client. This flag reduces
		///                 consumption of resources by the DDEML. It includes the functionality of the <see cref="CBF_FAIL_ALLSVRXACTIONS" /> flag.
		///             </description>
		///         </item>
		///         <item>
		///             <term>APPCMD_FILTERINITS 0x00000020L</term>
		///             <description>
		///                 Prevents the DDEML from sending <see cref="XTYP_CONNECT" /> and <see cref="XTYP_WILDCONNECT" /> transactions to the application until
		///                 the application has created its string handles and registered its service names or has turned off filtering by a subsequent call to
		///                 the <see cref="DdeNameService" /> or <see cref="DdeInitialize" /> function. This flag is always in effect when an application calls
		///                 <see cref="DdeInitialize" /> for the first time, regardless of whether the application specifies the flag. On subsequent calls to
		///                 <see cref="DdeInitialize" />, not specifying this flag turns off the application's service-name filters, but specifying it turns on
		///                 the application's service name filters.
		///             </description>
		///         </item>
		///         <item>
		///             <term>CBF_FAIL_ALLSVRXACTIONS 0x0003f000</term>
		///             <description>
		///                 Prevents the callback function from receiving server transactions. The system returns <see cref="DDE_FNOTPROCESSED" /> to each client
		///                 that sends a transaction to this application. This flag is equivalent to combining all CBF_FAIL_ flags.
		///             </description>
		///         </item>
		///         <item>
		///             <term>CBF_FAIL_ADVISES 0x00004000</term>
		///             <description>
		///                 Prevents the callback function from receiving <see cref="XTYP_ADVSTART" /> and <see cref="XTYP_ADVSTOP" /> transactions. The system
		///                 returns <see cref="DDE_FNOTPROCESSED" /> to each client that sends an <see cref="XTYP_ADVSTART" /> or <see cref="XTYP_ADVSTOP" />
		///                 transaction to the server.
		///             </description>
		///         </item>
		///         <item>
		///             <term>CBF_FAIL_CONNECTIONS 0x00002000</term>
		///             <description>
		///                 Prevents the callback function from receiving <see cref="XTYP_CONNECT" /> and <see cref="XTYP_WILDCONNECT" /> transactions.
		///             </description>
		///         </item>
		///         <item>
		///             <term>CBF_FAIL_EXECUTES 0x00008000</term>
		///             <description>
		///                 Prevents the callback function from receiving <see cref="XTYP_EXECUTE" /> transactions. The system returns
		///                 <see cref="DDE_FNOTPROCESSED" /> to a client that sends an <see cref="XTYP_EXECUTE" /> transaction to the server.
		///             </description>
		///         </item>
		///         <item>
		///             <term>CBF_FAIL_POKES 0x00010000</term>
		///             <description>
		///                 Prevents the callback function from receiving <see cref="XTYP_POKE" /> transactions. The system returns
		///                 <see cref="DDE_FNOTPROCESSED" /> to a client that sends an <see cref="XTYP_POKE" /> transaction to the server.
		///             </description>
		///         </item>
		///         <item>
		///             <term>CBF_FAIL_REQUESTS 0x00020000</term>
		///             <description>
		///                 Prevents the callback function from receiving <see cref="XTYP_REQUEST" /> transactions. The system returns
		///                 <see cref="DDE_FNOTPROCESSED" /> to a client that sends an <see cref="XTYP_REQUEST" /> transaction to the server.
		///             </description>
		///         </item>
		///         <item>
		///             <term>CBF_FAIL_SELFCONNECTIONS 0x00001000</term>
		///             <description>
		///                 Prevents the callback function from receiving <see cref="XTYP_CONNECT" /> transactions from the application's own instance. This flag
		///                 prevents an application from establishing a DDE conversation with its own instance. An application should use this flag if it needs
		///                 to communicate with other instances of itself but not with itself.
		///             </description>
		///         </item>
		///         <item>
		///             <term>CBF_SKIP_ALLNOTIFICATIONS 0x003c0000</term>
		///             <description>Prevents the callback function from receiving any notifications. This flag is equivalent to combining all CBF_SKIP_ flags.</description>
		///         </item>
		///         <item>
		///             <term>CBF_SKIP_CONNECT_CONFIRMS 0x00040000</term>
		///             <description>
		///                 Prevents the callback function from receiving <see cref="XTYP_CONNECT_CONFIRM" /> notifications.
		///             </description>
		///         </item>
		///         <item>
		///             <term>CBF_SKIP_DISCONNECTS 0x00200000</term>
		///             <description>
		///                 Prevents the callback function from receiving <see cref="XTYP_DISCONNECT" /> notifications.
		///             </description>
		///         </item>
		///         <item>
		///             <term>CBF_SKIP_REGISTRATIONS 0x00080000</term>
		///             <description>
		///                 Prevents the callback function from receiving <see cref="XTYP_REGISTER" /> notifications.
		///             </description>
		///         </item>
		///         <item>
		///             <term>CBF_SKIP_UNREGISTRATIONS 0x00100000</term>
		///             <description>
		///                 Prevents the callback function from receiving <see cref="XTYP_UNREGISTER" /> notifications.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_CALLBACKS 0x08000000</term>
		///             <description>Notifies the callback function whenever a transaction is sent to any DDE callback function in the system.</description>
		///         </item>
		///         <item>
		///             <term>MF_CONV 0x40000000</term>
		///             <description>Notifies the callback function whenever a conversation is established or terminated.</description>
		///         </item>
		///         <item>
		///             <term>MF_ERRORS 0x10000000</term>
		///             <description>Notifies the callback function whenever a DDE error occurs.</description>
		///         </item>
		///         <item>
		///             <term>MF_HSZ_INFO 0x01000000</term>
		///             <description>
		///                 Notifies the callback function whenever a DDE application creates, frees, or increments the usage count of a string handle or
		///                 whenever a string handle is freed as a result of a call to the <see cref="DdeUninitialize" /> function.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_LINKS 0x20000000</term>
		///             <description>Notifies the callback function whenever an advise loop is started or ended.</description>
		///         </item>
		///         <item>
		///             <term>MF_POSTMSGS 0x04000000</term>
		///             <description>Notifies the callback function whenever the system or an application posts a DDE message.</description>
		///         </item>
		///         <item>
		///             <term>MF_SENDMSGS 0x02000000</term>
		///             <description>Notifies the callback function whenever the system or an application sends a DDE message.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="ulRes">Reserved; must be set to zero.</param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is <see cref="DMLERR_NO_ERROR" />.
		///     </para>
		///     <para>If the function fails, the return value is one of the following values:</para>
		/// </returns>
		/// <remarks>
		///     <para>An application that uses multiple instances of the DDEML must not pass DDEML objects between instances.</para>
		///     <para>
		///         A DDE monitoring application should not attempt to perform DDE operations (establish conversations, issue transactions, and so on) within the
		///         context of the same application instance.
		///     </para>
		///     <para>
		///         A synchronous transaction fails with a <see cref="DMLERR_REENTRANCY" /> error if any instance of the same task has a synchronous transaction
		///         already in progress.
		///     </para>
		///     <para>
		///         The <see cref="CBF_FAIL_ALLSVRXACTIONS" /> flag causes the DDEML to filter all server transactions and can be changed by a subsequent call to
		///         <see cref="DdeInitialize" />. The <see cref="APPCMD_CLIENTONLY" /> flag prevents the DDEML from creating key resources for the server and
		///         cannot be changed by a subsequent call to <see cref="DdeInitialize" />.
		///     </para>
		///     <para>
		///         There is an ANSI version and a Unicode version of <see cref="DdeInitialize" />. The version called determines the type of the window
		///         procedures used to control DDE conversations (ANSI or Unicode), and the default value for the <paramref name="iCodePage" /> member of the
		///         <see cref="CONVCONTEXT" /> structure (<see cref="CP_WINANSI" /> or <see cref="CP_WINUNICODE" />).
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DdeInitialize")]
		public static extern uint DdeInitialize(ref uint pidInst, DdeCallback pfnCallback, uint afCmd, uint ulRes);

		/// <summary>
		///     Establishes a conversation with all server applications that support the specified service name and topic name pair. An application can also use
		///     this function to obtain a list of conversation handles by passing the function an existing conversation handle. The Dynamic Data Exchange
		///     Management Library removes the handles of any terminated conversations from the conversation list. The resulting conversation list contains the
		///     handles of all currently established conversations that support the specified service name and topic name.
		/// </summary>
		/// <param name="idInst">
		///     The application instance identifier obtained by a previous call to the <see cref="DdeInitialize" /> function.
		/// </param>
		/// <param name="hszService">
		///     A handle to the string that specifies the service name of the server application with which a conversation is to be established. If this
		///     parameter is 0L, the system attempts to establish conversations with all available servers that support the specified topic name.
		/// </param>
		/// <param name="hszTopic">
		///     A handle to the string that specifies the name of the topic on which a conversation is to be established. This handle must have been created by a
		///     previous call to the <see cref="DdeCreateStringHandle" /> function. If this parameter is 0L, the system will attempt to establish conversations
		///     on all topics supported by the selected server (or servers).
		/// </param>
		/// <param name="hConvList">
		///     A handle to the conversation list to be enumerated. This parameter should be 0L if a new conversation list is to be
		///     established.
		/// </param>
		/// <param name="pCC">
		///     A pointer to the <see cref="CONVCONTEXT" /> structure that contains conversation-context information. If this parameter is NULL, the server
		///     receives the default <see cref="CONVCONTEXT" /> structure during the <see cref="XTYP_CONNECT" /> or <see cref="XTYP_WILDCONNECT" /> transaction.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the handle to a new conversation list.</para>
		///     <para>If the function fails, the return value is 0L. The handle to the old conversation list is no longer valid.</para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         An application must free the conversation list handle returned by the <see cref="DdeConnectList" /> function, regardless of whether any
		///         conversation handles within the list are active. To free the handle, an application can call <see cref="DdeDisconnectList" />.
		///     </para>
		///     <para>
		///         All members of the default <see cref="CONVCONTEXT" /> structure are set to zero except <paramref name="cb" />, specifying the size of the
		///         structure, and <paramref name="iCodePage" />, specifying <see cref="CP_WINANSI" /> (the default code page) or <see cref="CP_WINUNICODE" />,
		///         depending on whether the ANSI or Unicode version of the <see cref="DdeInitialize" /> function was called by the client application.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DdeConnectList")]
		public static extern IntPtr DdeConnectList(uint idInst, IntPtr hszService, IntPtr hszTopic, IntPtr hConvList, ref CONVCONTEXT pCC);

		/// <summary>
		///     <para>
		///         Creates a new desktop, associates it with the current window station of the calling process, and assigns it to the calling thread. The
		///         calling process must have an associated window station, either assigned by the system at process creation time or set by the
		///         <see cref="SetProcessWindowStation" /> function.
		///     </para>
		///     <para>
		///         To specify the size of the heap for the desktop, use the <see cref="CreateDesktopEx" /> function.
		///     </para>
		/// </summary>
		/// <param name="lpszDesktop">The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters (\).</param>
		/// <param name="lpszDevice">Reserved; must be NULL.</param>
		/// <param name="pDevmode">Reserved; must be NULL.</param>
		/// <param name="dwFlags">
		///     <para>This parameter can be zero or the following value.</para>
		///     <list type="table">
		///         <item>
		///             <term>DF_ALLOWOTHERACCOUNTHOOK 0x0001</term>
		///             <description>Enables processes running in other accounts on the desktop to set hooks in this process.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="dwDesiredAccess">
		///     <para>The access to the desktop. For a list of values, see Desktop Security and Access Rights.</para>
		///     <para>
		///         This parameter must include the DESKTOP_CREATEWINDOW access right, because internally <see cref="CreateDesktop" /> uses the handle to create
		///         a window.
		///     </para>
		/// </param>
		/// <param name="lpsa">
		///     <para>
		///         A pointer to a <see cref="SECURITY_ATTRIBUTES" /> structure that determines whether the returned handle can be inherited by child processes.
		///         If <paramref name="lpsa" /> is NULL, the handle cannot be inherited.
		///     </para>
		///     <para>
		///         The <see cref="lpSecurityDescriptor" /> member of the structure specifies a security descriptor for the new desktop. If this parameter is
		///         NULL, the desktop inherits its security descriptor from the parent window station.
		///     </para>
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is a handle to the newly created desktop. If the specified desktop already exists, the function
		///         succeeds and returns a handle to the existing desktop. When you are finished using the handle, call the <see cref="CloseDesktop" /> function
		///         to close it.
		///     </para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If the <paramref name="dwDesiredAccess" /> parameter specifies the READ_CONTROL, WRITE_DAC, or WRITE_OWNER standard access rights, you must
		///         also request the DESKTOP_READOBJECTS and DESKTOP_WRITEOBJECTS access rights.
		///     </para>
		///     <para>
		///         The number of desktops that can be created is limited by the size of the system desktop heap, which is 48 MB. Desktop objects use the heap to
		///         store resources. You can increase the number of desktops that can be created by reducing the default heap reserved for each desktop in the
		///         interactive window station. This value is specified in the SharedSection substring of the following registry value:
		///         HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\SubSystems\Windows. The default data for this registry value is as
		///         follows:
		///     </para>
		///     <para>
		///         %SystemRoot%\system32\csrss.exe ObjectDirectory=\Windows SharedSection=1024,3072,512 Windows=On SubSystemType=Windows ServerDll=basesrv,1
		///         ServerDll=winsrv:UserServerDllInitialization,3 ServerDll=winsrv:ConServerDllInitialization,2 ProfileControl=Off MaxRequestThreads=16
		///     </para>
		///     <para></para>
		///     <para>The values for the SharedSection substring are described as follows:</para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CreateDesktop")]
		public static extern IntPtr CreateDesktop(
			[In] string lpszDesktop, [In] string lpszDevice, IntPtr pDevmode, DF dwFlags, uint dwDesiredAccess, [In] ref SECURITY_ATTRIBUTES lpsa);

		/// <summary>Closes the clipboard.</summary>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         When the window has finished examining or changing the clipboard, close the clipboard by calling <see cref="CloseClipboard" />. This enables
		///         other windows to access the clipboard.
		///     </para>
		///     <para>
		///         Do not place an object on the clipboard after calling <see cref="CloseClipboard" />.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "CloseClipboard")]
		public static extern bool CloseClipboard();

		/// <summary>
		///     The <see cref="ClientToScreen" /> function converts the client-area coordinates of a specified point to screen coordinates.
		/// </summary>
		/// <param name="hWnd">A handle to the window whose client area is used for the conversion.</param>
		/// <param name="lpPoint">
		///     A pointer to a <see cref="POINT" /> structure that contains the client coordinates to be converted. The new screen coordinates are copied into
		///     this structure if the function succeeds.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="ClientToScreen" /> function replaces the client-area coordinates in the <see cref="POINT" /> structure with the screen
		///         coordinates. The screen coordinates are relative to the upper-left corner of the screen. Note, a screen-coordinate point that is above the
		///         window's client area has a negative y-coordinate. Similarly, a screen coordinate to the left of a client area has a negative x-coordinate.
		///     </para>
		///     <para>All coordinates are device coordinates.</para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "ClientToScreen")]
		public static extern bool ClientToScreen([In] IntPtr hWnd, ref POINT lpPoint);

		/// <summary>Changes the check state of a button control.</summary>
		/// <param name="hDlg">A handle to the dialog box that contains the button.</param>
		/// <param name="nIDButton">The identifier of the button to modify.</param>
		/// <param name="uCheck">
		///     <para>The check state of the button. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>BST_CHECKED</term>
		///             <description>Sets the button state to checked.</description>
		///         </item>
		///         <item>
		///             <term>BST_INDETERMINATE</term>
		///             <description>
		///                 Sets the button state to grayed, indicating an indeterminate state. Use this value only if the button has the
		///                 <see cref="BS_3STATE" /> or <see cref="BS_AUTO3STATE" /> style.
		///             </description>
		///         </item>
		///         <item>
		///             <term>BST_UNCHECKED</term>
		///             <description>Sets the button state to cleared</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     The <see cref="CheckDlgButton" /> function sends a <see cref="BM_SETCHECK" /> message to the specified button control in the specified dialog
		///     box.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "CheckDlgButton")]
		public static extern bool CheckDlgButton([In] IntPtr hDlg, int nIDButton, uint uCheck);

		/// <summary>Converts lowercase characters in a buffer to uppercase characters. The function converts the characters in place.</summary>
		/// <param name="lpsz">A buffer containing one or more characters to be processed.</param>
		/// <param name="cchLength">
		///     <para>
		///         The size, in characters, of the buffer pointed to by <paramref name="lpsz" />.
		///     </para>
		///     <para>
		///         The function examines each character, and converts lowercase characters to uppercase characters. The function examines the number of
		///         characters indicated by <paramref name="cchLength" />, even if one or more characters are null characters.
		///     </para>
		/// </param>
		/// <returns>
		///     <para>The return value is the number of characters processed.</para>
		///     <para>
		///         For example, if <see cref="CharUpperBuff" />("Zenith of API Sets", 10) succeeds, the return value is 10.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Note that <see cref="CharUpperBuff" /> always maps lowercase I ("i") to uppercase I, even when the current language is Turkish or Azeri. If
		///         you need a function that is linguistically sensitive in this respect, call <see cref="LCMapString" />.
		///     </para>
		///     <para>Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.</para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CharUpperBuff")]
		public static extern uint CharUpperBuff(StringBuilder lpsz, uint cchLength);

		/// <summary>Translates a specified number of characters in a string into the OEM-defined character set.</summary>
		/// <param name="lpszSrc">The null-terminated string to be translated.</param>
		/// <param name="lpszDst">
		///     The buffer for the translated string. If the <see cref="CharToOemBuff" /> function is being used as an ANSI function, the string can be
		///     translated in place by setting the <paramref name="lpszDst" /> parameter to the same address as the <paramref name="lpszSrc" /> parameter. This
		///     cannot be done if <see cref="CharToOemBuff" /> is being used as a wide-character function.
		/// </param>
		/// <param name="cchDstLength">
		///     The number of characters to translate in the string identified by the <paramref name="lpszSrc" /> parameter.
		/// </param>
		/// <returns>
		///     The return value is always nonzero except when you pass the same address to <paramref name="lpszSrc" /> and <paramref name="lpszDst" /> in the
		///     wide-character version of the function. In this case the function returns zero and GetLastError returns
		///     <see cref="ERROR_INVALID_ADDRESS" />.
		/// </returns>
		/// <remarks>
		///     Unlike the <see cref="CharToOem" /> function, the <see cref="CharToOemBuff" /> function does not stop converting characters when it encounters a
		///     null character in the buffer pointed to by <paramref name="lpszSrc" />. The <see cref="CharToOemBuff" /> function converts all
		///     <paramref name="cchDstLength" /> characters.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "CharToOemBuff")]
		public static extern bool CharToOemBuff([In] string lpszSrc, [Out] StringBuilder lpszDst, uint cchDstLength);

		/// <summary>Converts uppercase characters in a buffer to lowercase characters. The function converts the characters in place.</summary>
		/// <param name="lpsz">A buffer containing one or more characters to be processed.</param>
		/// <param name="cchLength">
		///     The size, in characters, of the buffer pointed to by <paramref name="lpsz" />. The function examines each character, and converts uppercase
		///     characters to lowercase characters. The function examines the number of characters indicated by <paramref name="cchLength" />, even if one or
		///     more characters are null characters.
		/// </param>
		/// <returns>
		///     The return value is the number of characters processed. For example, if <see cref="CharLowerBuff" />("Acme of Operating Systems", 10) succeeds,
		///     the return value is 10.
		/// </returns>
		/// <remarks>
		///     <para>
		///         Note that <see cref="CharLowerBuff" /> always maps uppercase I to lowercase I ("i"), even when the current language is Turkish or Azeri. If
		///         you need a function that is linguistically sensitive in this respect, call <see cref="LCMapSting" />.
		///     </para>
		///     <para>Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.</para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CharLowerBuff")]
		public static extern uint CharLowerBuff(StringBuilder lpsz, uint cchLength);

		/// <summary>Cascades the specified child windows of the specified parent window.</summary>
		/// <param name="hwndParent">A handle to the parent window. If this parameter is NULL, the desktop window is assumed.</param>
		/// <param name="wHow">
		///     <para>A cascade flag. This parameter can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MDITILE_SKIPDISABLED 0x0002</term>
		///             <description>Prevents disabled MDI child windows from being cascaded.</description>
		///         </item>
		///         <item>
		///             <term>MDITILE_ZORDER 0x0004</term>
		///             <description>
		///                 Arranges the windows in Z order. If this value is not specified, the windows are arranged using the order specified in the
		///                 <paramref name="lpKids" /> array.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="lpRect">
		///     A pointer to a structure that specifies the rectangular area, in client coordinates, within which the windows are arranged. This parameter can be
		///     NULL, in which case the client area of the parent window is used.
		/// </param>
		/// <param name="cKids">
		///     The number of elements in the array specified by the <paramref name="lpKids" /> parameter. This parameter is ignored if
		///     <paramref name="lpKids" /> is NULL.
		/// </param>
		/// <param name="lpKids">
		///     An array of handles to the child windows to arrange. If a specified child window is a top-level window with the style
		///     <see cref="WS_EX.WS_EX_TOPMOST" /> or <see cref="WS_EX.WS_EX_TOOLWINDOW" />, the child window is not arranged. If this parameter is NULL, all child windows
		///     of the specified parent window (or of the desktop window) are arranged.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the number of windows arranged.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         By default, <see cref="CascadeWindows" /> arranges the windows in the order provided by the <paramref name="lpKids" /> array, but preserves
		///         the <see cref="Z-Order" />. If you specify the <see cref="MDITILE_ZORDER" /> flag, <see cref="CascadeWindows" /> arranges the windows in Z
		///         order.
		///     </para>
		///     <para>
		///         Calling <see cref="CascadeWindows" /> causes all maximized windows to be restored to their previous size.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CascadeWindows")]
		public static extern ushort CascadeWindows([In] IntPtr hwndParent, uint wHow, [In] ref RECT lpRect, uint cKids, ref IntPtr lpKids);

		/// <summary>
		///     Passes the hook information to the next hook procedure in the current hook chain. A hook procedure can call this function either before or after
		///     processing the hook information.
		/// </summary>
		/// <param name="hhk">This parameter is ignored.</param>
		/// <param name="nCode">
		///     The hook code passed to the current hook procedure. The next hook procedure uses this code to determine how to process the hook
		///     information.
		/// </param>
		/// <param name="wParam">
		///     The <paramref name="wParam" /> value passed to the current hook procedure. The meaning of this parameter depends on the type of hook associated
		///     with the current hook chain.
		/// </param>
		/// <param name="lParam">
		///     The <paramref name="lParam" /> value passed to the current hook procedure. The meaning of this parameter depends on the type of hook associated
		///     with the current hook chain.
		/// </param>
		/// <returns>
		///     <para>
		///         This value is returned by the next hook procedure in the chain. The current hook procedure must also return this value. The meaning of the
		///         return value depends on the hook type. For more information, see the descriptions of the individual hook procedures.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Hook procedures are installed in chains for particular hook types. <see cref="CallNextHookEx" /> calls the next hook in the chain.
		///     </para>
		///     <para>
		///         Calling <see cref="CallNextHookEx" /> is optional, but it is highly recommended; otherwise, other applications that have installed hooks will
		///         not receive hook notifications and may behave incorrectly as a result. You should call <see cref="CallNextHookEx" /> unless you absolutely
		///         need to prevent the notification from being seen by other applications.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CallNextHookEx")]
		public static extern IntPtr CallNextHookEx(
			[In] IntPtr hhk, int nCode, IntPtr wParam, IntPtr lParam);

		/// <summary>
		///     Passes the specified message and hook code to the hook procedures associated with the WH_SYSMSGFILTER and WH_MSGFILTER hooks. A
		///     <see cref="WH_SYSMSGFILTER" /> or <see cref="WH_MSGFILTER" /> hook procedure is an application-defined callback function that examines and,
		///     optionally, modifies messages for a dialog box, message box, menu, or scroll bar.
		/// </summary>
		/// <param name="lpMsg">
		///     A pointer to an <see cref="MSG" /> structure that contains the message to be passed to the hook procedures.
		/// </param>
		/// <param name="nCode">
		///     An application-defined code used by the hook procedure to determine how to process the message. The code must not have the same value as
		///     system-defined hook codes (MSGF_ and HC_) associated with the <see cref="WH_SYSMSGFILTER" /> and <see cref="WH_MSGFILTER" /> hooks.
		/// </param>
		/// <returns>
		///     <para>If the application should process the message further, the return value is zero.</para>
		///     <para>If the application should not process the message further, the return value is nonzero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The system calls <see cref="CallMsgFilter" /> to enable applications to examine and control the flow of messages during internal processing
		///         of dialog boxes, message boxes, menus, and scroll bars, or when the user activates a different window by pressing the ALT+TAB key
		///         combination.
		///     </para>
		///     <para>
		///         Install this hook procedure by using the <see cref="SetWindowsHookEx" /> function.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CallMsgFilter")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool CallMsgFilter([In] ref MSG lpMsg, int nCode);

		/// <summary>
		///     Makes the specified desktop visible and activates it. This enables the desktop to receive input from the user. The calling process must have
		///     DESKTOP_SWITCHDESKTOP access to the desktop for the <see cref="SwitchDesktop" /> function to succeed.
		/// </summary>
		/// <param name="hDesktop">
		///     <para>
		///         A handle to the desktop. This handle is returned by the <see cref="CreateDesktop" /> and <see cref="OpenDesktop" /> functions.
		///     </para>
		///     <para>This desktop must be associated with the current window station for the process.</para>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>
		///         If the function fails, the return value is zero. To get extended error information, call GetLastError. However,
		///         <see cref="SwitchDesktop" /> only sets the last error for the following cases:
		///     </para>
		/// </returns>
		/// <remarks>
		///     The <see cref="SwitchDesktop" /> function fails if the desktop belongs to an invisible window station. <see cref="SwitchDesktop" /> also fails
		///     when called from a process that is associated with a secured desktop such as the WinLogon and ScreenSaver desktops. Processes that are associated
		///     with a secured desktop include custom UserInit processes. Such calls typically fail with an "access denied" error.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SwitchDesktop")]
		public static extern bool SwitchDesktop([In] IntPtr hDesktop);

		/// <summary>
		///     The <see cref="ShowScrollBar" /> function shows or hides the specified scroll bar.
		/// </summary>
		/// <param name="hWnd">
		///     Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the <paramref name="wBar" /> parameter.
		/// </param>
		/// <param name="wBar">
		///     <para>Specifies the scroll bar(s) to be shown or hidden. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>SB_BOTH</term>
		///             <description>Shows or hides a window's standard horizontal and vertical scroll bars.</description>
		///         </item>
		///         <item>
		///             <term>SB_CTL</term>
		///             <description>
		///                 Shows or hides a scroll bar control. The <paramref name="hwnd" /> parameter must be the handle to the scroll bar control.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SB_HORZ</term>
		///             <description>Shows or hides a window's standard horizontal scroll bars.</description>
		///         </item>
		///         <item>
		///             <term>SB_VERT</term>
		///             <description>Shows or hides a window's standard vertical scroll bar.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="bShow">Specifies whether the scroll bar is shown or hidden. If this parameter is TRUE, the scroll bar is shown; otherwise, it is hidden.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>You should not call this function to hide a scroll bar while processing a scroll bar message.</remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "ShowScrollBar")]
		public static extern bool ShowScrollBar([In] IntPtr hWnd, int wBar, [MarshalAs(UnmanagedType.Bool)] bool bShow);

		[DllImport("user32.dll", EntryPoint = "SetWindowWord")]
		public static extern ushort SetWindowWord([In] IntPtr hWnd, int nIndex, ushort wNewWord);

		/// <summary>
		///     The <see cref="SetScrollInfo" /> function sets the parameters of a scroll bar, including the minimum and maximum scrolling positions, the page
		///     size, and the position of the scroll box (thumb). The function also redraws the scroll bar, if requested.
		/// </summary>
		/// <param name="hwnd">
		///     Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the <paramref name="fnBar" /> parameter.
		/// </param>
		/// <param name="fnBar">
		///     <para>Specifies the type of scroll bar for which to set parameters. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>SB_CTL</term>
		///             <description>
		///                 Sets the parameters of a scroll bar control. The <paramref name="hwnd" /> parameter must be the handle to the scroll bar control.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SB_HORZ</term>
		///             <description>Sets the parameters of the window's standard horizontal scroll bar.</description>
		///         </item>
		///         <item>
		///             <term>SB_VERT</term>
		///             <description>Sets the parameters of the window's standard vertical scroll bar.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="lpsi">
		///     <para>
		///         Pointer to a <see cref="SCROLLINFO" /> structure. Before calling <see cref="SetScrollInfo" />, set the <see cref="cbSize" /> member of the
		///         structure to sizeof(<see cref="SCROLLINFO" />), set the <see cref="fMask" /> member to indicate the parameters to set, and
		///         specify the new parameter values in the appropriate members.
		///     </para>
		///     <para>
		///         The <see cref="fMask" /> member can be one or more of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>SIF_DISABLENOSCROLL</term>
		///             <description>Disables the scroll bar instead of removing it, if the scroll bar's new parameters make the scroll bar unnecessary.</description>
		///         </item>
		///         <item>
		///             <term>SIF_PAGE</term>
		///             <description>
		///                 Sets the scroll page to the value specified in the <see cref="nPage" /> member of the <see cref="SCROLLINFO" /> structure pointed to
		///                 by <paramref name="lpsi" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SIF_POS</term>
		///             <description>
		///                 Sets the scroll position to the value specified in the <see cref="nPos" /> member of the <see cref="SCROLLINFO" /> structure pointed
		///                 to by <paramref name="lpsi" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SIF_RANGE</term>
		///             <description>
		///                 Sets the scroll range to the value specified in the <see cref="nMin" /> and <see cref="nMax" /> members of the
		///                 <see cref="SCROLLINFO" /> structure pointed to by <paramref name="lpsi" />.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="fRedraw">
		///     Specifies whether the scroll bar is redrawn to reflect the changes to the scroll bar. If this parameter is TRUE, the scroll bar is redrawn,
		///     otherwise, it is not redrawn.
		/// </param>
		/// <returns>The return value is the current position of the scroll box.</returns>
		/// <remarks>
		///     <para>
		///         The <see cref="SetScrollInfo" /> function performs range checking on the values specified by the <see cref="nPage" /> and <see cref="nPos" />
		///         members of the <see cref="SCROLLINFO" /> structure. The <see cref="nPage" /> member must specify a value from 0 to <see cref="nMax" /> -
		///         <see cref="nMin" /> +1. The <see cref="nPos" /> member must specify a value between <see cref="nMin" /> and <see cref="nMax" /> -
		///         <see cref="max" />( <see cref="nPage" />– 1, 0). If either value is beyond its range, the function sets it to a value that is just within the
		///         range.
		///     </para>
		///     <para>
		///         If the <paramref name="fnBar" /> parameter is SB_CTL and the window specified by the <paramref name="hwnd" /> parameter is not a system
		///         scroll bar control, the system sends the <see cref="SBM_SETSCROLLINFO" /> message to the window to set scroll bar information (The system can
		///         optimize the message to <see cref="SBM_SETPOS" /> or <see cref="SBM_SETRANGE" /> if the request is solely for the position or range). This
		///         allows <see cref="SetScrollInfo" /> to operate on a custom control that mimics a scroll bar. If the window does not handle
		///         <see cref="SBM_SETSCROLLINFO" /> (or the optimized <see cref="SBM_SETPOS" /> message or <see cref="SBM_SETRANGE" /> message), then the
		///         <see cref="SetScrollInfo" /> function fails.
		///     </para>
		///     <para>For an example, see Scrolling Text with the WM_PAINT Message.</para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetScrollInfo")]
		public static extern int SetScrollInfo([In] IntPtr hwnd, int nBar, [In] ref SCROLLINFO lpsi, [MarshalAs(UnmanagedType.Bool)] bool redraw);

		/// <summary>Sets the text of a control in a dialog box to the string representation of a specified integer value.</summary>
		/// <param name="hDlg">A handle to the dialog box that contains the control.</param>
		/// <param name="nIDDlgItem">The control to be changed.</param>
		/// <param name="uValue">The integer value used to generate the item text.</param>
		/// <param name="bSigned">
		///     Indicates whether the <paramref name="uValue" /> parameter is signed or unsigned. If this parameter is TRUE, <paramref name="uValue" /> is
		///     signed. If this parameter is TRUE and <paramref name="uValue" /> is less than zero, a minus sign is placed before the first digit in the string.
		///     If this parameter is FALSE, <paramref name="uValue" /> is unsigned.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     To set the new text, this function sends a <see cref="WM.WM_SETTEXT" /> message to the specified control.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetDlgItemInt")]
		public static extern bool SetDlgItemInt([In] IntPtr hDlg, int nIDDlgItem, uint uValue, [MarshalAs(UnmanagedType.Bool)] bool bSigned);

		/// <summary>
		///     <para>
		///         Replaces the specified 32-bit (<see cref="long" />) value at the specified offset into the extra class memory or the
		///         <see cref="WNDCLASSEX" /> structure for the class to which the specified window belongs.
		///     </para>
		///     <para>
		///         Note:  This function has been superseded by the <see cref="SetClassLongPtr" /> function. To write code that is compatible with
		///         both 32-bit and 64-bit versions of Windows, use <see cref="SetClassLongPtr" />.
		///     </para>
		/// </summary>
		/// <param name="hWnd">A handle to the window and, indirectly, the class to which the window belongs.</param>
		/// <param name="nIndex">
		///     <para>
		///         The value to be replaced. To set a 32-bit value in the extra class memory, specify the positive, zero-based byte offset of the value to be
		///         set. Valid values are in the range zero through the number of bytes of extra class memory, minus four; for example, if you specified 12 or
		///         more bytes of extra class memory, a value of 8 would be an index to the third 32-bit integer. To set any other value from the
		///         <see cref="WNDCLASSEX" /> structure, specify one of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>GCL_CBCLSEXTRA -20</term>
		///             <description>
		///                 Sets the size, in bytes, of the extra memory associated with the class. Setting this value does not change the number of extra bytes
		///                 already allocated.
		///             </description>
		///         </item>
		///         <item>
		///             <term>GCL_CBWNDEXTRA -18</term>
		///             <description>
		///                 Sets the size, in bytes, of the extra window memory associated with each window in the class. Setting this value does not change the
		///                 number of extra bytes already allocated. For information on how to access this memory, see <see cref="SetWindowLong" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>GCL_HBRBACKGROUND -10</term>
		///             <description>Replaces a handle to the background brush associated with the class.</description>
		///         </item>
		///         <item>
		///             <term>GCL_HCURSOR -12</term>
		///             <description>Replaces a handle to the cursor associated with the class.</description>
		///         </item>
		///         <item>
		///             <term>GCL_HICON -14</term>
		///             <description>Replaces a handle to the icon associated with the class.</description>
		///         </item>
		///         <item>
		///             <term>GCL_HICONSM -34</term>
		///             <description>Replace a handle to the small icon associated with the class.</description>
		///         </item>
		///         <item>
		///             <term>GCL_HMODULE -16</term>
		///             <description>Replaces a handle to the module that registered the class.</description>
		///         </item>
		///         <item>
		///             <term>GCL_MENUNAME -8</term>
		///             <description>Replaces the address of the menu name string. The string identifies the menu resource associated with the class.</description>
		///         </item>
		///         <item>
		///             <term>GCL_STYLE -26</term>
		///             <description>Replaces the window-class style bits.</description>
		///         </item>
		///         <item>
		///             <term>GCL_WNDPROC -24</term>
		///             <description>Replaces the address of the window procedure associated with the class.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="dwNewLong">The replacement value.</param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is the previous value of the specified 32-bit integer. If the value was not previously set, the
		///         return value is zero.
		///     </para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If you use the <see cref="SetClassLong" /> function and the <see cref="GCL_WNDPROC" /> index to replace the window procedure, the window
		///         procedure must conform to the guidelines specified in the description of the <see cref="WindowProc" /> callback function.
		///     </para>
		///     <para>
		///         Calling <see cref="SetClassLong" /> with the <see cref="GCL_WNDPROC" /> index creates a subclass of the window class that affects all windows
		///         subsequently created with the class. An application can subclass a system class, but should not subclass a window class created by another
		///         process.
		///     </para>
		///     <para>
		///         Reserve extra class memory by specifying a nonzero value in the <see cref="cbClsExtra" /> member of the <see cref="WNDCLASSEX" /> structure
		///         used with the <see cref="RegisterClassEx" /> function.
		///     </para>
		///     <para>
		///         Use the <see cref="SetClassLong" /> function with care. For example, it is possible to change the background color for a class by using
		///         <see cref="SetClassLong" />, but this change does not immediately repaint all windows belonging to the class.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetClassLong")]
		public static extern uint SetClassLong([In] IntPtr hWnd, int nIndex, int dwNewLong);

		/// <summary>
		///     Packs a Dynamic Data Exchange (DDE) <paramref name="lParam" /> value into an internal structure used for sharing DDE data between processes.
		/// </summary>
		/// <param name="msg">The DDE message to be posted.</param>
		/// <param name="uiLo">
		///     A value that corresponds to the 16-bit Windows low-order word of an <paramref name="lParam" /> parameter for the DDE message being posted.
		/// </param>
		/// <param name="uiHi">
		///     A value that corresponds to the 16-bit Windows high-order word of an <paramref name="lParam" /> parameter for the DDE message being posted.
		/// </param>
		/// <returns>
		///     The return value is the <paramref name="lParam" /> value.
		/// </returns>
		/// <remarks>
		///     <para>
		///         The return value must be posted as the <paramref name="lParam" /> parameter of a DDE message; it must not be used for any other purpose.
		///         After the application posts a return value, it need not perform any action to dispose of the <paramref name="lParam" /> parameter.
		///     </para>
		///     <para>An application should call this function only for posted DDE messages.</para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.SysInt)]
		[DllImport("user32.dll", EntryPoint = "PackDDElParam")]
		public static extern int PackDDElParam(uint msg, [MarshalAs(UnmanagedType.SysUInt)] uint uiLo, [MarshalAs(UnmanagedType.SysUInt)] uint uiHi);

		/// <summary>Opens the clipboard for examination and prevents other applications from modifying the clipboard content.</summary>
		/// <param name="hWndNewOwner">
		///     A handle to the window to be associated with the open clipboard. If this parameter is NULL, the open clipboard is
		///     associated with the current task.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         <see cref="OpenClipboard" /> fails if another window has the clipboard open.
		///     </para>
		///     <para>
		///         An application should call the <see cref="CloseClipboard" /> function after every successful call to <see cref="OpenClipboard" />.
		///     </para>
		///     <para>
		///         The window identified by the <paramref name="hWndNewOwner" /> parameter does not become the clipboard owner unless the
		///         <see cref="EmptyClipboard" /> function is called.
		///     </para>
		///     <para>
		///         If an application calls <see cref="OpenClipboard" /> with hwnd set to NULL, <see cref="EmptyClipboard" /> sets the clipboard owner to NULL;
		///         this causes <see cref="SetClipboardData" /> to fail.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "OpenClipboard")]
		public static extern bool OpenClipboard([In] IntPtr hWndNewOwner);

		/// <summary>
		///     Displays a modal dialog box that contains a system icon, a set of buttons, and a brief application-specific message, such as status or error
		///     information. The message box returns an integer value that indicates which button the user clicked.
		/// </summary>
		/// <param name="hWnd">A handle to the owner window of the message box to be created. If this parameter is NULL, the message box has no owner window.</param>
		/// <param name="lpText">
		///     The message to be displayed. If the string consists of more than one line, you can separate the lines using a carriage return and/or linefeed
		///     character between each line.
		/// </param>
		/// <param name="lpCaption">
		///     The dialog box title. If this parameter is NULL, the default title is <see cref="Error" />.
		/// </param>
		/// <param name="uType">
		///     <para>The contents and behavior of the dialog box. This parameter can be a combination of flags from the following groups of flags.</para>
		///     <para>To indicate the buttons displayed in the message box, specify one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MB_ABORTRETRYIGNORE 0x00000002L</term>
		///             <description>
		///                 The message box contains three push buttons: <see cref="Abort" />, <see cref="Retry" />, and <see cref="Ignore" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_CANCELTRYCONTINUE 0x00000006L</term>
		///             <description>
		///                 The message box contains three push buttons: <see cref="Cancel" />, Try Again, <see cref="Continue" />. Use this message box type
		///                 instead of MB_ABORTRETRYIGNORE.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_HELP 0x00004000L</term>
		///             <description>
		///                 Adds a <see cref="Help" /> button to the message box. When the user clicks the <see cref="Help" /> button or presses F1, the system
		///                 sends a <see cref="WM.WM_HELP" /> message to the owner.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_OK 0x00000000L</term>
		///             <description>
		///                 The message box contains one push button: OK. This is the default.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_OKCANCEL 0x00000001L</term>
		///             <description>
		///                 The message box contains two push buttons: OK and <see cref="Cancel" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_RETRYCANCEL 0x00000005L</term>
		///             <description>
		///                 The message box contains two push buttons: <see cref="Retry" /> and <see cref="Cancel" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_YESNO 0x00000004L</term>
		///             <description>
		///                 The message box contains two push buttons: <see cref="Yes" /> and <see cref="No" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_YESNOCANCEL 0x00000003L</term>
		///             <description>
		///                 The message box contains three push buttons: <see cref="Yes" />, <see cref="No" />, and <see cref="Cancel" />.
		///             </description>
		///         </item>
		///     </list>
		///     <para>To display an icon in the message box, specify one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MB_ICONEXCLAMATION 0x00000030L</term>
		///             <description>An exclamation-point icon appears in the message box.</description>
		///         </item>
		///         <item>
		///             <term>MB_ICONWARNING 0x00000030L</term>
		///             <description>An exclamation-point icon appears in the message box.</description>
		///         </item>
		///         <item>
		///             <term>MB_ICONINFORMATION 0x00000040L</term>
		///             <description>
		///                 An icon consisting of a lowercase letter <paramref name="i" /> in a circle appears in the message box.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_ICONASTERISK 0x00000040L</term>
		///             <description>
		///                 An icon consisting of a lowercase letter <paramref name="i" /> in a circle appears in the message box.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_ICONQUESTION 0x00000020L</term>
		///             <description>
		///                 A question-mark icon appears in the message box. The question-mark message icon is no longer recommended because it does not clearly
		///                 represent a specific type of message and because the phrasing of a message as a question could apply to any message type. In
		///                 addition, users can confuse the message symbol question mark with Help information. Therefore, do not use this question mark message
		///                 symbol in your message boxes. The system continues to support its inclusion only for backward compatibility.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_ICONSTOP 0x00000010L</term>
		///             <description>A stop-sign icon appears in the message box.</description>
		///         </item>
		///         <item>
		///             <term>MB_ICONERROR 0x00000010L</term>
		///             <description>A stop-sign icon appears in the message box.</description>
		///         </item>
		///         <item>
		///             <term>MB_ICONHAND 0x00000010L</term>
		///             <description>A stop-sign icon appears in the message box.</description>
		///         </item>
		///     </list>
		///     <para>To indicate the default button, specify one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MB_DEFBUTTON1 0x00000000L</term>
		///             <description>
		///                 <para>The first button is the default button.</para>
		///                 <para>
		///                     <see cref="MB.MB_DEFBUTTON1" /> is the default unless <see cref="MB.MB_DEFBUTTON2" />, <see cref="MB.MB_DEFBUTTON3" />, or
		///                     <see cref="MB.MB_DEFBUTTON4" /> is specified.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_DEFBUTTON2 0x00000100L</term>
		///             <description>The second button is the default button.</description>
		///         </item>
		///         <item>
		///             <term>MB_DEFBUTTON3 0x00000200L</term>
		///             <description>The third button is the default button.</description>
		///         </item>
		///         <item>
		///             <term>MB_DEFBUTTON4 0x00000300L</term>
		///             <description>The fourth button is the default button.</description>
		///         </item>
		///     </list>
		///     <para>To indicate the modality of the dialog box, specify one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MB_APPLMODAL 0x00000000L</term>
		///             <description>
		///                 <para>
		///                     The user must respond to the message box before continuing work in the window identified by the <paramref name="hWnd" />
		///                     parameter. However, the user can move to the windows of other threads and work in those windows.
		///                 </para>
		///                 <para>
		///                     Depending on the hierarchy of windows in the application, the user may be able to move to other windows within the thread. All
		///                     child windows of the parent of the message box are automatically disabled, but pop-up windows are not.
		///                 </para>
		///                 <para>
		///                     <see cref="MB.MB_APPLMODAL" /> is the default if neither <see cref="MB.MB_SYSTEMMODAL" /> nor <see cref="MB.MB_TASKMODAL" /> is specified.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_SYSTEMMODAL 0x00001000L</term>
		///             <description>
		///                 Same as MB_APPLMODAL except that the message box has the <see cref="WS_EX.WS_EX_TOPMOST" /> style. Use system-modal message boxes to notify
		///                 the user of serious, potentially damaging errors that require immediate attention (for example, running out of memory). This flag has
		///                 no effect on the user's ability to interact with windows other than those associated with <paramref name="hWnd" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_TASKMODAL 0x00002000L</term>
		///             <description>
		///                 Same as <see cref="MB.MB_APPLMODAL" /> except that all the top-level windows belonging to the current thread are disabled if the
		///                 <paramref name="hWnd" /> parameter is NULL. Use this flag when the calling application or library does not have a window handle
		///                 available but still needs to prevent input to other windows in the calling thread without suspending other threads.
		///             </description>
		///         </item>
		///     </list>
		///     <para>To specify other options, use one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MB_DEFAULT_DESKTOP_ONLY 0x00020000L</term>
		///             <description>
		///                 <para>Same as desktop of the interactive window station. For more information, see Window Stations.</para>
		///                 <para>
		///                     If the current input desktop is not the default desktop, <see cref="MessageBox" /> does not return until the user switches to the
		///                     default desktop.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_RIGHT 0x00080000L</term>
		///             <description>The text is right-justified.</description>
		///         </item>
		///         <item>
		///             <term>MB_RTLREADING 0x00100000L</term>
		///             <description>Displays message and caption text using right-to-left reading order on Hebrew and Arabic systems.</description>
		///         </item>
		///         <item>
		///             <term>MB_SETFOREGROUND 0x00010000L</term>
		///             <description>
		///                 The message box becomes the foreground window. Internally, the system calls the <see cref="SetForegroundWindow" /> function for the
		///                 message box.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_TOPMOST 0x00040000L</term>
		///             <description>
		///                 The message box is created with the <see cref="WS_EX.WS_EX_TOPMOST" /> window style.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_SERVICE_NOTIFICATION 0x00200000L</term>
		///             <description>
		///                 <para>
		///                     The caller is a service notifying the user of an event. The function displays a message box on the current active desktop, even
		///                     if there is no user logged on to the computer.
		///                 </para>
		///                 <para>
		///                     Terminal Services: If the calling thread has an impersonation token, the function directs the message box to the session
		///                     specified in the impersonation token.
		///                 </para>
		///                 <para>
		///                     If this flag is set, the <paramref name="hWnd" /> parameter must be NULL. This is so that the message box can appear on a desktop
		///                     other than the desktop corresponding to the <paramref name="hWnd" />.
		///                 </para>
		///                 <para>
		///                     For information on security considerations in regard to using this flag, see Interactive Services. In particular, be aware that
		///                     this flag can produce interactive content on a locked desktop and should therefore be used for only a very limited set of
		///                     scenarios, such as resource exhaustion.
		///                 </para>
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>
		///         If a message box has a Cancel button, the function returns the IDCANCEL value if either the ESC key is pressed
		///         or the Cancel button is selected. If the message box has no Cancel button, pressing ESC has no effect.
		///     </para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		///     <para>If the function succeeds, the return value is one of the following menu-item values.</para>
		/// </returns>
		/// <remarks>
		///     The following system icons can be used in a message box by setting the <paramref name="uType" /> parameter to the corresponding flag value.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "MessageBoxEx")]
		public static extern int MessageBoxEx([In] IntPtr hWnd, [In] string lpText, [In] string lpCaption, uint uType, ushort wLanguageId);

		/// <summary>
		///     Converts the specified dialog box units to screen units (pixels). The function replaces the coordinates in the specified <see cref="RECT" />
		///     structure with the converted coordinates, which allows the structure to be used to create a dialog box or position a control within a dialog box.
		/// </summary>
		/// <param name="hDlg">
		///     A handle to a dialog box. This function accepts only handles returned by one of the dialog box creation functions; handles for other windows are
		///     not valid.
		/// </param>
		/// <param name="lpRect">
		///     A pointer to a <see cref="RECT" /> structure that contains the dialog box coordinates to be converted.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     The <see cref="MapDialogRect" /> function assumes that the initial coordinates in the <see cref="RECT" /> structure represent dialog box units.
		///     To convert these coordinates from dialog box units to pixels, the function retrieves the current horizontal and vertical base units for the
		///     dialog box, then applies the following formulas:
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "MapDialogRect")]
		public static extern bool MapDialogRect([In] IntPtr hDlg, ref RECT lpRect);

		/// <summary>
		///     The <see cref="InvalidateRgn" /> function invalidates the client area within the specified region by adding it to the current update region of a
		///     window. The invalidated region, along with all other areas in the update region, is marked for painting when the next <see cref="WM.WM_PAINT" />
		///     message occurs.
		/// </summary>
		/// <param name="hWnd">A handle to the window with an update region that is to be modified.</param>
		/// <param name="hRgn">
		///     A handle to the region to be added to the update region. The region is assumed to have client coordinates. If this parameter is NULL, the entire
		///     client area is added to the update region.
		/// </param>
		/// <param name="bErase">
		///     Specifies whether the background within the update region should be erased when the update region is processed. If this parameter is TRUE, the
		///     background is erased when the <see cref="BeginPaint" /> function is called. If the parameter is FALSE, the background remains unchanged.
		/// </param>
		/// <returns>The return value is always nonzero.</returns>
		/// <remarks>
		///     <para>
		///         Invalidated areas accumulate in the update region until the next <see cref="WM.WM_PAINT" /> message is processed or until the region is
		///         validated by using the <see cref="ValidateRect" /> or <see cref="ValidateRgn" /> function.
		///     </para>
		///     <para>
		///         The system sends a <see cref="WM.WM_PAINT" /> message to a window whenever its update region is not empty and there are no other messages in
		///         the application queue for that window.
		///     </para>
		///     <para>The specified region must have been created by using one of the region functions.</para>
		///     <para>
		///         If the <paramref name="bErase" /> parameter is TRUE for any part of the update region, the background in the entire region is erased, not
		///         just in the specified part.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "InvalidateRgn")]
		public static extern bool InvalidateRgn([In] IntPtr hWnd, [In] IntPtr hRgn, [MarshalAs(UnmanagedType.Bool)] bool bErase);

		/// <summary>
		///     The <see cref="IntersectRect" /> function calculates the intersection of two source rectangles and places the coordinates of the intersection
		///     rectangle into the destination rectangle. If the source rectangles do not intersect, an empty rectangle (in which all coordinates are set to
		///     zero) is placed into the destination rectangle.
		/// </summary>
		/// <param name="lprcDst">
		///     A pointer to the <see cref="RECT" /> structure that is to receive the intersection of the rectangles pointed to by the
		///     <paramref name="lprcSrc1" /> and <paramref name="lprcSrc2" /> parameters. This parameter cannot be NULL.
		/// </param>
		/// <param name="lprcSrc1">
		///     A pointer to the <see cref="RECT" /> structure that contains the first source rectangle.
		/// </param>
		/// <param name="lprcSrc2">
		///     A pointer to the <see cref="RECT" /> structure that contains the second source rectangle.
		/// </param>
		/// <returns>
		///     <para>If the rectangles intersect, the return value is nonzero.</para>
		///     <para>If the rectangles do not intersect, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all
		///     rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used
		///     determine the units of measure.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "IntersectRect")]
		public static extern bool IntersectRect([Out] out RECT lprcDst, [In] ref RECT lprcSrc1, [In] ref RECT lprcSrc2);

		/// <summary>
		///     <para>
		///         Determines whether the current window procedure is processing a message that was sent from another thread (in the same process or a different
		///         process) by a call to the <see cref="SendMessage" /> function.
		///     </para>
		///     <para>
		///         To obtain additional information about how the message was sent, use the <see cref="InSendMessageEx" /> function.
		///     </para>
		/// </summary>
		/// <returns>
		///     <para>
		///         If the window procedure is processing a message sent to it from another thread using the <see cref="SendMessage" /> function, the return
		///         value is nonzero.
		///     </para>
		///     <para>
		///         If the window procedure is not processing a message sent to it from another thread using the <see cref="SendMessage" /> function, the return
		///         value is zero.
		///     </para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "InSendMessage")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool InSendMessage();

		[DllImport("user32.dll", EntryPoint = "GetWindowWord")]
		public static extern ushort GetWindowWord([In] IntPtr hWnd, int nIndex);

		/// <summary>
		///     Retrieves the dimensions of the bounding rectangle of the specified window. The dimensions are given in screen coordinates that are relative to
		///     the upper-left corner of the screen.
		/// </summary>
		/// <param name="hWnd">A handle to the window.</param>
		/// <param name="lpRect">
		///     A pointer to a <see cref="RECT" /> structure that receives the screen coordinates of the upper-left and lower-right corners of the window.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     In conformance with conventions for the <see cref="RECT" /> structure, the bottom-right coordinates of the returned rectangle are exclusive. In
		///     other words, the pixel at (<see cref="RECT.right" />, <see cref="RECT.bottom" />) lies immediately outside the rectangle.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetWindowRect")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool GetWindowRect([In] IntPtr hWnd, [Out] out RECT lpRect);

		/// <summary>Retrieves information about the specified window.</summary>
		/// <param name="hwnd">A handle to the window whose information is to be retrieved.</param>
		/// <param name="pwi">
		///     A pointer to a <see cref="WINDOWINFO" /> structure to receive the information. Note that you must set the <see cref="WINDOWINFO.cbSize" /> member to
		///     sizeof(WINDOWINFO) before calling this function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		///     <para>To get extended error information, call GetLastError.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetWindowInfo")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool GetWindowInfo([In] IntPtr hwnd, ref WINDOWINFO pwi);

		/// <summary>
		///     The <see cref="GetUpdateRect" /> function retrieves the coordinates of the smallest rectangle that completely encloses the update region of the
		///     specified window. <see cref="GetUpdateRect" /> retrieves the rectangle in logical coordinates. If there is no update region,
		///     <see cref="GetUpdateRect" /> retrieves an empty rectangle (sets all coordinates to zero).
		/// </summary>
		/// <param name="hWnd">Handle to the window whose update region is to be retrieved.</param>
		/// <param name="lpRect">
		///     <para>
		///         Pointer to the <see cref="RECT" /> structure that receives the coordinates, in device units, of the enclosing rectangle.
		///     </para>
		///     <para>
		///         An application can set this parameter to NULL to determine whether an update region exists for the window. If this parameter is NULL,
		///         <see cref="GetUpdateRect" /> returns nonzero if an update region exists, and zero if one does not. This provides a simple and efficient means
		///         of determining whether a <see cref="WM.WM_PAINT" /> message resulted from an invalid area.
		///     </para>
		/// </param>
		/// <param name="bErase">
		///     Specifies whether the background in the update region is to be erased. If this parameter is TRUE and the update region is not empty,
		///     <see cref="GetUpdateRect" /> sends a <see cref="WM.WM_ERASEBKGND" /> message to the specified window to erase the background.
		/// </param>
		/// <returns>
		///     <para>If the update region is not empty, the return value is nonzero.</para>
		///     <para>If there is no update region, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The update rectangle retrieved by the <see cref="BeginPaint" /> function is identical to that retrieved by <see cref="GetUpdateRect" />.
		///     </para>
		///     <para>
		///         <see cref="BeginPaint" /> automatically validates the update region, so any call to <see cref="GetUpdateRect" /> made immediately after the
		///         call to <see cref="BeginPaint" /> retrieves an empty update region.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetUpdateRect")]
		public static extern bool GetUpdateRect([In] IntPtr hWnd, ref RECT lpRect, [MarshalAs(UnmanagedType.Bool)] bool bErase);

		/// <summary>Enables the application to access the window menu (also known as the system menu or the control menu) for copying and modifying.</summary>
		/// <param name="hWnd">A handle to the window that will own a copy of the window menu.</param>
		/// <param name="bRevert">
		///     The action to be taken. If this parameter is FALSE, <see cref="GetSystemMenu" /> returns a handle to the copy of the window menu currently in
		///     use. The copy is initially identical to the window menu, but it can be modified. If this parameter is TRUE, <see cref="GetSystemMenu" /> resets
		///     the window menu back to the default state. The previous window menu, if any, is destroyed.
		/// </param>
		/// <returns>
		///     If the <paramref name="bRevert" /> parameter is FALSE, the return value is a handle to a copy of the window menu. If the
		///     <paramref name="bRevert" /> parameter is TRUE, the return value is NULL.
		/// </returns>
		/// <remarks>
		///     <para>
		///         Any window that does not use the <see cref="GetSystemMenu" /> function to make its own copy of the window menu receives the standard window
		///         menu.
		///     </para>
		///     <para>
		///         The window menu initially contains items with various identifier values, such as <see cref="SC_CLOSE" />, <see cref="SC_MOVE" />, and
		///         <see cref="SC_SIZE" />.
		///     </para>
		///     <para>
		///         Menu items on the window menu send <see cref="WM.WM_SYSCOMMAND" /> messages.
		///     </para>
		///     <para>
		///         All predefined window menu items have identifier numbers greater than 0xF000. If an application adds commands to the window menu, it should
		///         use identifier numbers less than 0xF000.
		///     </para>
		///     <para>
		///         The system automatically grays items on the standard window menu, depending on the situation. The application can perform its own checking or
		///         graying by responding to the <see cref="WM.WM_INITMENU" /> message that is sent before any menu is displayed.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetSystemMenu")]
		public static extern IntPtr GetSystemMenu([In] IntPtr hWnd, [MarshalAs(UnmanagedType.Bool)] bool bRevert);

		/// <summary>
		///     The <see cref="GetScrollInfo" /> function retrieves the parameters of a scroll bar, including the minimum and maximum scrolling positions, the
		///     page size, and the position of the scroll box (thumb).
		/// </summary>
		/// <param name="hwnd">
		///     Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the <paramref name="fnBar" /> parameter.
		/// </param>
		/// <param name="fnBar">
		///     <para>Specifies the type of scroll bar for which to retrieve parameters. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>SB_CTL</term>
		///             <description>
		///                 Retrieves the parameters for a scroll bar control. The <paramref name="hwnd" /> parameter must be the handle to the scroll bar
		///                 control.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SB_HORZ</term>
		///             <description>Retrieves the parameters for the window's standard horizontal scroll bar.</description>
		///         </item>
		///         <item>
		///             <term>SB_VERT</term>
		///             <description>Retrieves the parameters for the window's standard vertical scroll bar.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="lpsi">
		///     <para>
		///         Pointer to a <see cref="SCROLLINFO" /> structure. Before calling <see cref="GetScrollInfo" />, set the <see cref="SCROLLINFO.cbSize" /> member to
		///         sizeof(<see cref="SCROLLINFO" />), and set the <see cref="SCROLLINFO.fMask" /> member to specify the scroll bar parameters to retrieve.
		///         Before returning, the function copies the specified parameters to the appropriate members of the structure.
		///     </para>
		///     <para>
		///         The <see cref="SCROLLINFO.fMask" /> member can be one or more of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>SIF_PAGE</term>
		///             <description>
		///                 Copies the scroll page to the <see cref="SCROLLINFO.nPage" /> member of the <see cref="SCROLLINFO" /> structure pointed to by
		///                 <paramref name="lpsi" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SIF_POS</term>
		///             <description>
		///                 Copies the scroll position to the <see cref="SCROLLINFO.nPos" /> member of the <see cref="SCROLLINFO" /> structure pointed to by
		///                 <paramref name="lpsi" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SIF_RANGE</term>
		///             <description>
		///                 Copies the scroll range to the <see cref="SCROLLINFO.nMin" /> and <see cref="SCROLLINFO.nMax" /> members of the <see cref="SCROLLINFO" /> structure pointed
		///                 to by <paramref name="lpsi" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SIF_TRACKPOS</term>
		///             <description>
		///                 Copies the current scroll box tracking position to the <see cref="SCROLLINFO.nTrackPos" /> member of the <see cref="SCROLLINFO" /> structure
		///                 pointed to by <paramref name="lpsi" />.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function retrieved any values, the return value is nonzero.</para>
		///     <para>If the function does not retrieve any values, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="GetScrollInfo" /> function enables applications to use 32-bit scroll positions. Although the messages that indicate scroll bar
		///         position, <see cref="WM.WM_HSCROLL" /> and <see cref="WM.WM_VSCROLL" />, provide only 16 bits of position data, the functions
		///         <see cref="SetScrollInfo" /> and <see cref="GetScrollInfo" /> provide 32 bits of scroll bar position data. Thus, an application can call
		///         <see cref="GetScrollInfo" /> while processing either the <see cref="WM.WM_HSCROLL" /> or <see cref="WM.WM_VSCROLL" /> messages to obtain
		///         32-bit scroll bar position data.
		///     </para>
		///     <para>
		///         To get the 32-bit position of the scroll box (thumb) during a SB_THUMBTRACK request code in a <see cref="WM.WM_HSCROLL" /> or
		///         <see cref="WM.WM_VSCROLL" /> message, call <see cref="GetScrollInfo" /> with the SIF_TRACKPOS value in the <see cref="SCROLLINFO.fMask" /> member of the
		///         <see cref="SCROLLINFO" /> structure. The function returns the tracking position of the scroll box in the <see cref="SCROLLINFO.nTrackPos" /> member of
		///         the <see cref="SCROLLINFO" /> structure. This allows you to get the position of the scroll box as the user moves it. The following sample
		///         code illustrates the technique.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetScrollInfo")]
		public static extern bool GetScrollInfo([In] IntPtr hwnd, int fnBar, ref SCROLLINFO lpsi);

		/// <summary>
		///     <para>
		///         Retrieves the cursor position for the last message retrieved by the <see cref="GetMessage" /> function.
		///     </para>
		///     <para>
		///         To determine the current position of the cursor, use the <see cref="GetCursorPos" /> function.
		///     </para>
		/// </summary>
		/// <returns>
		///     <para>
		///         The return value specifies the x- and y-coordinates of the cursor position. The x-coordinate is the low order short and the
		///         y-coordinate is the high-order short.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         As noted above, the x-coordinate is in the low-order short of the return value; the y-coordinate is in the high-order
		///         short (both represent signed values because they can take negative values on systems with multiple
		///         monitors). If the return value is assigned to a variable, you can use the MAKEPOINTS macro to obtain a <see cref="POINT" />
		///         structure from the return value. You can also use the GET_X_LPARAM or GET_Y_LPARAM macro to extract the x- or
		///         y-coordinate.
		///     </para>
		///     <para>
		///         Important:  Do not use the LOWORD or HIWORD macros to extract the x- and y- coordinates of the
		///         cursor position because these macros return incorrect results on systems with multiple monitors. Systems with multiple monitors can have
		///         negative x- and y- coordinates, and LOWORD and HIWORD treat the coordinates as unsigned quantities.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetMessagePos")]
		public static extern uint GetMessagePos();

		/// <summary>Retrieves the menu item identifier of a menu item located at the specified position in a menu.</summary>
		/// <param name="hMenu">A handle to the menu that contains the item whose identifier is to be retrieved.</param>
		/// <param name="nPos">The zero-based relative position of the menu item whose identifier is to be retrieved.</param>
		/// <returns>
		///     The return value is the identifier of the specified menu item. If the menu item identifier is NULL or if the specified item opens a submenu, the
		///     return value is -1.
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetMenuItemID")]
		public static extern uint GetMenuItemID([In] IntPtr hMenu, int nPos);

		/// <summary>
		///     <para>Retrieves the current code page.</para>
		///     <para>
		///         Note:  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the
		///         GetOEMCP function to retrieve the OEM code-page identifier for the system.
		///     </para>
		/// </summary>
		/// <returns>
		///     The return value is an OEM code-page identifier, or it is the default identifier if the registry value is not readable. For a list of OEM
		///     code-page identifiers, see Code Page Identifiers.
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetKBCodePage")]
		public static extern uint GetKBCodePage();

		/// <summary>Determines whether there are mouse-button or keyboard messages in the calling thread's message queue.</summary>
		/// <returns>
		///     <para>If the queue contains one or more new mouse-button or keyboard messages, the return value is nonzero.</para>
		///     <para>If there are no new mouse-button or keyboard messages in the queue, the return value is zero.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetInputState")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool GetInputState();

		/// <summary>Translates the text of a specified control in a dialog box into an integer value.</summary>
		/// <param name="hDlg">A handle to the dialog box that contains the control of interest.</param>
		/// <param name="nIDDlgItem">The identifier of the control whose text is to be translated.</param>
		/// <param name="lpTranslated">
		///     <para>Indicates success or failure (TRUE indicates success, FALSE indicates failure).</para>
		///     <para>If this parameter is NULL, the function returns no information about success or failure.</para>
		/// </param>
		/// <param name="bSigned">
		///     Indicates whether the function should examine the text for a minus sign at the beginning and return a signed integer value if it finds one (TRUE
		///     specifies this should be done, FALSE that it should not).
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the variable pointed to by <paramref name="lpTranslated" /> is set to TRUE, and the return value is the translated
		///         value of the control text.
		///     </para>
		///     <para>
		///         If the function fails, the variable pointed to by <paramref name="lpTranslated" /> is set to FALSE, and the return value is zero. Note that,
		///         because zero is a possible translated value, a return value of zero does not by itself indicate failure.
		///     </para>
		///     <para>
		///         If <paramref name="lpTranslated" /> is NULL, the function returns no information about success or failure.
		///     </para>
		///     <para>
		///         Note that, if the <paramref name="bSigned" /> parameter is TRUE and there is a minus sign (–) at the beginning of the text,
		///         <see cref="GetDlgItemInt" /> translates the text into a signed integer value. Otherwise, the function creates an unsigned integer value. To
		///         obtain the proper value in this case, cast the return value to an <see cref="int" /> type.
		///     </para>
		///     <para>To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="GetDlgItemInt" /> function retrieves the text of the specified control by sending the control a <see cref="WM.WM_GETTEXT" />
		///         message. The function translates the retrieved text by stripping any extra spaces at the beginning of the text and then converting the
		///         decimal digits. The function stops translating when it reaches the end of the text or encounters a nonnumeric character.
		///     </para>
		///     <para>
		///         The <see cref="GetDlgItemInt" /> function returns zero if the translated value is greater than INT_MAX (for signed numbers) or
		///         UINT_MAX (for unsigned numbers).
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetDlgItemInt")]
		public static extern uint GetDlgItemInt([In] IntPtr hDlg, int nIDDlgItem, IntPtr lpTranslated, [MarshalAs(UnmanagedType.Bool)] bool bSigned);

		/// <summary>Retrieves information about the global cursor.</summary>
		/// <param name="pci">
		///     A pointer to a <see cref="CURSORINFO" /> structure that receives the information. Note that you must set the <see cref="CURSORINFO.cbSize" /> member to
		///     sizeof(CURSORINFO) before calling this function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetCursorInfo")]
		public static extern bool GetCursorInfo(ref CURSORINFO pci);

		/// <summary>Retrieves the screen coordinates of the rectangular area to which the cursor is confined.</summary>
		/// <param name="lpRect">
		///     A pointer to a <see cref="RECT" /> structure that receives the screen coordinates of the confining rectangle. The structure receives the
		///     dimensions of the screen if the cursor is not confined to a rectangle.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The cursor is a shared resource. If an application confines the cursor with the <see cref="ClipCursor" /> function, it must later release the
		///         cursor by using <see cref="ClipCursor" /> before relinquishing control to another application.
		///     </para>
		///     <para>
		///         The calling process must have <see cref="WINSTA_READATTRIBUTES" /> access to the window station.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetClipCursor")]
		public static extern bool GetClipCursor([Out] out RECT lpRect);

		/// <summary>
		///     Retrieves the coordinates of a window's client area. The client coordinates specify the upper-left and lower-right corners of the client area.
		///     Because client coordinates are relative to the upper-left corner of a window's client area, the coordinates of the upper-left corner are (0,0).
		/// </summary>
		/// <param name="hWnd">A handle to the window whose client coordinates are to be retrieved.</param>
		/// <param name="lpRect">
		///     A pointer to a <see cref="RECT" /> structure that receives the client coordinates. The <see cref="RECT.left" /> and <see cref="RECT.top" /> members are
		///     zero. The <see cref="RECT.right" /> and <see cref="RECT.bottom" /> members contain the width and height of the window.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     In conformance with conventions for the <see cref="RECT" /> structure, the bottom-right coordinates of the returned rectangle are exclusive. In
		///     other words, the pixel at (<see cref="RECT.right" />, <see cref="RECT.bottom" />) lies immediately outside the rectangle.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetClientRect")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool GetClientRect([In] IntPtr hWnd, [Out] out RECT lpRect);

		/// <summary>Retrieves the name of the class to which the specified window belongs.</summary>
		/// <param name="hWnd">A handle to the window and, indirectly, the class to which the window belongs.</param>
		/// <param name="lpClassName">The class name string.</param>
		/// <param name="nMaxCount">
		///     The length of the <paramref name="lpClassName" /> buffer, in characters. The buffer must be large enough to include the terminating null
		///     character; otherwise, the class name string is truncated to nMaxCount-1 characters.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the number of characters copied to the buffer, not including the terminating null character.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetClassName")]
		public static extern int GetClassName([In] IntPtr hWnd, [Out] StringBuilder lpClassName, int nMaxCount);

		/// <summary>
		///     <para>
		///         Retrieves the specified 32-bit (DWORD) value from the <see cref="WNDCLASSEX" /> structure associated with the specified
		///         window.
		///     </para>
		///     <para>
		///         Note:  If you are retrieving a pointer or a handle, this function has been superseded by the GetClassLongPtr
		///         function. (Pointers and handles are 32 bits on 32-bit Windows and 64 bits on 64-bit Windows.)
		///     </para>
		/// </summary>
		/// <param name="hWnd">A handle to the window and, indirectly, the class to which the window belongs.</param>
		/// <param name="nIndex">
		///     <para>
		///         The value to be retrieved. To retrieve a value from the extra class memory, specify the positive, zero-based byte offset of the value to be
		///         retrieved. Valid values are in the range zero through the number of bytes of extra class memory, minus four; for example, if you specified 12
		///         or more bytes of extra class memory, a value of 8 would be an index to the third integer. To retrieve any other value from the
		///         <see cref="WNDCLASSEX" /> structure, specify one of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>GCW_ATOM -32</term>
		///             <description>
		///                 Retrieves an ATOM value that uniquely identifies the window class. This is the same atom that the
		///                 <see cref="RegisterClassEx" /> function returns.
		///             </description>
		///         </item>
		///         <item>
		///             <term>GCL_CBCLSEXTRA -20</term>
		///             <description>Retrieves the size, in bytes, of the extra memory associated with the class.</description>
		///         </item>
		///         <item>
		///             <term>GCL_CBWNDEXTRA -18</term>
		///             <description>
		///                 Retrieves the size, in bytes, of the extra window memory associated with each window in the class. For information on how to access
		///                 this memory, see <see cref="GetWindowLong" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>GCL_HBRBACKGROUND -10</term>
		///             <description>Retrieves a handle to the background brush associated with the class.</description>
		///         </item>
		///         <item>
		///             <term>GCL_HCURSOR -12</term>
		///             <description>Retrieves a handle to the cursor associated with the class.</description>
		///         </item>
		///         <item>
		///             <term>GCL_HICON -14</term>
		///             <description>Retrieves a handle to the icon associated with the class.</description>
		///         </item>
		///         <item>
		///             <term>GCL_HICONSM -34</term>
		///             <description>Retrieves a handle to the small icon associated with the class.</description>
		///         </item>
		///         <item>
		///             <term>GCL_HMODULE -16</term>
		///             <description>Retrieves a handle to the module that registered the class.</description>
		///         </item>
		///         <item>
		///             <term>GCL_MENUNAME -8</term>
		///             <description>Retrieves the address of the menu name string. The string identifies the menu resource associated with the class.</description>
		///         </item>
		///         <item>
		///             <term>GCL_STYLE -26</term>
		///             <description>Retrieves the window-class style bits.</description>
		///         </item>
		///         <item>
		///             <term>GCL_WNDPROC -24</term>
		///             <description>
		///                 Retrieves the address of the window procedure, or a handle representing the address of the window procedure. You must use the
		///                 <see cref="CallWindowProc" /> function to call the window procedure.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the requested value.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     Reserve extra class memory by specifying a nonzero value in the <see cref="cbClsExtra" /> member of the <see cref="WNDCLASSEX" /> structure used
		///     with the <see cref="RegisterClassEx" /> function.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetClassLong")]
		public static extern uint GetClassLong([In] IntPtr hWnd, int nIndex);

		/// <summary>
		///     <para>Retrieves information about a window class.</para>
		///     <para>
		///         Note:  The <see cref="GetClassInfo" /> function has been superseded by the <see cref="GetClassInfoEx" /> function. You can
		///         still use <see cref="GetClassInfo" />, however, if you do not need information about the class small icon.
		///     </para>
		/// </summary>
		/// <param name="hInstance">
		///     A handle to the instance of the application that created the class. To retrieve information about classes defined by the system (such as buttons
		///     or list boxes), set this parameter to NULL.
		/// </param>
		/// <param name="lpClassName">
		///     <para>
		///         The class name. The name must be that of a preregistered class or a class registered by a previous call to the <see cref="RegisterClass" />
		///         or <see cref="RegisterClassEx" /> function.
		///     </para>
		///     <para>
		///         Alternatively, this parameter can be an atom. If so, it must be a class atom created by a previous call to <see cref="RegisterClass" /> or
		///         <see cref="RegisterClassEx" />. The atom must be in the low-order word of <paramref name="lpClassName" />; the high-order word must be zero.
		///     </para>
		/// </param>
		/// <param name="lpWndClass">
		///     A pointer to a <see cref="WNDCLASS" /> structure that receives the information about the class.
		/// </param>
		/// <returns>
		///     <para>If the function finds a matching class and successfully copies the data, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetClassInfo")]
		[return: MarshalAs(UnmanagedType.Bool)]
		public static extern bool GetClassInfo([In] IntPtr hInstance, [In] string lpClassName, [Out] out WNDCLASS lpWndClass);

		/// <summary>
		///     Frees the memory specified by the <paramref name="lParam" /> parameter of a posted Dynamic Data Exchange (DDE) message. An application receiving
		///     a posted DDE message should call this function after it has used the <see cref="UnpackDDElParam" /> function to unpack the
		///     <paramref name="lParam" /> value.
		/// </summary>
		/// <param name="msg">The posted DDE message.</param>
		/// <param name="lParam">
		///     The <paramref name="lParam" /> parameter of the posted DDE message.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>An application should call this function only for posted DDE messages.</para>
		///     <para>
		///         This function frees the memory specified by the <paramref name="lParam" /> parameter. It does not free the contents of
		///         <paramref name="lParam" />.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "FreeDDElParam")]
		public static extern bool FreeDDElParam(uint msg, [MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>Flashes the specified window. It does not change the active state of the window.</summary>
		/// <param name="pfwi">
		///     A pointer to a <see cref="FLASHWINFO" /> structure.
		/// </param>
		/// <returns>
		///     The return value specifies the window's state before the call to the <see cref="FlashWindowEx" /> function. If the window caption was drawn as
		///     active before the call, the return value is nonzero. Otherwise, the return value is zero.
		/// </returns>
		/// <remarks>
		///     Typically, you flash a window to inform the user that the window requires attention but does not currently have the keyboard focus. When a window
		///     flashes, it appears to change from inactive to active status. An inactive caption bar changes to an active caption bar; an active caption bar
		///     changes to an inactive caption bar.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "FlashWindowEx")]
		public static extern bool FlashWindowEx([In] ref FLASHWINFO pfwi);

		/// <summary>
		///     Retrieves a handle to a window whose class name and window name match the specified strings. The function searches child windows, beginning with
		///     the one following the specified child window. This function does not perform a case-sensitive search.
		/// </summary>
		/// <param name="hwndParent">
		///     <para>A handle to the parent window whose child windows are to be searched.</para>
		///     <para>
		///         If <paramref name="hwndParent" /> is NULL, the function uses the desktop window as the parent window. The function searches among windows
		///         that are child windows of the desktop.
		///     </para>
		///     <para>
		///         If <paramref name="hwndParent" /> is <see cref="HWND_MESSAGE" />, the function searches all message-only windows.
		///     </para>
		/// </param>
		/// <param name="hwndChildAfter">
		///     <para>
		///         A handle to a child window. The search begins with the next child window in the Z order. The child window must be a direct child window of
		///         <paramref name="hwndParent" />, not just a descendant window.
		///     </para>
		///     <para>
		///         If <paramref name="hwndChildAfter" /> is NULL, the search begins with the first child window of <paramref name="hwndParent" />.
		///     </para>
		///     <para>
		///         Note that if both <paramref name="hwndParent" /> and <paramref name="hwndChildAfter" /> are NULL, the function searches all top-level and
		///         message-only windows.
		///     </para>
		/// </param>
		/// <param name="lpszClass">
		///     <para>
		///         The class name or a class atom created by a previous call to the <see cref="RegisterClass" /> or <see cref="RegisterClassEx" /> function. The
		///         atom must be placed in the low-order word of <paramref name="lpszClass" />; the high-order word must be zero.
		///     </para>
		///     <para>
		///         If <paramref name="lpszClass" /> is a string, it specifies the window class name. The class name can be any name registered with
		///         <see cref="RegisterClass" /> or <see cref="RegisterClassEx" />, or any of the predefined control-class names, or it can be
		///         MAKEINTATOM(0x8000). In this latter case, 0x8000 is the atom for a menu class. For more information, see the Remarks section of this topic.
		///     </para>
		/// </param>
		/// <param name="lpszWindow">The window name (the window's title). If this parameter is NULL, all window names match.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to the window that has the specified class and window names.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If the <paramref name="lpszWindow" /> parameter is not NULL, <see cref="FindWindowEx" /> calls the <see cref="GetWindowText" /> function to
		///         retrieve the window name for comparison. For a description of a potential problem that can arise, see the Remarks section of
		///         <see cref="GetWindowText" />.
		///     </para>
		///     <para>An application can call this function in the following way.</para>
		///     <para>FindWindowEx( NULL, NULL, MAKEINTATOM(0x8000), NULL );</para>
		///     <para>
		///         Note that 0x8000 is the atom for a menu class. When an application calls this function, the function checks whether a context menu is being
		///         displayed that the application created.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "FindWindowEx")]
		public static extern IntPtr FindWindowEx([In] IntPtr hWndParent, [In] IntPtr hWndChildAfter, [In] string lpszClass, [In] string lpszWindow);

		/// <summary>
		///     Logs off the interactive user, shuts down the system, or shuts down and restarts the system. It sends the <see cref="WM.WM_QUERYENDSESSION" />
		///     message to all applications to determine if they can be terminated.
		/// </summary>
		/// <param name="uFlags">
		///     <para>The shutdown type. This parameter must include one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>EWX_HYBRID_SHUTDOWN 0x00400000</term>
		///             <description>
		///                 Beginning with Windows 8:  You can prepare the system for a faster startup by combining the EWX_HYBRID_SHUTDOWN flag with
		///                 the EWX_SHUTDOWN flag.
		///             </description>
		///         </item>
		///         <item>
		///             <term>EWX_LOGOFF 0</term>
		///             <description>
		///                 <para>
		///                     Shuts down all processes running in the logon session of the process that called the <see cref="ExitWindowsEx" /> function. Then
		///                     it logs the user off.
		///                 </para>
		///                 <para>This flag can be used only by processes running in an interactive user's logon session.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>EWX_POWEROFF 0x00000008</term>
		///             <description>
		///                 <para>Shuts down the system and turns off the power. The system must support the power-off feature.</para>
		///                 <para>The calling process must have the SE_SHUTDOWN_NAME privilege. For more information, see the following Remarks section.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>EWX_REBOOT 0x00000002</term>
		///             <description>
		///                 <para>Shuts down the system and then restarts the system.</para>
		///                 <para>The calling process must have the SE_SHUTDOWN_NAME privilege. For more information, see the following Remarks section.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>EWX_RESTARTAPPS 0x00000040</term>
		///             <description>
		///                 Shuts down the system and then restarts it, as well as any applications that have been registered for restart using the
		///                 <see cref="RegisterApplicationRestart" /> function. These application receive the <see cref="WM.WM_QUERYENDSESSION" /> message with
		///                 <paramref name="lParam" /> set to the ENDSESSION_CLOSEAPP value. For more information, see Guidelines for Applications.
		///             </description>
		///         </item>
		///         <item>
		///             <term>EWX_SHUTDOWN 0x00000001</term>
		///             <description>
		///                 <para>
		///                     Shuts down the system to a point at which it is safe to turn off the power. All file buffers have been flushed to disk, and all
		///                     running processes have stopped.
		///                 </para>
		///                 <para>The calling process must have the SE_SHUTDOWN_NAME privilege. For more information, see the following Remarks section.</para>
		///                 <para>
		///                     Specifying this flag will not turn off the power even if the system supports the power-off feature. You must specify
		///                     EWX_POWEROFF to do this.
		///                 </para>
		///             </description>
		///         </item>
		///     </list>
		///     <para>This parameter can optionally include one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>EWX_FORCE 0x00000004</term>
		///             <description>
		///                 This flag has no effect if terminal services is enabled. Otherwise, the system does not send the <see cref="WM.WM_QUERYENDSESSION" />
		///                 message. This can cause applications to lose data. Therefore, you should only use this flag in an emergency.
		///             </description>
		///         </item>
		///         <item>
		///             <term>EWX_FORCEIFHUNG 0x00000010</term>
		///             <description>
		///                 Forces processes to terminate if they do not respond to the <see cref="WM.WM_QUERYENDSESSION" /> or <see cref="WM.WM_ENDSESSION" />
		///                 message within the timeout interval. For more information, see the Remarks.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="dwReason">
		///     <para>The reason for initiating the shutdown. This parameter must be one of the system shutdown reason codes.</para>
		///     <para>
		///         If this parameter is zero, the SHTDN_REASON_FLAG_PLANNED reason code will not be set and therefore the default action is an undefined
		///         shutdown that is logged as "No title for this reason could be found". By default, it is also an unplanned shutdown. Depending on how the
		///         system is configured, an unplanned shutdown triggers the creation of a file that contains the system state information, which can delay
		///         shutdown. Therefore, do not use zero for this parameter.
		///     </para>
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is nonzero. Because the function executes asynchronously, a nonzero return value indicates that
		///         the shutdown has been initiated. It does not indicate whether the shutdown will succeed. It is possible that the system, the user, or another
		///         application will abort the shutdown.
		///     </para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="ExitWindowsEx" /> function returns as soon as it has initiated the shutdown process. The shutdown or logoff then proceeds
		///         asynchronously. The function is designed to stop all processes in the caller's logon session. Therefore, if you are not the interactive user,
		///         the function can succeed without actually shutting down the computer. If you are not the interactive user, use the
		///         <see cref="InitiateSystemShutdown" /> or <see cref="InitiateSystemShutdownEx" /> function.
		///     </para>
		///     <para>
		///         A non-zero return value does not mean the logoff was or will be successful. The shutdown is an asynchronous process, and it can occur long
		///         after the API call has returned, or not at all. Even if the timeout value is zero, the shutdown can still be aborted by applications,
		///         services, or even the system. The non-zero return value indicates that the validation of the rights and parameters was successful and that
		///         the system accepted the shutdown request.
		///     </para>
		///     <para>
		///         When this function is called, the caller must specify whether or not applications with unsaved changes should be forcibly closed. If the
		///         caller chooses not to force these applications to close and an application with unsaved changes is running on the console session, the
		///         shutdown will remain in progress until the user logged into the console session aborts the shutdown, saves changes, closes the application,
		///         or forces the application to close. During this period, the shutdown may not be aborted except by the console user, and another shutdown may
		///         not be initiated.
		///     </para>
		///     <para>
		///         Calling this function with the value of the <paramref name="uFlags" /> parameter set to EWX_FORCE avoids this situation. Remember that doing
		///         this may result in loss of data.
		///     </para>
		///     <para>
		///         To set a shutdown priority for an application relative to other applications in the system, use the
		///         <see cref="SetProcessShutdownParameters" /> function.
		///     </para>
		///     <para>
		///         During a shutdown or log-off operation, running applications are allowed a specific amount of time to respond to the shutdown request. If
		///         this time expires before all applications have stopped, the system displays a user interface that allows the user to forcibly shut down the
		///         system or to cancel the shutdown request. If the EWX_FORCE value is specified, the system forces running applications to stop when the time
		///         expires.
		///     </para>
		///     <para>If the EWX_FORCEIFHUNG value is specified, the system forces hung applications to close and does not display the dialog box.</para>
		///     <para>
		///         Console processes receive a separate notification message, CTRL_SHUTDOWN_EVENT or CTRL_LOGOFF_EVENT, as the situation warrants. A console
		///         process routes these messages to its <see cref="HandlerRoutine" /> function. <see cref="ExitWindowsEx" /> sends these notification messages
		///         asynchronously; thus, an application cannot assume that the console notification messages have been handled when a call to
		///         <see cref="ExitWindowsEx" /> returns.
		///     </para>
		///     <para>
		///         To shut down or restart the system, the calling process must use the <see cref="AdjustTokenPrivileges" /> function to enable the
		///         SE_SHUTDOWN_NAME privilege. For more information, see Running with Special Privileges.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "ExitWindowsEx")]
		public static extern bool ExitWindowsEx(uint uFlags, uint dwReason);

		/// <summary>
		///     Enumerates all desktops associated with the specified window station of the calling process. The function passes the name of each desktop, in
		///     turn, to an application-defined callback function.
		/// </summary>
		/// <param name="hwinsta">
		///     <para>
		///         A handle to the window station whose desktops are to be enumerated. This handle is returned by the <see cref="CreateWindowStation" />,
		///         <see cref="GetProcessWindowStation" />, or <see cref="OpenWindowStation" /> function, and must have the WINSTA_ENUMDESKTOPS access right. For
		///         more information, see Window Station Security and Access Rights.
		///     </para>
		///     <para>If this parameter is NULL, the current window station is used.</para>
		/// </param>
		/// <param name="lpEnumFunc">
		///     A pointer to an application-defined <see cref="EnumDesktopProc" /> callback function.
		/// </param>
		/// <param name="lParam">An application-defined value to be passed to the callback function.</param>
		/// <returns>
		///     <para>
		///         If the function succeeds, it returns the nonzero value returned by the callback function that was pointed to by
		///         <paramref name="lpEnumFunc" />.
		///     </para>
		///     <para>If the function is unable to perform the enumeration, the return value is zero. Call GetLastError to get extended error information.</para>
		///     <para>
		///         If the callback function fails, the return value is zero. The callback function can call SetLastError to set an error code for
		///         the caller to retrieve by calling GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="EnumDesktops" /> function enumerates only those desktops for which the calling process has the DESKTOP_ENUMERATE access right.
		///         For more information, see Desktop Security and Access Rights.
		///     </para>
		///     <para>
		///         The <see cref="EnumDesktops" /> function repeatedly invokes the <paramref name="lpEnumFunc" /> callback function until the last desktop is
		///         enumerated or the callback function returns FALSE.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "EnumDesktops")]
		public static extern bool EnumDesktops([In] IntPtr hwinsta, EnumWindowStationProc lpEnumFunc, [MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>
		///     The <see cref="DrawFocusRect" /> function draws a rectangle in the style used to indicate that the rectangle has the focus.
		/// </summary>
		/// <param name="hDC">A handle to the device context.</param>
		/// <param name="lprc">
		///     A pointer to a <see cref="RECT" /> structure that specifies the logical coordinates of the rectangle.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         <see cref="DrawFocusRect" /> works only in MM_TEXT mode.
		///     </para>
		///     <para>
		///         Because <see cref="DrawFocusRect" /> is an XOR function, calling it a second time with the same rectangle removes the rectangle from the
		///         screen.
		///     </para>
		///     <para>
		///         This function draws a rectangle that cannot be scrolled. To scroll an area containing a rectangle drawn by this function, call
		///         <see cref="DrawFocusRect" /> to remove the rectangle from the screen, scroll the area, and then call <see cref="DrawFocusRect" /> again to
		///         draw the rectangle in the new position.
		///     </para>
		///     <para>
		///         Windows XP: The focus rectangle can now be thicker than 1 pixel, so it is more visible for high-resolution, high-density displays and
		///         accessibility needs. This is handled by the SPI_SETFOCUSBORDERWIDTH and SPI_SETFOCUSBORDERHEIGHT in <see cref="SystemParametersInfo" />.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DrawFocusRect")]
		public static extern bool DrawFocusRect([In] IntPtr hDC, [In] ref RECT lprc);

		/// <summary>
		///     <para>
		///         Destroys the specified window. The function sends <see cref="WM.WM_DESTROY" /> and <see cref="WM.WM_NCDESTROY" /> messages to the window to
		///         deactivate it and remove the keyboard focus from it. The function also destroys the window's menu, flushes the thread message queue, destroys
		///         timers, removes clipboard ownership, and breaks the clipboard viewer chain (if the window is at the top of the viewer chain).
		///     </para>
		///     <para>
		///         If the specified window is a parent or owner window, <see cref="DestroyWindow" /> automatically destroys the associated child or owned
		///         windows when it destroys the parent or owner window. The function first destroys child or owned windows, and then it destroys the parent or
		///         owner window.
		///     </para>
		///     <para>
		///         <see cref="DestroyWindow" /> also destroys modeless dialog boxes created by the <see cref="CreateDialog" /> function.
		///     </para>
		/// </summary>
		/// <param name="hWnd">A handle to the window to be destroyed.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         A thread cannot use <see cref="DestroyWindow" /> to destroy a window created by a different thread.
		///     </para>
		///     <para>
		///         If the window being destroyed is a child window that does not have the <see cref="WS_EX.WS_EX_NOPARENTNOTIFY" /> style, a
		///         <see cref="WM.WM_PARENTNOTIFY" /> message is sent to the parent.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DestroyWindow")]
		public static extern bool DestroyWindow([In] IntPtr hWnd);

		/// <summary>Destroys a cursor and frees any memory the cursor occupied. Do not use this function to destroy a shared cursor.</summary>
		/// <param name="hCursor">A handle to the cursor to be destroyed. The cursor must not be in use.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     The <see cref="DestroyCursor" /> function destroys a nonshared cursor. Do not use this function to destroy a shared cursor. A shared cursor is
		///     valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared cursor:
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DestroyCursor")]
		public static extern bool DestroyCursor([In] IntPtr hCursor);

		/// <summary>
		///     Provides default processing for any window messages that the window procedure of a multiple-document interface (MDI) frame window does not
		///     process. All window messages that are not explicitly processed by the window procedure must be passed to the <see cref="DefFrameProc" />
		///     function, not the <see cref="DefWindowProc" /> function.
		/// </summary>
		/// <param name="hWnd">A handle to the MDI frame window.</param>
		/// <param name="hWndMDIClient">A handle to the MDI client window.</param>
		/// <param name="uMsg">The message to be processed.</param>
		/// <param name="wParam">Additional message-specific information.</param>
		/// <param name="lParam">Additional message-specific information.</param>
		/// <returns>
		///     <para>
		///         The return value specifies the result of the message processing and depends on the message. If the <paramref name="hWndMDIClient" />
		///         parameter is NULL, the return value is the same as for the <see cref="DefWindowProc" /> function.
		///     </para>
		/// </returns>
		/// <remarks>
		///     When an application's window procedure does not handle a message, it typically passes the message to the <see cref="DefWindowProc" /> function to
		///     process the message. MDI applications use the <see cref="DefFrameProc" /> and <see cref="DefMDIChildProc" /> functions instead of
		///     <see cref="DefWindowProc" /> to provide default message processing. All messages that an application would usually pass to
		///     <see cref="DefWindowProc" /> (such as nonclient messages and the <see cref="WM.WM_SETTEXT" /> message) should be passed to
		///     <see cref="DefFrameProc" /> instead. The <see cref="DefFrameProc" /> function also handles the following messages.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.SysInt)]
		[DllImport("user32.dll", EntryPoint = "DefFrameProc")]
		public static extern int DefFrameProc(
			[In] IntPtr hWnd, [In] IntPtr hWndMDIClient, uint uMsg, [MarshalAs(UnmanagedType.SysUInt)] uint wParam, [MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>
		///     Causes the system to send an <see cref="XTYP_ADVREQ" /> transaction to the calling (server) application's Dynamic Data Exchange (DDE) callback
		///     function for each client with an active advise loop on the specified topic and item. A server application should call this function whenever the
		///     data associated with the topic name or item name pair changes.
		/// </summary>
		/// <param name="idInst">
		///     The application instance identifier obtained by a previous call to the <see cref="DdeInitialize" /> function.
		/// </param>
		/// <param name="hszTopic">
		///     A handle to a string that specifies the topic name. To send notifications for all topics with active advise loops, an application can set this
		///     parameter to 0L.
		/// </param>
		/// <param name="hszItem">
		///     A handle to a string that specifies the item name. To send notifications for all items with active advise loops, an application can set this
		///     parameter to 0L.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         A server that has nonenumerable topics or items should set the <paramref name="hszTopic" /> and <paramref name="hszItem" /> parameters to
		///         NULL so that the system generates transactions for all active advise loops. The server's DDE callback function returns NULL for any advise
		///         loops that must not be updated.
		///     </para>
		///     <para>
		///         If a server calls <see cref="DdePostAdvise" /> with a topic, item, and format name set that includes the set currently being handled in an
		///         <see cref="XTYP_ADVREQ" /> callback, a stack overflow can result.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DdePostAdvise")]
		public static extern bool DdePostAdvise(uint idInst, IntPtr hszTopic, IntPtr hszItem);

		/// <summary>
		///     Terminates a conversation started by either the <see cref="DdeConnect" /> or <see cref="DdeConnectList" /> function and invalidates the specified
		///     conversation handle.
		/// </summary>
		/// <param name="hConv">A handle to the active conversation to be terminated.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		/// <remarks>
		///     Any incomplete transactions started before calling <see cref="DdeDisconnect" /> are immediately abandoned. The <see cref="XTYP_DISCONNECT" />
		///     transaction is sent to the Dynamic Data Exchange (DDE) callback function of the partner in the conversation. Generally, only client applications
		///     must terminate conversations.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DdeDisconnect")]
		public static extern bool DdeDisconnect(IntPtr hConv);

		/// <summary>
		///     Provides access to the data in the specified Dynamic Data Exchange (DDE) object. An application must call the <see cref="DdeUnaccessData" />
		///     function when it has finished accessing the data in the object.
		/// </summary>
		/// <param name="hData">A handle to the DDE object to be accessed.</param>
		/// <param name="pcbDataSize">
		///     A pointer to a variable that receives the size, in bytes, of the DDE object identified by the <paramref name="hData" /> parameter. If this
		///     parameter is NULL, no size information is returned.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a pointer to the first byte of data in the DDE object.</para>
		///     <para>If the function fails, the return value is NULL.</para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		/// <remarks>
		///     If the <paramref name="hData" /> parameter has not been passed to a Dynamic Data Exchange Management Library (DDEML) function, an application can
		///     use the pointer returned by <see cref="DdeAccessData" /> for read-write access to the DDE object. If <paramref name="hData" /> has already been
		///     passed to a DDEML function, the pointer should be used only for read access to the memory object.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DdeAccessData")]
		public static extern IntPtr DdeAccessData(IntPtr hData, ref uint pcbDataSize);

		/// <summary>
		///     <para>
		///         [<see cref="CheckMenuItem" /> is available for use in the operating systems specified in the Requirements section. It may be altered or
		///         unavailable in subsequent versions. Instead, use <see cref="SetMenuItemInfo" />. ]
		///     </para>
		///     <para>Sets the state of the specified menu item's check-mark attribute to either selected or clear.</para>
		/// </summary>
		/// <param name="hmenu">A handle to the menu of interest.</param>
		/// <param name="uIDCheckItem">
		///     The menu item whose check-mark attribute is to be set, as determined by the <paramref name="uCheck" /> parameter.
		/// </param>
		/// <param name="uCheck">
		///     <para>
		///         The flags that control the interpretation of the <paramref name="uIDCheckItem" /> parameter and the state of the menu item's check-mark
		///         attribute. This parameter can be a combination of either <see cref="MF.MF_BYCOMMAND" />, or <see cref="MF.MF_BYPOSITION" /> and
		///         <see cref="MF.MF_CHECKED" /> or <see cref="MF.MF_UNCHECKED" />.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BYCOMMAND 0x00000000L</term>
		///             <description>
		///                 Indicates that the <paramref name="uIDCheckItem" /> parameter gives the identifier of the menu item. The <see cref="MF.MF_BYCOMMAND" />
		///                 flag is the default, if neither the <see cref="MF.MF_BYCOMMAND" /> nor <see cref="MF.MF_BYPOSITION" /> flag is specified.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_BYPOSITION 0x00000400L</term>
		///             <description>
		///                 Indicates that the <paramref name="uIDCheckItem" /> parameter gives the zero-based relative position of the menu item.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_CHECKED 0x00000008L</term>
		///             <description>Sets the check-mark attribute to the selected state.</description>
		///         </item>
		///         <item>
		///             <term>MF_UNCHECKED 0x00000000L</term>
		///             <description>Sets the check-mark attribute to the clear state.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     The return value specifies the previous state of the menu item (either <see cref="MF.MF_CHECKED" /> or <see cref="MF.MF_UNCHECKED" />). If the menu
		///     item does not exist, the return value is –1.
		/// </returns>
		/// <remarks>
		///     <para>An item in a menu bar cannot have a check mark.</para>
		///     <para>
		///         The <paramref name="uIDCheckItem" /> parameter identifies a item that opens a submenu or a command item. For a item that opens a submenu, the
		///         <paramref name="uIDCheckItem" /> parameter must specify the position of the item. For a command item, the <paramref name="uIDCheckItem" />
		///         parameter can specify either the item's position or its identifier.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CheckMenuItem")]
		public static extern uint CheckMenuItem([In] IntPtr hMenu, uint uIDCheckItem, uint uCheck);

		/// <summary>
		///     Enables you to produce special effects when showing or hiding windows. There are four types of animation: roll, slide, collapse or expand, and
		///     alpha-blended fade.
		/// </summary>
		/// <param name="hwnd">A handle to the window to animate. The calling thread must own this window.</param>
		/// <param name="dwTime">The time it takes to play the animation, in milliseconds. Typically, an animation takes 200 milliseconds to play.</param>
		/// <param name="dwFlags">
		///     <para>
		///         The type of animation. This parameter can be one or more of the following values. Note that, by default, these flags take effect when showing
		///         a window. To take effect when hiding a window, use <see cref="AW_HIDE" /> and a logical OR operator with the appropriate flags.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>AW_ACTIVATE 0x00020000</term>
		///             <description>
		///                 Activates the window. Do not use this value with <see cref="AW_HIDE" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>AW_BLEND 0x00080000</term>
		///             <description>
		///                 Uses a fade effect. This flag can be used only if <paramref name="hwnd" /> is a top-level window.
		///             </description>
		///         </item>
		///         <item>
		///             <term>AW_CENTER 0x00000010</term>
		///             <description>
		///                 Makes the window appear to collapse inward if <see cref="AW_HIDE" /> is used or expand outward if the <see cref="AW_HIDE" /> is not
		///                 used. The various direction flags have no effect.
		///             </description>
		///         </item>
		///         <item>
		///             <term>AW_HIDE 0x00010000</term>
		///             <description>Hides the window. By default, the window is shown.</description>
		///         </item>
		///         <item>
		///             <term>AW_HOR_POSITIVE 0x00000001</term>
		///             <description>
		///                 Animates the window from left to right. This flag can be used with roll or slide animation. It is ignored when used with
		///                 <see cref="AW_CENTER" /> or <see cref="AW_BLEND" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>AW_HOR_NEGATIVE 0x00000002</term>
		///             <description>
		///                 Animates the window from right to left. This flag can be used with roll or slide animation. It is ignored when used with
		///                 <see cref="AW_CENTER" /> or <see cref="AW_BLEND" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>AW_SLIDE 0x00040000</term>
		///             <description>
		///                 Uses slide animation. By default, roll animation is used. This flag is ignored when used with <see cref="AW_CENTER" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>AW_VER_POSITIVE 0x00000004</term>
		///             <description>
		///                 Animates the window from top to bottom. This flag can be used with roll or slide animation. It is ignored when used with
		///                 <see cref="AW_CENTER" /> or <see cref="AW_BLEND" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>AW_VER_NEGATIVE 0x00000008</term>
		///             <description>
		///                 Animates the window from bottom to top. This flag can be used with roll or slide animation. It is ignored when used with
		///                 <see cref="AW_CENTER" /> or <see cref="AW_BLEND" />.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. The function will fail in the following situations:</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         To show or hide a window without special effects, use <see cref="ShowWindow" />.
		///     </para>
		///     <para>
		///         When using slide or roll animation, you must specify the direction. It can be either <see cref="AW_HOR_POSITIVE" />,
		///         <see cref="AW_HOR_NEGATIVE" />, AW_VER_POSITIVE, or AW_VER_NEGATIVE.
		///     </para>
		///     <para>
		///         You can combine <see cref="AW_HOR_POSITIVE" /> or <see cref="AW_HOR_NEGATIVE" /> with <see cref="AW_VER_POSITIVE" /> or
		///         <see cref="AW_VER_NEGATIVE" /> to animate a window diagonally.
		///     </para>
		///     <para>
		///         The window procedures for the window and its child windows should handle any <see cref="WM.WM_PRINT" /> or <see cref="WM.WM_PRINTCLIENT" />
		///         messages. Dialog boxes, controls, and common controls already handle <see cref="WM.WM_PRINTCLIENT" />. The default window procedure already
		///         handles <see cref="WM.WM_PRINT" />.
		///     </para>
		///     <para>If a child window is displayed partially clipped, when it is animated it will have holes where it is clipped.</para>
		///     <para>
		///         <see cref="AnimateWindow" /> supports RTL windows.
		///     </para>
		///     <para>Avoid animating a window that has a drop shadow because it produces visually distracting, jerky animations.</para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "AnimateWindow")]
		public static extern bool AnimateWindow([In] IntPtr hWnd, uint dwTime, AW dwFlags);

		/// <summary>
		///     The <see cref="WindowFromDC" /> function returns a handle to the window associated with the specified display device context (DC). Output
		///     functions that use the specified device context draw into this window.
		/// </summary>
		/// <param name="hDC">Handle to the device context from which a handle to the associated window is to be retrieved.</param>
		/// <returns>
		///     The return value is a handle to the window associated with the specified DC. If no window is associated with the specified DC, the return value
		///     is NULL.
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "WindowFromDC")]
		public static extern IntPtr WindowFromDC([In] IntPtr hDC);

		/// <summary>
		///     Translates a character to the corresponding virtual-key code and shift state. The function translates the character using the input language and
		///     physical keyboard layout identified by the input locale identifier.
		/// </summary>
		/// <param name="ch">The character to be translated into a virtual-key code.</param>
		/// <param name="dwhkl">
		///     Input locale identifier used to translate the character. This parameter can be any input locale identifier previously returned by the
		///     <see cref="LoadKeyboardLayout" /> function.
		/// </param>
		/// <returns>
		///     If the function succeeds, the low-order byte of the return value contains the virtual-key code and the high-order byte contains the shift state,
		///     which can be a combination of the following flag bits.
		/// </returns>
		/// <remarks>
		///     <para>
		///         The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input
		///         Method Editor (IME), or any other form of input.
		///     </para>
		///     <para>
		///         For keyboard layouts that use the right-hand ALT key as a shift key (for example, the French keyboard layout), the shift state is represented
		///         by the value 6, because the right-hand ALT key is converted internally into CTRL+ALT.
		///     </para>
		///     <para>
		///         Translations for the numeric keypad (VK_NUMPAD0 through VK_DIVIDE) are ignored. This function is intended to translate characters into
		///         keystrokes from the main keyboard section only. For example, the character "7" is translated into VK_7, not VK_NUMPAD7.
		///     </para>
		///     <para>
		///         <see cref="VkKeyScanEx" /> is used by applications that send characters by using the <see cref="WM.WM_KEYUP" /> and
		///         <see cref="WM.WM_KEYDOWN" />
		///         messages.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "VkKeyScanEx")]
		public static extern short VkKeyScanEx(char ch, [In] IntPtr dwhkl);

		/// <summary>
		///     The <see cref="ValidateRect" /> function validates the client area within a rectangle by removing the rectangle from the update region of the
		///     specified window.
		/// </summary>
		/// <param name="hWnd">
		///     Handle to the window whose update region is to be modified. If this parameter is NULL, the system invalidates and redraws all windows and sends
		///     the <see cref="WM.WM_ERASEBKGND" /> and <see cref="WM.WM_NCPAINT" /> messages to the window procedure before the function returns.
		/// </param>
		/// <param name="lpRect">
		///     Pointer to a <see cref="RECT" /> structure that contains the client coordinates of the rectangle to be removed from the update region. If this
		///     parameter is NULL, the entire client area is removed.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="BeginPaint" /> function automatically validates the entire client area. Neither the <see cref="ValidateRect" /> nor
		///         <see cref="ValidateRgn" /> function should be called if a portion of the update region must be validated before the next
		///         <see cref="WM.WM_PAINT" /> message is generated.
		///     </para>
		///     <para>
		///         The system continues to generate <see cref="WM.WM_PAINT" /> messages until the current update region is validated.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "ValidateRect")]
		public static extern bool ValidateRect([In] IntPtr hWnd, [In] ref RECT lpRect);

		/// <summary>
		///     The <see cref="UpdateWindow" /> function updates the client area of the specified window by sending a <see cref="WM.WM_PAINT" /> message to the
		///     window if the window's update region is not empty. The function sends a <see cref="WM.WM_PAINT" /> message directly to the window procedure of
		///     the specified window, bypassing the application queue. If the update region is empty, no message is sent.
		/// </summary>
		/// <param name="hWnd">Handle to the window to be updated.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "UpdateWindow")]
		public static extern bool UpdateWindow([In] IntPtr hWnd);

		/// <summary>
		///     The <see cref="SubtractRect" /> function determines the coordinates of a rectangle formed by subtracting one rectangle from another.
		/// </summary>
		/// <param name="lprcDst">
		///     A pointer to a <see cref="RECT" /> structure that receives the coordinates of the rectangle determined by subtracting the rectangle pointed to by
		///     <paramref name="lprcSrc2" /> from the rectangle pointed to by <paramref name="lprcSrc1" />.
		/// </param>
		/// <param name="lprcSrc1">
		///     A pointer to a <see cref="RECT" /> structure from which the function subtracts the rectangle pointed to by <paramref name="lprcSrc2" />.
		/// </param>
		/// <param name="lprcSrc2">
		///     A pointer to a <see cref="RECT" /> structure that the function subtracts from the rectangle pointed to by <paramref name="lprcSrc1" />.
		/// </param>
		/// <returns>
		///     <para>If the resulting rectangle is empty, the return value is zero.</para>
		///     <para>If the resulting rectangle is not empty, the return value is nonzero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The function only subtracts the rectangle specified by <paramref name="lprcSrc2" /> from the rectangle specified by
		///         <paramref name="lprcSrc1" /> when the rectangles intersect completely in either the x- or y-direction. For example, if *
		///         <paramref name="lprcSrc1" /> has the coordinates (10,10,100,100) and *<paramref name="lprcSrc2" /> has the coordinates (50,50,150,150), the
		///         function sets the coordinates of the rectangle pointed to by <paramref name="lprcDst" /> to (10,10,100,100). If *<paramref name="lprcSrc1" />
		///         has the coordinates (10,10,100,100) and *<paramref name="lprcSrc2" /> has the coordinates (50,10,150,150), however, the function sets the
		///         coordinates of the rectangle pointed to by <paramref name="lprcDst" /> to (10,10,50,100). In other words, the resulting rectangle is the
		///         bounding box of the geometric difference.
		///     </para>
		///     <para>
		///         Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all
		///         rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used
		///         determine the units of measure.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SubtractRect")]
		public static extern bool SubtractRect([Out] out RECT lprcDst, [In] ref RECT lprcSrc1, [In] ref RECT lprcSrc2);

		/// <summary>
		///     The <see cref="SetWindowRgn" /> function sets the window region of a window. The window region determines the area within the window where the
		///     system permits drawing. The system does not display any portion of a window that lies outside of the window region
		/// </summary>
		/// <param name="hWnd">A handle to the window whose window region is to be set.</param>
		/// <param name="hRgn">
		///     <para>A handle to a region. The function sets the window region of the window to this region.</para>
		///     <para>
		///         If <paramref name="hRgn" /> is NULL, the function sets the window region to NULL.
		///     </para>
		/// </param>
		/// <param name="bRedraw">
		///     <para>
		///         Specifies whether the system redraws the window after setting the window region. If <paramref name="bRedraw" /> is TRUE, the system does so;
		///         otherwise, it does not.
		///     </para>
		///     <para>
		///         Typically, you set <paramref name="bRedraw" /> to TRUE if the window is visible.
		///     </para>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         When this function is called, the system sends the <see cref="WM.WM_WINDOWPOSCHANGING" /> and <see cref="WM.WM_WINDOWPOSCHANGING" /> messages
		///         to the window.
		///     </para>
		///     <para>The coordinates of a window's window region are relative to the upper-left corner of the window, not the client area of the window.</para>
		///     <para>
		///         Note:  If the window layout is right-to-left (RTL), the coordinates are relative to the upper-right corner of the window. See
		///         Window Layout and Mirroring.
		///     </para>
		///     <para>
		///         After a successful call to <see cref="SetWindowRgn" />, the system owns the region specified by the region handle <paramref name="hRgn" />.
		///         The system does not make a copy of the region. Thus, you should not make any further function calls with this region handle. In particular,
		///         do not delete this region handle. The system deletes the region handle when it no longer needed.
		///     </para>
		///     <para>
		///         To obtain the window region of a window, call the <see cref="GetWindowRgn" /> function.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetWindowRgn")]
		public static extern int SetWindowRgn([In] IntPtr hWnd, [In] IntPtr hRgn, [MarshalAs(UnmanagedType.Bool)] bool bRedraw);

		/// <summary>
		///     Changes the size, position, and Z order of a child, pop-up, or top-level window. These windows are ordered according to their appearance on the
		///     screen. The topmost window receives the highest rank and is the first window in the Z order.
		/// </summary>
		/// <param name="hWnd">A handle to the window.</param>
		/// <param name="hWndInsertAfter">
		///     <para>
		///         A handle to the window to precede the positioned window in the Z order. This parameter must be a window handle or one of the following
		///         values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>HWND_BOTTOM (HWND)1</term>
		///             <description>
		///                 Places the window at the bottom of the Z order. If the <paramref name="hWnd" /> parameter identifies a topmost window, the window
		///                 loses its topmost status and is placed at the bottom of all other windows.
		///             </description>
		///         </item>
		///         <item>
		///             <term>HWND_NOTOPMOST (HWND)-2</term>
		///             <description>
		///                 Places the window above all non-topmost windows (that is, behind all topmost windows). This flag has no effect if the window is
		///                 already a non-topmost window.
		///             </description>
		///         </item>
		///         <item>
		///             <term>HWND_TOP (HWND)0</term>
		///             <description>Places the window at the top of the Z order.</description>
		///         </item>
		///         <item>
		///             <term>HWND_TOPMOST (HWND)-1</term>
		///             <description>Places the window above all non-topmost windows. The window maintains its topmost position even when it is deactivated.</description>
		///         </item>
		///     </list>
		///     <para>For more information about how this parameter is used, see the following Remarks section.</para>
		/// </param>
		/// <param name="X">The new position of the left side of the window, in client coordinates.</param>
		/// <param name="Y">The new position of the top of the window, in client coordinates.</param>
		/// <param name="cx">The new width of the window, in pixels.</param>
		/// <param name="cy">The new height of the window, in pixels.</param>
		/// <param name="uFlags">
		///     <para>The window sizing and positioning flags. This parameter can be a combination of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>SWP_ASYNCWINDOWPOS 0x4000</term>
		///             <description>
		///                 If the calling thread and the thread that owns the window are attached to different input queues, the system posts the request to the
		///                 thread that owns the window. This prevents the calling thread from blocking its execution while other threads process the request.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_DEFERERASE 0x2000</term>
		///             <description>
		///                 Prevents generation of the <see cref="WM.WM_SYNCPAINT" /> message.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_DRAWFRAME 0x0020</term>
		///             <description>Draws a frame (defined in the window's class description) around the window.</description>
		///         </item>
		///         <item>
		///             <term>SWP_FRAMECHANGED 0x0020</term>
		///             <description>
		///                 Applies new frame styles set using the <see cref="SetWindowLong" /> function. Sends a <see cref="WM.WM_NCCALCSIZE" /> message to the
		///                 window, even if the window's size is not being changed. If this flag is not specified, <see cref="WM.WM_NCCALCSIZE" /> is sent only
		///                 when the window's size is being changed.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_HIDEWINDOW 0x0080</term>
		///             <description>Hides the window.</description>
		///         </item>
		///         <item>
		///             <term>SWP_NOACTIVATE 0x0010</term>
		///             <description>
		///                 Does not activate the window. If this flag is not set, the window is activated and moved to the top of either the topmost or
		///                 non-topmost group (depending on the setting of the <paramref name="hWndInsertAfter" /> parameter).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_NOCOPYBITS 0x0100</term>
		///             <description>
		///                 Discards the entire contents of the client area. If this flag is not specified, the valid contents of the client area are saved and
		///                 copied back into the client area after the window is sized or repositioned.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_NOMOVE 0x0002</term>
		///             <description>
		///                 Retains the current position (ignores <paramref name="X" /> and <paramref name="Y" /> parameters).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_NOOWNERZORDER 0x0200</term>
		///             <description>Does not change the owner window's position in the Z order.</description>
		///         </item>
		///         <item>
		///             <term>SWP_NOREDRAW 0x0008</term>
		///             <description>
		///                 Does not redraw changes. If this flag is set, no repainting of any kind occurs. This applies to the client area, the nonclient area
		///                 (including the title bar and scroll bars), and any part of the parent window uncovered as a result of the window being moved. When
		///                 this flag is set, the application must explicitly invalidate or redraw any parts of the window and parent window that need redrawing.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_NOREPOSITION 0x0200</term>
		///             <description>
		///                 Same as the <see cref="SWP.SWP_NOOWNERZORDER" /> flag.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_NOSENDCHANGING 0x0400</term>
		///             <description>
		///                 Prevents the window from receiving the <see cref="WM.WM_WINDOWPOSCHANGING" /> message.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_NOSIZE 0x0001</term>
		///             <description>
		///                 Retains the current size (ignores the <paramref name="cx" /> and <paramref name="cy" /> parameters).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_NOZORDER 0x0004</term>
		///             <description>
		///                 Retains the current Z order (ignores the <paramref name="hWndInsertAfter" /> parameter).
		///             </description>
		///         </item>
		///         <item>
		///             <term>SWP_SHOWWINDOW 0x0040</term>
		///             <description>Displays the window.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         As part of the Vista re-architecture, all services were moved off the interactive desktop into Session 0. hwnd and window manager operations
		///         are only effective inside a session and cross-session attempts to manipulate the hwnd will fail. For more information, see The Windows Vista
		///         Developer Story: Application Compatibility Cookbook.
		///     </para>
		///     <para>
		///         If you have changed certain window data using <see cref="SetWindowLong" />, you must call <see cref="SetWindowPos" /> for the changes to take
		///         effect. Use the following combination for <paramref name="uFlags" />: SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED.
		///     </para>
		///     <para>
		///         A window can be made a topmost window either by setting the <paramref name="hWndInsertAfter" /> parameter to <see cref="HWND_TOPMOST" /> and
		///         ensuring that the <see cref="SWP.SWP_NOZORDER" /> flag is not set, or by setting a window's position in the Z order so that it is above any
		///         existing topmost windows. When a non-topmost window is made topmost, its owned windows are also made topmost. Its owners, however, are not
		///         changed.
		///     </para>
		///     <para>
		///         If neither the <see cref="SWP.SWP_NOACTIVATE" /> nor <see cref="SWP.SWP_NOZORDER" /> flag is specified (that is, when the application requests that a
		///         window be simultaneously activated and its position in the Z order changed), the value specified in <paramref name="hWndInsertAfter" /> is
		///         used only in the following circumstances.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetWindowPos")]
		public static extern bool SetWindowPos([In] IntPtr hWnd, [In] IntPtr hWndInsertAfter, int X, int Y, int cx, int cy, SWP uFlags);

		/// <summary>
		///     Sets the colors for the specified display elements. Display elements are the various parts of a window and the display that appear on the system
		///     display screen.
		/// </summary>
		/// <param name="cElements">
		///     The number of display elements in the <paramref name="lpaElements" /> array.
		/// </param>
		/// <param name="lpaElements">
		///     An array of integers that specify the display elements to be changed. For a list of display elements, see <see cref="GetSysColor" />.
		/// </param>
		/// <param name="lpaRgbValues">
		///     <para>
		///         An array of <see cref="COLORREF" /> values that contain the new red, green, blue (RGB) color values for the display elements in the array
		///         pointed to by the <paramref name="lpaElements" /> parameter.
		///     </para>
		///     <para>
		///         To generate a <see cref="COLORREF" />, use the RGB macro.
		///     </para>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a nonzero value.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="SetSysColors" /> function sends a <see cref="WM.WM_SYSCOLORCHANGE" /> message to all windows to inform them of the change in
		///         color. It also directs the system to repaint the affected portions of all currently visible windows.
		///     </para>
		///     <para>
		///         It is best to respect the color settings specified by the user. If you are writing an application to enable the user to change the colors,
		///         then it is appropriate to use this function. However, this function affects only the current session. The new colors are not saved when the
		///         system terminates.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetSysColors")]
		public static extern bool SetSysColors(
			int cElements, [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.I4, SizeParamIndex = 0)] int[] lpaElements,
			[MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.U4, SizeParamIndex = 0)] uint[] lpaRgbValues);

		/// <summary>
		///     <para>
		///         The <see cref="SetScrollPos" /> function sets the position of the scroll box (thumb) in the specified scroll bar and, if requested, redraws
		///         the scroll bar to reflect the new position of the scroll box.
		///     </para>
		///     <para>
		///         Note:  The <see cref="SetScrollPos" /> function is provided for backward compatibility. New applications should use the
		///         <see cref="SetScrollInfo" /> function.
		///     </para>
		/// </summary>
		/// <param name="hWnd">
		///     Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the <paramref name="nBar" /> parameter.
		/// </param>
		/// <param name="nBar">
		///     <para>Specifies the scroll bar to be set. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>SB_CTL</term>
		///             <description>
		///                 Sets the position of the scroll box in a scroll bar control. The <paramref name="hwnd" /> parameter must be the handle to the scroll
		///                 bar control.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SB_HORZ</term>
		///             <description>Sets the position of the scroll box in a window's standard horizontal scroll bar.</description>
		///         </item>
		///         <item>
		///             <term>SB_VERT</term>
		///             <description>Sets the position of the scroll box in a window's standard vertical scroll bar.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="nPos">
		///     Specifies the new position of the scroll box. The position must be within the scrolling range. For more information about the scrolling range,
		///     see the <see cref="SetScrollRange" /> function.
		/// </param>
		/// <param name="bRedraw">
		///     Specifies whether the scroll bar is redrawn to reflect the new scroll box position. If this parameter is TRUE, the scroll bar is redrawn. If it
		///     is FALSE, the scroll bar is not redrawn.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the previous position of the scroll box.</para>
		///     <para>Windows XP: If the desktop is themed and the parent window is a message-only window, the function returns an incorrect value.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If the scroll bar is redrawn by a subsequent call to another function, setting the <paramref name="bRedraw" /> parameter to FALSE is useful.
		///     </para>
		///     <para>
		///         Because the messages that indicate scroll bar position, <see cref="WM.WM_HSCROLL" /> and <see cref="WM.WM_VSCROLL" />, are limited to 16 bits
		///         of position data, applications that rely solely on those messages for position data have a practical maximum value of 65,535 for the
		///         <see cref="SetScrollPos" /> function's <paramref name="nPos" /> parameter.
		///     </para>
		///     <para>
		///         However, because the <see cref="SetScrollInfo" />, <see cref="SetScrollPos" />, <see cref="SetScrollRange" />, <see cref="GetScrollInfo" />,
		///         <see cref="GetScrollPos" />, and <see cref="GetScrollRange" /> functions support 32-bit scroll bar position data, there is a way to
		///         circumvent the 16-bit barrier of the <see cref="WM.WM_HSCROLL" /> and <see cref="WM.WM_VSCROLL" /> messages. See <see cref="GetScrollInfo" />
		///         for a description of the technique.
		///     </para>
		///     <para>
		///         If the <paramref name="nBar" /> parameter is SB_CTL and the window specified by the <paramref name="hWnd" /> parameter is not a system scroll
		///         bar control, the system sends the <see cref="SBM_SETPOS" /> message to the window to set scroll bar information. This allows
		///         <see cref="SetScrollPos" /> to operate on a custom control that mimics a scroll bar. If the window does not handle the
		///         <see cref="SBM_SETPOS" /> message, the <see cref="SetScrollPos" /> function fails.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetScrollPos")]
		public static extern int SetScrollPos([In] IntPtr hWnd, int nBar, int nPos, [MarshalAs(UnmanagedType.Bool)] bool bRedraw);

		/// <summary>
		///     The <see cref="SetRectEmpty" /> function creates an empty rectangle in which all coordinates are set to zero.
		/// </summary>
		/// <param name="lprc">
		///     Pointer to the <see cref="RECT" /> structure that contains the coordinates of the rectangle.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all
		///     rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used
		///     determine the units of measure.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetRectEmpty")]
		public static extern bool SetRectEmpty([Out] out RECT lprc);

		/// <summary>
		///     Moves the cursor to the specified screen coordinates. If the new coordinates are not within the screen rectangle set by the most recent
		///     <see cref="ClipCursor" /> function call, the system automatically adjusts the coordinates so that the cursor stays within the rectangle.
		/// </summary>
		/// <param name="X">The new x-coordinate of the cursor, in screen coordinates.</param>
		/// <param name="Y">The new y-coordinate of the cursor, in screen coordinates.</param>
		/// <returns>Returns nonzero if successful or zero otherwise. To get extended error information, call GetLastError.</returns>
		/// <remarks>
		///     <para>The cursor is a shared resource. A window should move the cursor only when the cursor is in the window's client area.</para>
		///     <para>
		///         The calling process must have <see cref="WINSTA_WRITEATTRIBUTES" /> access to the window station.
		///     </para>
		///     <para>
		///         The input desktop must be the current desktop when you call <see cref="SetCursorPos" />. Call <see cref="OpenInputDesktop" /> to determine
		///         whether the current desktop is the input desktop. If it is not, call <see cref="SetThreadDesktop" /> with the <see cref="HDESK" /> returned
		///         by <see cref="OpenInputDesktop" /> to switch to that desktop.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetCursorPos")]
		public static extern bool SetCursorPos(int X, int Y);

		/// <summary>
		///     <para>
		///         Replaces the 16-bit (WORD) value at the specified offset into the extra class memory for the window class to which the
		///         specified window belongs.
		///     </para>
		///     <para>
		///         Note:  This function is provided only for compatibility with 16-bit versions of Windows. Applications should use the
		///         <see cref="SetClassLong" /> function.
		///     </para>
		/// </summary>
		/// <param name="hWnd">A handle to the window and, indirectly, the class to which the window belongs.</param>
		/// <param name="nIndex">
		///     The zero-based byte offset of the value to be replaced. Valid values are in the range zero through the number of bytes of class memory minus two;
		///     for example, if you specified 10 or more bytes of extra class memory, a value of 8 would be an index to the fifth 16-bit integer.
		/// </param>
		/// <param name="wNewWord">The replacement value.</param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is the previous value of the specified 16-bit integer. If the value was not previously set, the
		///         return value is zero.
		///     </para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     Reserve extra class memory by specifying a nonzero value in the <see cref="cbClsExtra" /> member of the <see cref="WNDCLASS" /> structure used
		///     with the <see cref="RegisterClass" /> function.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetClassWord")]
		public static extern ushort SetClassWord([In] IntPtr hWnd, int nIndex, ushort wNewWord);

		/// <summary>
		///     <para>
		///         Sends the specified message to a window or windows. The <see cref="SendMessage" /> function calls the window procedure for the specified
		///         window and does not return until the window procedure has processed the message.
		///     </para>
		///     <para>
		///         To send a message and return immediately, use the <see cref="SendMessageCallback" /> or <see cref="SendNotifyMessage" /> function. To post a
		///         message to a thread's message queue and return immediately, use the <see cref="PostMessage" /> or <see cref="PostThreadMessage" /> function.
		///     </para>
		/// </summary>
		/// <param name="hWnd">
		///     <para>
		///         A handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff),
		///         the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up
		///         windows; but the message is not sent to child windows.
		///     </para>
		///     <para>
		///         Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of lesser or
		///         equal integrity level.
		///     </para>
		/// </param>
		/// <param name="Msg">
		///     <para>The message to be sent.</para>
		///     <para>For lists of the system-provided messages, see System-Defined Messages.</para>
		/// </param>
		/// <param name="wParam">Additional message-specific information.</param>
		/// <param name="lParam">Additional message-specific information.</param>
		/// <returns>
		///     <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
		/// </returns>
		/// <remarks>
		///     <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
		///     <para>
		///         Applications that need to communicate using HWND_BROADCAST should use the <see cref="RegisterWindowMessage" /> function to
		///         obtain a unique message for inter-application communication.
		///     </para>
		///     <para>
		///         The system only does marshalling for system messages (those in the range 0 to (<see cref="WM.WM_USER" />-1)). To send other messages (those
		///         >=
		///         <see cref="WM.WM_USER" />) to another process, you must do custom marshalling.
		///     </para>
		///     <para>
		///         If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the specified
		///         window was created by a different thread, the system switches to that thread and calls the appropriate window procedure. Messages sent
		///         between threads are processed only when the receiving thread executes message retrieval code. The sending thread is blocked until the
		///         receiving thread processes the message. However, the sending thread will process incoming nonqueued messages while waiting for its message to
		///         be processed. To prevent this, use <see cref="SendMessageTimeout" /> with SMTO_BLOCK set. For more information on nonqueued messages, see
		///         Nonqueued Messages.
		///     </para>
		///     <para>
		///         An accessibility application can use <see cref="SendMessage(IntPtr, uint, IntPtr, IntPtr)" /> to send <see cref="WM.WM_APPCOMMAND" /> 
		///         messages to the shell to launch applications. This functionality is not guaranteed to work for other types of applications.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SendMessage")]
		public static extern IntPtr SendMessage([In] IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

		/// <summary>
		///     <para>
		///         Sends the specified message to a window or windows. The <see cref="SendMessage" /> function calls the window procedure for the specified
		///         window and does not return until the window procedure has processed the message.
		///     </para>
		///     <para>
		///         To send a message and return immediately, use the <see cref="SendMessageCallback" /> or <see cref="SendNotifyMessage" /> function. To post a
		///         message to a thread's message queue and return immediately, use the <see cref="PostMessage" /> or <see cref="PostThreadMessage" /> function.
		///     </para>
		/// </summary>
		/// <param name="hWnd">
		///     <para>
		///         A handle to the window whose window procedure will receive the message. If this parameter is HWND_BROADCAST ((HWND)0xffff),
		///         the message is sent to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows, and pop-up
		///         windows; but the message is not sent to child windows.
		///     </para>
		///     <para>
		///         Message sending is subject to UIPI. The thread of a process can send messages only to message queues of threads in processes of lesser or
		///         equal integrity level.
		///     </para>
		/// </param>
		/// <param name="Msg">
		///     <para>The message to be sent.</para>
		///     <para>For lists of the system-provided messages, see System-Defined Messages.</para>
		/// </param>
		/// <param name="wParam">Additional message-specific information.</param>
		/// <param name="lParam">Additional message-specific information.</param>
		/// <returns>
		///     <para>The return value specifies the result of the message processing; it depends on the message sent.</para>
		/// </returns>
		/// <remarks>
		///     <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
		///     <para>
		///         Applications that need to communicate using HWND_BROADCAST should use the <see cref="RegisterWindowMessage" /> function to
		///         obtain a unique message for inter-application communication.
		///     </para>
		///     <para>
		///         The system only does marshalling for system messages (those in the range 0 to (<see cref="WM.WM_USER" />-1)). To send other messages (those
		///         >=
		///         <see cref="WM.WM_USER" />) to another process, you must do custom marshalling.
		///     </para>
		///     <para>
		///         If the specified window was created by the calling thread, the window procedure is called immediately as a subroutine. If the specified
		///         window was created by a different thread, the system switches to that thread and calls the appropriate window procedure. Messages sent
		///         between threads are processed only when the receiving thread executes message retrieval code. The sending thread is blocked until the
		///         receiving thread processes the message. However, the sending thread will process incoming nonqueued messages while waiting for its message to
		///         be processed. To prevent this, use <see cref="SendMessageTimeout" /> with SMTO_BLOCK set. For more information on nonqueued messages, see
		///         Nonqueued Messages.
		///     </para>
		///     <para>
		///         An accessibility application can use <see cref="SendMessage(IntPtr, uint, IntPtr, IntPtr)" /> to send <see cref="WM.WM_APPCOMMAND" /> 
		///         messages to the shell to launch applications. This functionality is not guaranteed to work for other types of applications.
		///     </para>
		/// </remarks>
		public static IntPtr SendMessage([In] IntPtr hWnd, WM Msg, IntPtr wParam, IntPtr lParam)
		{
			return SendMessage(hWnd, (uint) Msg, lParam, wParam);
		}

		/// <summary>
		///     <para>
		///         The <see cref="ScrollWindow" /> function scrolls the contents of the specified window's client area.
		///     </para>
		///     <para>
		///         Note:  The <see cref="ScrollWindow" /> function is provided for backward compatibility. New applications should use the
		///         <see cref="ScrollWindowEx" /> function.
		///     </para>
		/// </summary>
		/// <param name="hWnd">Handle to the window where the client area is to be scrolled.</param>
		/// <param name="XAmount">
		///     Specifies the amount, in device units, of horizontal scrolling. If the window being scrolled has the <see cref="CS.CS_OWNDC" /> or
		///     <see cref="CS.CS_CLASSDC" /> style, then this parameter uses logical units rather than device units. This parameter must be a negative value to
		///     scroll the content of the window to the left.
		/// </param>
		/// <param name="YAmount">
		///     Specifies the amount, in device units, of vertical scrolling. If the window being scrolled has the <see cref="CS.CS_OWNDC" /> or
		///     <see cref="CS.CS_CLASSDC" /> style, then this parameter uses logical units rather than device units. This parameter must be a negative value to
		///     scroll the content of the window up.
		/// </param>
		/// <param name="lpRect">
		///     Pointer to the <see cref="RECT" /> structure specifying the portion of the client area to be scrolled. If this parameter is NULL, the entire
		///     client area is scrolled.
		/// </param>
		/// <param name="lpClipRect">
		///     Pointer to the <see cref="RECT" /> structure containing the coordinates of the clipping rectangle. Only device bits within the clipping rectangle
		///     are affected. Bits scrolled from the outside of the rectangle to the inside are painted; bits scrolled from the inside of the rectangle to the
		///     outside are not painted.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If the caret is in the window being scrolled, <see cref="ScrollWindow" /> automatically hides the caret to prevent it from being erased and
		///         then restores the caret after the scrolling is finished. The caret position is adjusted accordingly.
		///     </para>
		///     <para>
		///         The area uncovered by <see cref="ScrollWindow" /> is not repainted, but it is combined into the window's update region. The application
		///         eventually receives a <see cref="WM.WM_PAINT" /> message notifying it that the region must be repainted. To repaint the uncovered area at the
		///         same time the scrolling is in action, call the <see cref="UpdateWindow" /> function immediately after calling <see cref="ScrollWindow" />.
		///     </para>
		///     <para>
		///         If the <paramref name="lpRect" /> parameter is NULL, the positions of any child windows in the window are offset by the amount specified by
		///         the <paramref name="XAmount" /> and <paramref name="YAmount" /> parameters; invalid (unpainted) areas in the window are also offset.
		///         <see cref="ScrollWindow" /> is faster when <paramref name="lpRect" /> is NULL.
		///     </para>
		///     <para>
		///         If <paramref name="lpRect" /> is not NULL, the positions of child windows are not changed and invalid areas in the window are not offset. To
		///         prevent updating problems when <paramref name="lpRect" /> is not NULL, call <see cref="UpdateWindow" /> to repaint the window before calling
		///         <see cref="ScrollWindow" />.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "ScrollWindow")]
		public static extern bool ScrollWindow([In] IntPtr hWnd, int XAmount, int YAmount, [In] ref RECT lpRect, [In] ref RECT lpClipRect);

		/// <summary>
		///     Replies to a message sent through the <see cref="SendMessage" /> function without returning control to the function that called
		///     <see cref="SendMessage" />.
		/// </summary>
		/// <param name="lResult">The result of the message processing. The possible values are based on the message sent.</param>
		/// <returns>
		///     <para>If the calling thread was processing a message sent from another thread or process, the return value is nonzero.</para>
		///     <para>If the calling thread was not processing a message sent from another thread or process, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         By calling this function, the window procedure that receives the message allows the thread that called <see cref="SendMessage" /> to continue
		///         to run as though the thread receiving the message had returned control. The thread that calls the <see cref="ReplyMessage" /> function also
		///         continues to run.
		///     </para>
		///     <para>
		///         If the message was not sent through <see cref="SendMessage" /> or if the message was sent by the same thread, <see cref="ReplyMessage" /> has
		///         no effect.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "ReplyMessage")]
		public static extern bool ReplyMessage([MarshalAs(UnmanagedType.SysInt)] int lResult);

		/// <summary>
		///     The <see cref="RedrawWindow" /> function updates the specified rectangle or region in a window's client area.
		/// </summary>
		/// <param name="hWnd">A handle to the window to be redrawn. If this parameter is NULL, the desktop window is updated.</param>
		/// <param name="lprcUpdate">
		///     A pointer to a <see cref="RECT" /> structure containing the coordinates, in device units, of the update rectangle. This parameter is ignored if
		///     the <paramref name="hrgnUpdate" /> parameter identifies a region.
		/// </param>
		/// <param name="hrgnUpdate">
		///     A handle to the update region. If both the <paramref name="hrgnUpdate" /> and <paramref name="lprcUpdate" /> parameters are NULL, the entire
		///     client area is added to the update region.
		/// </param>
		/// <param name="flags">
		///     <para>
		///         One or more redraw flags. This parameter can be used to invalidate or validate a window, control repainting, and control which windows are
		///         affected by <see cref="RedrawWindow" />.
		///     </para>
		///     <para>The following flags are used to invalidate the window.</para>
		///     <list type="table">
		///         <item>
		///             <term>RDW_ERASE</term>
		///             <description>
		///                 Causes the window to receive a <see cref="WM.WM_ERASEBKGND" /> message when the window is repainted. The RDW_INVALIDATE flag must
		///                 also be specified; otherwise, RDW_ERASE has no effect.
		///             </description>
		///         </item>
		///         <item>
		///             <term>RDW_FRAME</term>
		///             <description>
		///                 Causes any part of the nonclient area of the window that intersects the update region to receive a <see cref="WM.WM_NCPAINT" />
		///                 message. The RDW_INVALIDATE flag must also be specified; otherwise, RDW_FRAME has no effect. The <see cref="WM.WM_NCPAINT" /> message
		///                 is typically not sent during the execution of <see cref="RedrawWindow" /> unless either RDW_UPDATENOW or RDW_ERASENOW is specified.
		///             </description>
		///         </item>
		///         <item>
		///             <term>RDW_INTERNALPAINT</term>
		///             <description>
		///                 Causes a <see cref="WM.WM_PAINT" /> message to be posted to the window regardless of whether any portion of the window is invalid.
		///             </description>
		///         </item>
		///         <item>
		///             <term>RDW_INVALIDATE</term>
		///             <description>
		///                 Invalidates <paramref name="lprcUpdate" /> or <paramref name="hrgnUpdate" /> (only one may be non-NULL). If both are NULL, the entire
		///                 window is invalidated.
		///             </description>
		///         </item>
		///     </list>
		///     <para>The following flags are used to validate the window.</para>
		///     <list type="table">
		///         <item>
		///             <term>RDW_NOERASE</term>
		///             <description>
		///                 Suppresses any pending <see cref="WM.WM_ERASEBKGND" /> messages.
		///             </description>
		///         </item>
		///         <item>
		///             <term>RDW_NOFRAME</term>
		///             <description>
		///                 Suppresses any pending <see cref="WM.WM_NCPAINT" /> messages. This flag must be used with RDW_VALIDATE and is typically used with
		///                 RDW_NOCHILDREN. RDW_NOFRAME should be used with care, as it could cause parts of a window to be painted improperly.
		///             </description>
		///         </item>
		///         <item>
		///             <term>RDW_NOINTERNALPAINT</term>
		///             <description>
		///                 Suppresses any pending internal <see cref="WM.WM_PAINT" /> messages. This flag does not affect <see cref="WM.WM_PAINT" /> messages
		///                 resulting from a non-NULL update area.
		///             </description>
		///         </item>
		///         <item>
		///             <term>RDW_VALIDATE</term>
		///             <description>
		///                 Validates <paramref name="lprcUpdate" /> or <paramref name="hrgnUpdate" /> (only one may be non-NULL). If both are NULL, the entire
		///                 window is validated. This flag does not affect internal <see cref="WM.WM_PAINT" /> messages.
		///             </description>
		///         </item>
		///     </list>
		///     <para>
		///         The following flags control when repainting occurs. <see cref="RedrawWindow" /> will not repaint unless one of these flags is specified.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>RDW_ERASENOW</term>
		///             <description>
		///                 Causes the affected windows (as specified by the RDW_ALLCHILDREN and RDW_NOCHILDREN flags) to receive <see cref="WM.WM_NCPAINT" />
		///                 and
		///                 <see cref="WM.WM_ERASEBKGND" /> messages, if necessary, before the function returns. <see cref="WM.WM_PAINT" /> messages are received
		///                 at the ordinary time.
		///             </description>
		///         </item>
		///         <item>
		///             <term>RDW_UPDATENOW</term>
		///             <description>
		///                 Causes the affected windows (as specified by the RDW_ALLCHILDREN and RDW_NOCHILDREN flags) to receive <see cref="WM.WM_NCPAINT" />,
		///                 <see cref="WM.WM_ERASEBKGND" />, and <see cref="WM.WM_PAINT" /> messages, if necessary, before the function returns.
		///             </description>
		///         </item>
		///     </list>
		///     <para>
		///         By default, the windows affected by <see cref="RedrawWindow" /> depend on whether the specified window has the WS_CLIPCHILDREN style. Child
		///         windows that are not the WS_CLIPCHILDREN style are unaffected; non-WS_CLIPCHILDREN windows are recursively validated or invalidated until a
		///         WS_CLIPCHILDREN window is encountered. The following flags control which windows are affected by the <see cref="RedrawWindow" /> function.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>RDW_ALLCHILDREN</term>
		///             <description>Includes child windows, if any, in the repainting operation.</description>
		///         </item>
		///         <item>
		///             <term>RDW_NOCHILDREN</term>
		///             <description>Excludes child windows, if any, from the repainting operation.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     When <see cref="RedrawWindow" /> is used to invalidate part of the desktop window, the desktop window does not receive a
		///     <see cref="WM.WM_PAINT" />
		///     message. To repaint the desktop, an application uses the RDW_ERASE flag to generate a <see cref="WM.WM_ERASEBKGND" /> message.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "RedrawWindow")]
		public static extern bool RedrawWindow([In] IntPtr hWnd, [In] ref RECT lprcUpdate, [In] IntPtr hrgnUpdate, RDW flags);

		/// <summary>
		///     <para>
		///         Places (posts) a message in the message queue associated with the thread that created the specified window and returns without waiting for
		///         the thread to process the message.
		///     </para>
		///     <para>
		///         To post a message in the message queue associated with a thread, use the <see cref="PostThreadMessage" /> function.
		///     </para>
		/// </summary>
		/// <param name="hWnd">
		///     <para>A handle to the window whose window procedure is to receive the message. The following values have special meanings.</para>
		///     <list type="table">
		///         <item>
		///             <term>HWND_BROADCAST ((HWND)0xffff)</term>
		///             <description>
		///                 The message is posted to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows,
		///                 and pop-up windows. The message is not posted to child windows.
		///             </description>
		///         </item>
		///         <item>
		///             <term>NULL</term>
		///             <description>
		///                 The function behaves like a call to <see cref="PostThreadMessage" /> with the <paramref name="dwThreadId" /> parameter set to the
		///                 identifier of the current thread.
		///             </description>
		///         </item>
		///     </list>
		///     <para>
		///         Starting with Windows Vista, message posting is subject to UIPI. The thread of a process can post messages only to message queues of threads
		///         in processes of lesser or equal integrity level.
		///     </para>
		/// </param>
		/// <param name="Msg">
		///     <para>The message to be posted.</para>
		///     <para>For lists of the system-provided messages, see System-Defined Messages.</para>
		/// </param>
		/// <param name="wParam">Additional message-specific information.</param>
		/// <param name="lParam">Additional message-specific information.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>
		///         If the function fails, the return value is zero. To get extended error information, call GetLastError. GetLastError returns
		///         <see cref="ERROR_NOT_ENOUGH_QUOTA" /> when the limit is hit.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
		///     <para>
		///         Messages in a message queue are retrieved by calls to the <see cref="GetMessage" /> or <see cref="PeekMessage" /> function.
		///     </para>
		///     <para>
		///         Applications that need to communicate using HWND_BROADCAST should use the <see cref="RegisterWindowMessage" /> function to
		///         obtain a unique message for inter-application communication.
		///     </para>
		///     <para>
		///         The system only does marshalling for system messages (those in the range 0 to (<see cref="WM.WM_USER" />-1)). To send other messages (those
		///         >=
		///         <see cref="WM.WM_USER" />) to another process, you must do custom marshalling.
		///     </para>
		///     <para>
		///         If you send a message in the range below <see cref="WM.WM_USER" /> to the asynchronous message functions (<see cref="PostMessage" />,
		///         <see cref="SendNotifyMessage" />, and <see cref="SendMessageCallback" />), its message parameters cannot include pointers. Otherwise, the
		///         operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free
		///         the memory before it is used.
		///     </para>
		///     <para>
		///         Do not post the <see cref="WM.WM_QUIT" /> message using <see cref="PostMessage" />; use the <see cref="PostQuitMessage" /> function.
		///     </para>
		///     <para>
		///         An accessibility application can use <see cref="PostMessage" /> to post <see cref="WM.WM_APPCOMMAND" /> messages to the shell to launch
		///         applications. This functionality is not guaranteed to work for other types of applications.
		///     </para>
		///     <para>
		///         There is a limit of 10,000 posted messages per message queue. This limit should be sufficiently large. If your application exceeds the limit,
		///         it should be redesigned to avoid consuming so many system resources. To adjust this limit, modify the following registry key.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "PostMessage")]
		public static extern bool PostMessage([In] IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

		/// <summary>
		///     <para>
		///         Places (posts) a message in the message queue associated with the thread that created the specified window and returns without waiting for
		///         the thread to process the message.
		///     </para>
		///     <para>
		///         To post a message in the message queue associated with a thread, use the <see cref="PostThreadMessage" /> function.
		///     </para>
		/// </summary>
		/// <param name="hWnd">
		///     <para>A handle to the window whose window procedure is to receive the message. The following values have special meanings.</para>
		///     <list type="table">
		///         <item>
		///             <term>HWND_BROADCAST ((HWND)0xffff)</term>
		///             <description>
		///                 The message is posted to all top-level windows in the system, including disabled or invisible unowned windows, overlapped windows,
		///                 and pop-up windows. The message is not posted to child windows.
		///             </description>
		///         </item>
		///         <item>
		///             <term>NULL</term>
		///             <description>
		///                 The function behaves like a call to <see cref="PostThreadMessage" /> with the <paramref name="dwThreadId" /> parameter set to the
		///                 identifier of the current thread.
		///             </description>
		///         </item>
		///     </list>
		///     <para>
		///         Starting with Windows Vista, message posting is subject to UIPI. The thread of a process can post messages only to message queues of threads
		///         in processes of lesser or equal integrity level.
		///     </para>
		/// </param>
		/// <param name="Msg">
		///     <para>The message to be posted.</para>
		///     <para>For lists of the system-provided messages, see System-Defined Messages.</para>
		/// </param>
		/// <param name="wParam">Additional message-specific information.</param>
		/// <param name="lParam">Additional message-specific information.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>
		///         If the function fails, the return value is zero. To get extended error information, call GetLastError. GetLastError returns
		///         <see cref="ERROR_NOT_ENOUGH_QUOTA" /> when the limit is hit.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>When a message is blocked by UIPI the last error, retrieved with GetLastError, is set to 5 (access denied).</para>
		///     <para>
		///         Messages in a message queue are retrieved by calls to the <see cref="GetMessage" /> or <see cref="PeekMessage" /> function.
		///     </para>
		///     <para>
		///         Applications that need to communicate using HWND_BROADCAST should use the <see cref="RegisterWindowMessage" /> function to
		///         obtain a unique message for inter-application communication.
		///     </para>
		///     <para>
		///         The system only does marshalling for system messages (those in the range 0 to (<see cref="WM.WM_USER" />-1)). To send other messages (those
		///         >=
		///         <see cref="WM.WM_USER" />) to another process, you must do custom marshalling.
		///     </para>
		///     <para>
		///         If you send a message in the range below <see cref="WM.WM_USER" /> to the asynchronous message functions (<see cref="PostMessage" />,
		///         <see cref="SendNotifyMessage" />, and <see cref="SendMessageCallback" />), its message parameters cannot include pointers. Otherwise, the
		///         operation will fail. The functions will return before the receiving thread has had a chance to process the message and the sender will free
		///         the memory before it is used.
		///     </para>
		///     <para>
		///         Do not post the <see cref="WM.WM_QUIT" /> message using <see cref="PostMessage" />; use the <see cref="PostQuitMessage" /> function.
		///     </para>
		///     <para>
		///         An accessibility application can use <see cref="PostMessage" /> to post <see cref="WM.WM_APPCOMMAND" /> messages to the shell to launch
		///         applications. This functionality is not guaranteed to work for other types of applications.
		///     </para>
		///     <para>
		///         There is a limit of 10,000 posted messages per message queue. This limit should be sufficiently large. If your application exceeds the limit,
		///         it should be redesigned to avoid consuming so many system resources. To adjust this limit, modify the following registry key.
		///     </para>
		/// </remarks>
		public static bool PostMessage([In] IntPtr hWnd, WM Msg, IntPtr wParam, IntPtr lParam)
		{
			return PostMessage(hWnd, (uint) Msg, wParam, lParam);
		}

		/// <summary>Dispatches incoming sent messages, checks the thread message queue for a posted message, and retrieves the message (if any exist).</summary>
		/// <param name="lpMsg">
		///     A pointer to an <see cref="MSG" /> structure that receives message information.
		/// </param>
		/// <param name="hWnd">
		///     <para>A handle to the window whose messages are to be retrieved. The window must belong to the current thread.</para>
		///     <para>
		///         If <paramref name="hWnd" /> is NULL, <see cref="PeekMessage" /> retrieves messages for any window that belongs to the current thread, and any
		///         messages on the current thread's message queue whose <see cref="hwnd" /> value is NULL (see the <see cref="MSG" /> structure). Therefore if
		///         hWnd is NULL, both window messages and thread messages are processed.
		///     </para>
		///     <para>
		///         If <paramref name="hWnd" /> is -1, <see cref="PeekMessage" /> retrieves only messages on the current thread's message queue whose
		///         <see cref="hwnd" /> value is NULL, that is, thread messages as posted by <see cref="PostMessage" /> (when the <paramref name="hWnd" />
		///         parameter is NULL) or <see cref="PostThreadMessage" />.
		///     </para>
		/// </param>
		/// <param name="wMsgFilterMin">
		///     <para>
		///         The value of the first message in the range of messages to be examined. Use <see cref="WM.WM_KEYFIRST" /> (0x0100) to specify the first
		///         keyboard message or <see cref="WM.WM_MOUSEFIRST" /> (0x0200) to specify the first mouse message.
		///     </para>
		///     <para>
		///         If <paramref name="wMsgFilterMin" /> and <paramref name="wMsgFilterMax" /> are both zero, <see cref="PeekMessage" /> returns all available
		///         messages (that is, no range filtering is performed).
		///     </para>
		/// </param>
		/// <param name="wMsgFilterMax">
		///     <para>
		///         The value of the last message in the range of messages to be examined. Use <see cref="WM.WM_KEYLAST" /> to specify the last keyboard message
		///         or
		///         <see cref="WM.WM_MOUSELAST" /> to specify the last mouse message.
		///     </para>
		///     <para>
		///         If <paramref name="wMsgFilterMin" /> and <paramref name="wMsgFilterMax" /> are both zero, <see cref="PeekMessage" /> returns all available
		///         messages (that is, no range filtering is performed).
		///     </para>
		/// </param>
		/// <param name="wRemoveMsg">
		///     <para>Specifies how messages are to be handled. This parameter can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>PM_NOREMOVE 0x0000</term>
		///             <description>
		///                 Messages are not removed from the queue after processing by <see cref="PeekMessage" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>PM_REMOVE 0x0001</term>
		///             <description>
		///                 Messages are removed from the queue after processing by <see cref="PeekMessage" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>PM_NOYIELD 0x0002</term>
		///             <description>
		///                 <para>
		///                     Prevents the system from releasing any thread that is waiting for the caller to go idle (see <see cref="WaitForInputIdle" />).
		///                 </para>
		///                 <para>
		///                     Combine this value with either <see cref="PM_NOREMOVE" /> or <see cref="PM_REMOVE" />.
		///                 </para>
		///             </description>
		///         </item>
		///     </list>
		///     <para>
		///         By default, all message types are processed. To specify that only certain message should be processed, specify one or more of the following
		///         values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>
		///                 PM_QS_INPUT (QS_INPUT << 16)</term>
		///             <description>Process mouse and keyboard messages.</description>
		///         </item>
		///         <item>
		///             <term>
		///                 PM_QS_PAINT (QS_PAINT << 16)</term>
		///             <description>Process paint messages.</description>
		///         </item>
		///         <item>
		///             <term>
		///                 PM_QS_POSTMESSAGE ((QS_POSTMESSAGE | QS_HOTKEY | QS_TIMER) << 16)</term>
		///             <description>Process all posted messages, including timers and hotkeys.</description>
		///         </item>
		///         <item>
		///             <term>
		///                 PM_QS_SENDMESSAGE (QS_SENDMESSAGE << 16)</term>
		///             <description>Process all sent messages.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If a message is available, the return value is nonzero.</para>
		///     <para>If no messages are available, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         <see cref="PeekMessage" /> retrieves messages associated with the window identified by the <paramref name="hWnd" /> parameter or any of its
		///         children as specified by the <see cref="IsChild" /> function, and within the range of message values given by the
		///         <paramref name="wMsgFilterMin" /> and <paramref name="wMsgFilterMax" /> parameters. Note that an application can only use the low word in the
		///         <paramref name="wMsgFilterMin" /> and <paramref name="wMsgFilterMax" /> parameters; the high word is reserved for the system.
		///     </para>
		///     <para>
		///         Note that <see cref="PeekMessage" /> always retrieves <see cref="WM.WM_QUIT" /> messages, no matter which values you specify for
		///         <paramref name="wMsgFilterMin" /> and <paramref name="wMsgFilterMax" />.
		///     </para>
		///     <para>
		///         During this call, the system delivers pending, nonqueued messages, that is, messages sent to windows owned by the calling thread using the
		///         <see cref="SendMessage" />, <see cref="SendMessageCallback" />, <see cref="SendMessageTimeout" />, or <see cref="SendNotifyMessage" />
		///         function. Then the first queued message that matches the specified filter is retrieved. The system may also process internal events. If no
		///         filter is specified, messages are processed in the following order:
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "PeekMessage")]
		public static extern bool PeekMessage([Out] out MSG lpMsg, [In] IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax, uint wRemoveMsg);

		/// <summary>
		///     The <see cref="PaintDesktop" /> function fills the clipping region in the specified device context with the desktop pattern or wallpaper. The
		///     function is provided primarily for shell desktops.
		/// </summary>
		/// <param name="hdc">Handle to the device context.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "PaintDesktop")]
		public static extern bool PaintDesktop([In] IntPtr hdc);

		/// <summary>Opens the specified desktop object.</summary>
		/// <param name="lpszDesktop">
		///     <para>The name of the desktop to be opened. Desktop names are case-insensitive.</para>
		///     <para>This desktop must belong to the current window station.</para>
		/// </param>
		/// <param name="dwFlags">
		///     <para>This parameter can be zero or the following value.</para>
		///     <list type="table">
		///         <item>
		///             <term>DF_ALLOWOTHERACCOUNTHOOK 0x0001</term>
		///             <description>Allows processes running in other accounts on the desktop to set hooks in this process.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="fInherit">
		///     If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this
		///     handle.
		/// </param>
		/// <param name="dwDesiredAccess">The access to the desktop. For a list of access rights, see Desktop Security and Access Rights.</param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is a handle to the opened desktop. When you are finished using the handle, call the
		///         <see cref="CloseDesktop" /> function to close it.
		///     </para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The calling process must have an associated window station, either assigned by the system at process creation time or set by the
		///         <see cref="SetProcessWindowStation" /> function.
		///     </para>
		///     <para>
		///         If the <paramref name="dwDesiredAccess" /> parameter specifies the READ_CONTROL, WRITE_DAC, or WRITE_OWNER standard access rights, you must
		///         also request the DESKTOP_READOBJECTS and DESKTOP_WRITEOBJECTS access rights.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "OpenDesktop")]
		public static extern IntPtr OpenDesktop([In] string lpszDesktop, DF dwFlags, [MarshalAs(UnmanagedType.Bool)] bool fInherit, uint dwDesiredAccess);

		/// <summary>
		///     Determines whether a character is uppercase. This determination is based on the semantics of the language selected by the user during setup or
		///     through Control Panel.
		/// </summary>
		/// <param name="ch">The character to be tested.</param>
		/// <returns>
		///     <para>If the character is uppercase, the return value is nonzero.</para>
		///     <para>If the character is not uppercase, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "IsCharUpper")]
		public static extern bool IsCharUpper(char ch);

		/// <summary>
		///     Determines whether a character is lowercase. This determination is based on the semantics of the language selected by the user during setup or
		///     through Control Panel.
		/// </summary>
		/// <param name="ch">The character to be tested.</param>
		/// <returns>
		///     <para>If the character is lowercase, the return value is nonzero.</para>
		///     <para>If the character is not lowercase, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "IsCharLower")]
		public static extern bool IsCharLower(char ch);

		/// <summary>
		///     Determines whether a character is an alphabetical character. This determination is based on the semantics of the language selected by the user
		///     during setup or through Control Panel.
		/// </summary>
		/// <param name="ch">The character to be tested.</param>
		/// <returns>
		///     <para>If the character is alphabetical, the return value is nonzero.</para>
		///     <para>If the character is not alphabetical, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "IsCharAlpha")]
		public static extern bool IsCharAlpha(char ch);

		/// <summary>
		///     The <see cref="GetWindowRgn" /> function obtains a copy of the window region of a window. The window region of a window is set by calling the
		///     <see cref="SetWindowRgn" /> function. The window region determines the area within the window where the system permits drawing. The system does
		///     not display any portion of a window that lies outside of the window region
		/// </summary>
		/// <param name="hWnd">Handle to the window whose window region is to be obtained.</param>
		/// <param name="hRgn">Handle to the region which will be modified to represent the window region.</param>
		/// <returns>The return value specifies the type of the region that the function obtains. It can be one of the following values.</returns>
		/// <remarks>
		///     <para>The coordinates of a window's window region are relative to the upper-left corner of the window, not the client area of the window.</para>
		///     <para>
		///         To set the window region of a window, call the <see cref="SetWindowRgn" /> function.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetWindowRgn")]
		public static extern int GetWindowRgn([In] IntPtr hWnd, [In] IntPtr hRgn);

		/// <summary>
		///     The <see cref="GetUpdateRgn" /> function retrieves the update region of a window by copying it into the specified region. The coordinates of the
		///     update region are relative to the upper-left corner of the window (that is, they are client coordinates).
		/// </summary>
		/// <param name="hWnd">Handle to the window with an update region that is to be retrieved.</param>
		/// <param name="hRgn">Handle to the region to receive the update region.</param>
		/// <param name="bErase">
		///     Specifies whether the window background should be erased and whether nonclient areas of child windows should be drawn. If this parameter is
		///     FALSE, no drawing is done.
		/// </param>
		/// <returns>The return value indicates the complexity of the resulting region; it can be one of the following values.</returns>
		/// <remarks>
		///     The <see cref="BeginPaint" /> function automatically validates the update region, so any call to <see cref="GetUpdateRgn" /> made immediately
		///     after the call to <see cref="BeginPaint" /> retrieves an empty update region.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetUpdateRgn")]
		public static extern int GetUpdateRgn([In] IntPtr hWnd, [In] IntPtr hRgn, [MarshalAs(UnmanagedType.Bool)] bool bErase);

		/// <summary>
		///     Examines the Z order of the child windows associated with the specified parent window and retrieves a handle to the child window at the top of
		///     the Z order.
		/// </summary>
		/// <param name="hWnd">
		///     A handle to the parent window whose child windows are to be examined. If this parameter is NULL, the function returns a handle to the window at
		///     the top of the Z order.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is a handle to the child window at the top of the Z order. If the specified window has no child
		///         windows, the return value is NULL. To get extended error information, use the GetLastError function.
		///     </para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetTopWindow")]
		public static extern IntPtr GetTopWindow([In] IntPtr hWnd);

		/// <summary>
		///     <para>
		///         The <see cref="GetScrollPos" /> function retrieves the current position of the scroll box (thumb) in the specified scroll bar. The current
		///         position is a relative value that depends on the current scrolling range. For example, if the scrolling range is 0 through 100 and the scroll
		///         box is in the middle of the bar, the current position is 50.
		///     </para>
		///     <para>
		///         Note:   The <see cref="GetScrollPos" /> function is provided for backward compatibility. New applications should use the
		///         <see cref="GetScrollInfo" /> function.
		///     </para>
		/// </summary>
		/// <param name="hWnd">
		///     Handle to a scroll bar control or a window with a standard scroll bar, depending on the value of the <paramref name="nBar" /> parameter.
		/// </param>
		/// <param name="nBar">
		///     <para>Specifies the scroll bar to be examined. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>SB_CTL</term>
		///             <description>
		///                 Retrieves the position of the scroll box in a scroll bar control. The <paramref name="hWnd" /> parameter must be the handle to the
		///                 scroll bar control.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SB_HORZ</term>
		///             <description>Retrieves the position of the scroll box in a window's standard horizontal scroll bar.</description>
		///         </item>
		///         <item>
		///             <term>SB_VERT</term>
		///             <description>Retrieves the position of the scroll box in a window's standard vertical scroll bar.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the current position of the scroll box.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="GetScrollPos" /> function enables applications to use 32-bit scroll positions. Although the messages that indicate scroll bar
		///         position, <see cref="WM.WM_HSCROLL" /> and <see cref="WM.WM_VSCROLL" />, are limited to 16 bits of position data, the functions
		///         <see cref="SetScrollPos" />, <see cref="SetScrollRange" />, <see cref="GetScrollPos" />, and <see cref="GetScrollRange" /> support 32-bit
		///         scroll bar position data. Thus, an application can call <see cref="GetScrollPos" /> while processing either the <see cref="WM.WM_HSCROLL" />
		///         or
		///         <see cref="WM.WM_VSCROLL" /> messages to obtain 32-bit scroll bar position data.
		///     </para>
		///     <para>
		///         To get the 32-bit position of the scroll box (thumb) during a SB_THUMBTRACK request code in a <see cref="WM.WM_HSCROLL" /> or
		///         <see cref="WM.WM_VSCROLL" /> message, use the <see cref="GetScrollInfo" /> function.
		///     </para>
		///     <para>
		///         If the <paramref name="nBar" /> parameter is SB_CTL and the window specified by the <paramref name="hWnd" /> parameter is not a system scroll
		///         bar control, the system sends the <see cref="SBM_GETPOS" /> message to the window to obtain scroll bar information. This allows
		///         <see cref="GetScrollPos" /> to operate on a custom control that mimics a scroll bar. If the window does not handle the
		///         <see cref="SBM_GETPOS" /> message, the <see cref="GetScrollPos" /> function fails.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetScrollPos")]
		public static extern int GetScrollPos([In] IntPtr hWnd, int nBar);

		/// <summary>
		///     <para>
		///         Retrieves the menu flags associated with the specified menu item. If the menu item opens a submenu, this function also returns the number of
		///         items in the submenu.
		///     </para>
		///     <para>
		///         Note:  The <see cref="GetMenuState" /> function has been superseded by the <see cref="GetMenuItemInfo" />. You can still use
		///         <see cref="GetMenuState" />, however, if you do not need any of the extended features of <see cref="GetMenuItemInfo" />.
		///     </para>
		/// </summary>
		/// <param name="hMenu">A handle to the menu that contains the menu item whose flags are to be retrieved.</param>
		/// <param name="uId">
		///     The menu item for which the menu flags are to be retrieved, as determined by the <paramref name="uFlags" /> parameter.
		/// </param>
		/// <param name="uFlags">
		///     <para>
		///         Indicates how the <paramref name="uId" /> parameter is interpreted. This parameter can be one of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BYCOMMAND 0x00000000L</term>
		///             <description>
		///                 Indicates that the <paramref name="uId" /> parameter gives the identifier of the menu item. The <see cref="MF.MF_BYCOMMAND" /> flag is
		///                 the default if neither the <see cref="MF.MF_BYCOMMAND" /> nor <see cref="MF.MF_BYPOSITION" /> flag is specified.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_BYPOSITION 0x00000400L</term>
		///             <description>
		///                 Indicates that the <paramref name="uId" /> parameter gives the zero-based relative position of the menu item.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the specified item does not exist, the return value is -1.</para>
		///     <para>
		///         If the menu item opens a submenu, the low-order byte of the return value contains the menu flags associated with the item, and the high-order
		///         byte contains the number of items in the submenu opened by the item.
		///     </para>
		///     <para>Otherwise, the return value is a mask (Bitwise OR) of the menu flags. Following are the menu flags associated with the menu item.</para>
		/// </returns>
		/// <remarks>
		///     It is possible to test an item for a flag value of <see cref="MF.MF_ENABLED" />, <see cref="MF.MF_STRING" />, <see cref="MF.MF_UNCHECKED" />, or
		///     <see cref="MF.MF_UNHILITE" />. However, since these values equate to zero you must use an expression to test for them.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetMenuState")]
		public static extern uint GetMenuState([In] IntPtr hMenu, uint uId, MF uFlags);

		/// <summary>Retrieves the identifier of the specified control.</summary>
		/// <param name="hwndCtl">A handle to the control.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the identifier of the control.</para>
		///     <para>
		///         If the function fails, the return value is zero. An invalid value for the <paramref name="hwndCtl" /> parameter, for example, will cause the
		///         function to fail. To get extended error information, call GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         <see cref="GetDlgCtrlID" /> accepts child window handles as well as handles of controls in dialog boxes. An application sets the identifier
		///         for a child window when it creates the window by assigning the identifier value to the <paramref name="hmenu" /> parameter when calling the
		///         CreateWindow or <see cref="CreateWindowEx" /> function.
		///     </para>
		///     <para>
		///         Although <see cref="GetDlgCtrlID" /> may return a value if <paramref name="hwndCtl" /> is a handle to a top-level window, top-level windows
		///         cannot have identifiers and such a return value is never valid.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetDlgCtrlID")]
		public static extern int GetDlgCtrlID([In] IntPtr hWnd);

		/// <summary>Retrieves the position of the mouse cursor, in screen coordinates.</summary>
		/// <param name="lpPoint">
		///     A pointer to a <see cref="POINT" /> structure that receives the screen coordinates of the cursor.
		/// </param>
		/// <returns>Returns nonzero if successful or zero otherwise. To get extended error information, call GetLastError.</returns>
		/// <remarks>
		///     <para>
		///         The cursor position is always specified in screen coordinates and is not affected by the mapping mode of the window that contains the
		///         cursor.
		///     </para>
		///     <para>
		///         The calling process must have <see cref="WINSTA_READATTRIBUTES" /> access to the window station.
		///     </para>
		///     <para>
		///         The input desktop must be the current desktop when you call <see cref="GetCursorPos" />. Call <see cref="OpenInputDesktop" /> to determine
		///         whether the current desktop is the input desktop. If it is not, call <see cref="SetThreadDesktop" /> with the <see cref="HDESK" /> returned
		///         by <see cref="OpenInputDesktop" /> to switch to that desktop.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetCursorPos")]
		public static extern bool GetCursorPos([Out] out POINT lpPoint);

		/// <summary>
		///     <para>
		///         Retrieves the 16-bit (WORD) value at the specified offset into the extra class memory for the window class to which the
		///         specified window belongs.
		///     </para>
		///     <para>
		///         Note:  This function is deprecated for any use other than <paramref name="nIndex" /> set to GCW_ATOM. The
		///         function is provided only for compatibility with 16-bit versions of Windows. Applications should use the GetClassLongPtr or
		///         GetClassLongPtr function.
		///     </para>
		/// </summary>
		/// <param name="hWnd">A handle to the window and, indirectly, the class to which the window belongs.</param>
		/// <param name="nIndex">
		///     <para>
		///         The zero-based byte offset of the value to be retrieved. Valid values are in the range zero through the number of bytes of class memory,
		///         minus two; for example, if you specified 10 or more bytes of extra class memory, a value of eight would be an index to the fifth 16-bit
		///         integer. There is an additional valid value as shown in the following table.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>GCW_ATOM -32</term>
		///             <description>
		///                 Retrieves an ATOM value that uniquely identifies the window class. This is the same atom that the
		///                 <see cref="RegisterClass" /> or <see cref="RegisterClassEx" /> function returns.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the requested 16-bit value.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     Reserve extra class memory by specifying a nonzero value in the <see cref="WNDCLASS.cbClsExtra" /> member of the <see cref="WNDCLASS" /> structure used
		///     with the <see cref="RegisterClass" /> function.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetClassWord")]
		public static extern ushort GetClassWord([In] IntPtr hWnd, int nIndex);

		/// <summary>
		///     Enumerates all entries in the property list of a window by passing them, one by one, to the specified callback function.
		///     <see cref="EnumPropsEx" /> continues until the last entry is enumerated or the callback function returns FALSE.
		/// </summary>
		/// <param name="hWnd">A handle to the window whose property list is to be enumerated.</param>
		/// <param name="lpEnumFunc">
		///     A pointer to the callback function. For more information about the callback function, see the <see cref="PropEnumProcEx" /> function.
		/// </param>
		/// <param name="lParam">Application-defined data to be passed to the callback function.</param>
		/// <returns>
		///     <para>
		///         The return value specifies the last value returned by the callback function. It is -1 if the function did not find a property for
		///         enumeration.
		///     </para>
		/// </returns>
		/// <remarks>
		///     An application can remove only those properties it has added. It must not remove properties added by other applications or by the system
		///     itself.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "EnumPropsEx")]
		public static extern int EnumPropsEx([In] IntPtr hWnd, PropEnumProcEx lpEnumFunc, [MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>
		///     Enables or disables mouse and keyboard input to the specified window or control. When input is disabled, the window does not receive input such
		///     as mouse clicks and key presses. When input is enabled, the window receives all input.
		/// </summary>
		/// <param name="hWnd">A handle to the window to be enabled or disabled.</param>
		/// <param name="bEnable">
		///     Indicates whether to enable or disable the window. If this parameter is TRUE, the window is enabled. If the parameter is FALSE, the window is
		///     disabled.
		/// </param>
		/// <returns>
		///     <para>If the window was previously disabled, the return value is nonzero.</para>
		///     <para>If the window was not previously disabled, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If the window is being disabled, the system sends a <see cref="WM.WM_CANCELMODE" /> message. If the enabled state of a window is changing,
		///         the system sends a <see cref="WM.WM_ENABLE" /> message after the <see cref="WM.WM_CANCELMODE" /> message. (These messages are sent before
		///         <see cref="EnableWindow" /> returns.) If a window is already disabled, its child windows are implicitly disabled, although they are not sent
		///         a <see cref="WM.WM_ENABLE" /> message.
		///     </para>
		///     <para>
		///         A window must be enabled before it can be activated. For example, if an application is displaying a modeless dialog box and has disabled its
		///         main window, the application must enable the main window before destroying the dialog box. Otherwise, another window will receive the
		///         keyboard focus and be activated. If a child window is disabled, it is ignored when the system tries to determine which window should receive
		///         mouse messages.
		///     </para>
		///     <para>
		///         By default, a window is enabled when it is created. To create a window that is initially disabled, an application can specify the
		///         <see cref="WS.WS_DISABLED" /> style in the CreateWindow or <see cref="CreateWindowEx" /> function. After a window has been
		///         created, an application can use <see cref="EnableWindow" /> to enable or disable the window.
		///     </para>
		///     <para>
		///         An application can use this function to enable or disable a control in a dialog box. A disabled control cannot receive the keyboard focus,
		///         nor can a user gain access to it.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "EnableWindow")]
		public static extern bool EnableWindow([In] IntPtr hWnd, [MarshalAs(UnmanagedType.Bool)] bool bEnable);

		/// <summary>Destroys the caret's current shape, frees the caret from the window, and removes the caret from the screen.</summary>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         <see cref="DestroyCaret" /> destroys the caret only if a window in the current task owns the caret. If a window that is not in the current
		///         task owns the caret, <see cref="DestroyCaret" /> does nothing and returns FALSE.
		///     </para>
		///     <para>
		///         The system provides one caret per queue. A window should create a caret only when it has the keyboard focus or is active. The window should
		///         destroy the caret before losing the keyboard focus or becoming inactive.
		///     </para>
		///     <para>For an example, see Destroying a Caret</para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DestroyCaret")]
		public static extern bool DestroyCaret();

		/// <summary>
		///     Enables a client Dynamic Data Exchange Management Library (DDEML) application to attempt to reestablish a conversation with a service that has terminated a conversation with the client. When the conversation is reestablished, the Dynamic Data Exchange Management Library (DDEML) attempts to reestablish any preexisting advise loops.
		/// </summary>
		/// <param name="hConv">
		///     A handle to the conversation to be reestablished. A client must have obtained the conversation handle by a previous call to the <see cref="DdeConnect"/> function or from an XTYP_DISCONNECT transaction.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the handle to the established conversation.</para>
		///     <para>If the function fails, the return value is 0L.</para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "DdeReconnect")]
		public static extern IntPtr DdeReconnect(IntPtr hConv);

		/// <summary>Creates a cursor having the specified size, bit patterns, and hot spot.</summary>
		/// <param name="hInst">A handle to the current instance of the application creating the cursor.</param>
		/// <param name="xHotSpot">The horizontal position of the cursor's hot spot.</param>
		/// <param name="yHotSpot">The vertical position of the cursor's hot spot.</param>
		/// <param name="nWidth">The width of the cursor, in pixels.</param>
		/// <param name="nHeight">The height of the cursor, in pixels.</param>
		/// <param name="pvANDPlane">An array of bytes that contains the bit values for the AND mask of the cursor, as in a device-dependent monochrome bitmap.</param>
		/// <param name="pvXORPlane">An array of bytes that contains the bit values for the XOR mask of the cursor, as in a device-dependent monochrome bitmap.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to the cursor.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <paramref name="nWidth" /> and <paramref name="nHeight" /> parameters must specify a width and height that are supported by the current
		///         display driver, because the system cannot create cursors of other sizes. To determine the width and height supported by the display driver,
		///         use the <see cref="GetSystemMetrics" /> function, specifying the <see cref="SM.SM_CXCURSOR" /> or <see cref="SM.SM_CYCURSOR" /> value.
		///     </para>
		///     <para>
		///         Before closing, an application must call the <see cref="DestroyCursor" /> function to free any system resources associated with the cursor.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CreateCursor")]
		public static extern IntPtr CreateCursor(
			[In] IntPtr hInst, int xHotSpot, int yHotSpot, int nWidth, int nHeight, [In] ref byte[] pvANDPlane, [In] ref byte[] pvXORPlane);

		/// <summary>Closes an open handle to a desktop object.</summary>
		/// <param name="hDesktop">
		///     A handle to the desktop to be closed. This can be a handle returned by the <see cref="CreateDesktop" />, <see cref="OpenDesktop" />, or
		///     <see cref="OpenInputDesktop" /> functions. Do not specify the handle returned by the <see cref="GetThreadDesktop" /> function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     The <see cref="CloseDesktop" /> function will fail if any thread in the calling process is using the specified desktop handle or if the handle
		///     refers to the initial desktop of the calling process.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "CloseDesktop")]
		public static extern bool CloseDesktop([In] IntPtr hDesktop);

		/// <summary>
		///     Yields control to other threads when a thread has no other messages in its message queue. The <see cref="WaitMessage" /> function suspends the
		///     thread and does not return until a new message is placed in the thread's message queue.
		/// </summary>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     Note that <see cref="WaitMessage" /> does not return if there is unread input in the message queue after the thread has called a function to
		///     check the queue. This is because functions such as <see cref="PeekMessage" />, <see cref="GetMessage" />, <see cref="GetQueueStatus" />,
		///     <see cref="WaitMessage" />, <see cref="MsgWaitForMultipleObjects" />, and <see cref="MsgWaitForMultipleObjectsEx" /> check the queue and then
		///     change the state information for the queue so that the input is no longer considered new. A subsequent call to <see cref="WaitMessage" /> will
		///     not return until new input of the specified type arrives. The existing unread input (received prior to the last time the thread checked the
		///     queue) is ignored.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "WaitMessage")]
		public static extern bool WaitMessage();

		/// <summary>
		///     The <see cref="ValidateRgn" /> function validates the client area within a region by removing the region from the current update region of the
		///     specified window.
		/// </summary>
		/// <param name="hWnd">Handle to the window whose update region is to be modified.</param>
		/// <param name="hRgn">
		///     Handle to a region that defines the area to be removed from the update region. If this parameter is NULL, the entire client area
		///     is removed.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>The specified region must have been created by a region function. The region coordinates are assumed to be client coordinates.</para>
		///     <para>
		///         The <see cref="BeginPaint" /> function automatically validates the entire client area. Neither the <see cref="ValidateRect" /> nor
		///         <see cref="ValidateRgn" /> function should be called if a portion of the update region must be validated before the next
		///         <see cref="WM.WM_PAINT" /> message is generated.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "ValidateRgn")]
		public static extern bool ValidateRgn([In] IntPtr hWnd, [In] IntPtr hRgn);

		/// <summary>Translates the specified virtual-key code and keyboard state to the corresponding Unicode character or characters.</summary>
		/// <param name="wVirtKey">The virtual-key code to be translated. See Virtual-Key Codes.</param>
		/// <param name="wScanCode">The hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up.</param>
		/// <param name="lpKeyState">
		///     A pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of one key. If the
		///     high-order bit of a byte is set, the key is down.
		/// </param>
		/// <param name="pwszBuff">
		///     The buffer that receives the translated Unicode character or characters. However, this buffer may be returned without being null-terminated even
		///     though the variable name suggests that it is null-terminated.
		/// </param>
		/// <param name="cchBuff">
		///     The size, in characters, of the buffer pointed to by the <paramref name="pwszBuff" /> parameter.
		/// </param>
		/// <param name="wFlags">The behavior of the function. If bit 0 is set, a menu is active. Bits 1 through 31 are reserved.</param>
		/// <param name="dwhkl">
		///     The input locale identifier used to translate the specified code. This parameter can be any input locale identifier previously returned by the
		///     <see cref="LoadKeyboardLayout" /> function.
		/// </param>
		/// <returns>The function returns one of the following values.</returns>
		/// <remarks>
		///     <para>
		///         The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input
		///         Method Editor (IME), or any other form of input.
		///     </para>
		///     <para>
		///         The parameters supplied to the <see cref="ToUnicodeEx" /> function might not be sufficient to translate the virtual-key code because a
		///         previous dead key is stored in the keyboard layout.
		///     </para>
		///     <para>
		///         Typically, <see cref="ToUnicodeEx" /> performs the translation based on the virtual-key code. In some cases, however, bit 15 of the
		///         <paramref name="wScanCode" /> parameter can be used to distinguish between a key press and a key release.
		///     </para>
		///     <para>
		///         As <see cref="ToUnicodeEx" /> translates the virtual-key code, it also changes the state of the kernel-mode keyboard buffer. This
		///         state-change affects dead keys, ligatures, alt+numpad key entry, and so on. It might also cause undesired side-effects if used in conjunction
		///         with <see cref="TranslateMessage" /> (which also changes the state of the kernel-mode keyboard buffer).
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "ToUnicodeEx")]
		public static extern int ToUnicodeEx(
			uint wVirtKey, uint wScanCode, [In] IntPtr lpKeyState, [Out] [MarshalAs(UnmanagedType.LPWStr)] StringBuilder pwszBuff, int cchBuff, TU wFlags,
			[In] IntPtr dwhkl);

		/// <summary>Tiles the specified child windows of the specified parent window.</summary>
		/// <param name="hwndParent">A handle to the parent window. If this parameter is NULL, the desktop window is assumed.</param>
		/// <param name="wHow">
		///     <para>
		///         The tiling flags. This parameter can be one of the following values—optionally combined with <see cref="MDITILE.MDITILE_SKIPDISABLED" /> to prevent
		///         disabled MDI child windows from being tiled.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MDITILE_HORIZONTAL 0x0001</term>
		///             <description>Tiles windows horizontally.</description>
		///         </item>
		///         <item>
		///             <term>MDITILE_VERTICAL 0x0000</term>
		///             <description>Tiles windows vertically.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="lpRect">
		///     A pointer to a structure that specifies the rectangular area, in client coordinates, within which the windows are arranged. If this parameter is
		///     NULL, the client area of the parent window is used.
		/// </param>
		/// <param name="cKids">
		///     The number of elements in the array specified by the <paramref name="lpKids" /> parameter. This parameter is ignored if
		///     <paramref name="lpKids" /> is NULL.
		/// </param>
		/// <param name="lpKids">
		///     An array of handles to the child windows to arrange. If a specified child window is a top-level window with the style
		///     <see cref="WS_EX.WS_EX_TOPMOST" /> or <see cref="WS_EX.WS_EX_TOOLWINDOW" />, the child window is not arranged. If this parameter is NULL, all child windows
		///     of the specified parent window (or of the desktop window) are arranged.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the number of windows arranged.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     Calling <see cref="TileWindows" /> causes all maximized windows to be restored to their previous size.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "TileWindows")]
		public static extern ushort TileWindows([In] IntPtr hwndParent, MDITILE wHow, [In] ref RECT lpRect, uint cKids, ref IntPtr lpKids);

		/// <summary>Sets information for a specified menu.</summary>
		/// <param name="hmenu">A handle to a menu.</param>
		/// <param name="lpcmi">
		///     A pointer to a <see cref="MENUINFO" /> structure for the menu.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetMenuInfo")]
		public static extern bool SetMenuInfo([In] IntPtr hmenu, [In] ref MENUINFO lpcmi);

		/// <summary>
		///     Moves the caret to the specified coordinates. If the window that owns the caret was created with the <see cref="CS.CS_OWNDC" /> class style, then
		///     the specified coordinates are subject to the mapping mode of the device context associated with that window.
		/// </summary>
		/// <param name="X">The new x-coordinate of the caret.</param>
		/// <param name="Y">The new y-coordinate of the caret.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         <see cref="SetCaretPos" /> moves the caret whether the caret is hidden.
		///     </para>
		///     <para>
		///         The system provides one caret per queue. A window should create a caret only when it has the keyboard focus or is active. The window should
		///         destroy the caret before losing the keyboard focus or becoming inactive. A window can set the caret position only if it owns the caret.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetCaretPos")]
		public static extern bool SetCaretPos(int X, int Y);

		/// <summary>Removes an entry from the property list of the specified window. The specified character string identifies the entry to be removed.</summary>
		/// <param name="hWnd">A handle to the window whose property list is to be changed.</param>
		/// <param name="lpString">
		///     A null-terminated character string or an atom that identifies a string. If this parameter is an atom, it must have been created using the
		///     GlobalAddAtom function. The atom, a 16-bit value, must be placed in the low-order word of <paramref name="lpString" />; the
		///     high-order word must be zero.
		/// </param>
		/// <returns>
		///     <para>The return value identifies the specified data. If the data cannot be found in the specified property list, the return value is NULL.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The return value is the hData value that was passed to <see cref="SetProp" />; it is an application-defined value. Note,
		///         this function only destroys the association between the data and the window. If appropriate, the application must free the data handles
		///         associated with entries removed from a property list. The application can remove only those properties it has added. It must not remove
		///         properties added by other applications or by the system itself.
		///     </para>
		///     <para>
		///         The <see cref="RemoveProp" /> function returns the data handle associated with the string so that the application can free the data
		///         associated with the handle.
		///     </para>
		///     <para>
		///         Starting with Windows Vista, <see cref="RemoveProp" /> is subject to the restrictions of User Interface Privilege Isolation (UIPI). A process
		///         can only call this function on a window belonging to a process of lesser or equal integrity level. When UIPI blocks property changes,
		///         GetLastError will return 5.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "RemoveProp")]
		public static extern IntPtr RemoveProp([In] IntPtr hWnd, [In] string lpString);

		/// <summary>
		///     The <see cref="PrintWindow" /> function copies a visual window into the specified device context (DC), typically a printer DC.
		/// </summary>
		/// <param name="hwnd">A handle to the window that will be copied.</param>
		/// <param name="hdcBlt">A handle to the device context.</param>
		/// <param name="nFlags">
		///     <para>The drawing options. It can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>PW_CLIENTONLY</term>
		///             <description>
		///                 Only the client area of the window is copied to <paramref name="hdcBlt" />. By default, the entire window is copied.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, it returns a nonzero value.</para>
		///     <para>If the function fails, it returns zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Note:  This is a blocking or synchronous function and might not return immediately. How quickly this function returns depends
		///         on run-time factors such as network status, print server configuration, and printer driver implementation—factors that are difficult to
		///         predict when writing an application. Calling this function from a thread that manages interaction with the user interface could make the
		///         application appear to be unresponsive.
		///     </para>
		///     <para>
		///         The application that owns the window referenced by hWnd processes the <see cref="PrintWindow" /> call and renders the image in the device
		///         context that is referenced by <paramref name="hdcBlt" />. The application receives a <see cref="WM.WM_PRINT" /> message or, if the
		///         <see cref="PW_PRINTCLIENT" /> flag is specified, a <see cref="WM.WM_PRINTCLIENT" /> message. For more information, see
		///         <see cref="WM.WM_PRINT" />
		///         and <see cref="WM.WM_PRINTCLIENT" />.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "PrintWindow")]
		public static extern bool PrintWindow([In] IntPtr hwnd, [In] IntPtr hdcBlt, PW nFlags);

		/// <summary>
		///     <para>
		///         The <see cref="mouse_event" /> function synthesizes mouse motion and button clicks.
		///     </para>
		///     <para>
		///         Note:  This function has been superseded. Use <see cref="SendInput" /> instead.
		///     </para>
		/// </summary>
		/// <param name="dwFlags">
		///     <para>Controls various aspects of mouse motion and button clicking. This parameter can be certain combinations of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MOUSEEVENTF_ABSOLUTE 0x8000</term>
		///             <description>
		///                 The <paramref name="dx" /> and <paramref name="dy" /> parameters contain normalized absolute coordinates. If not set, those
		///                 parameters contain relative data: the change in position since the last reported position. This flag can be set, or not set,
		///                 regardless of what kind of mouse or mouse-like device, if any, is connected to the system. For further information about relative
		///                 mouse motion, see the following Remarks section.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MOUSEEVENTF_LEFTDOWN 0x0002</term>
		///             <description>The left button is down.</description>
		///         </item>
		///         <item>
		///             <term>MOUSEEVENTF_LEFTUP 0x0004</term>
		///             <description>The left button is up.</description>
		///         </item>
		///         <item>
		///             <term>MOUSEEVENTF_MIDDLEDOWN 0x0020</term>
		///             <description>The middle button is down.</description>
		///         </item>
		///         <item>
		///             <term>MOUSEEVENTF_MIDDLEUP 0x0040</term>
		///             <description>The middle button is up.</description>
		///         </item>
		///         <item>
		///             <term>MOUSEEVENTF_MOVE 0x0001</term>
		///             <description>Movement occurred.</description>
		///         </item>
		///         <item>
		///             <term>MOUSEEVENTF_RIGHTDOWN 0x0008</term>
		///             <description>The right button is down.</description>
		///         </item>
		///         <item>
		///             <term>MOUSEEVENTF_RIGHTUP 0x0010</term>
		///             <description>The right button is up.</description>
		///         </item>
		///         <item>
		///             <term>MOUSEEVENTF_WHEEL 0x0800</term>
		///             <description>
		///                 The wheel has been moved, if the mouse has a wheel. The amount of movement is specified in <paramref name="dwData" />
		///             </description>
		///         </item>
		///         <item>
		///             <term>MOUSEEVENTF_XDOWN 0x0080</term>
		///             <description>An X button was pressed.</description>
		///         </item>
		///         <item>
		///             <term>MOUSEEVENTF_XUP 0x0100</term>
		///             <description>An X button was released.</description>
		///         </item>
		///         <item>
		///             <term>MOUSEEVENTF_WHEEL 0x0800</term>
		///             <description>The wheel button is rotated.</description>
		///         </item>
		///         <item>
		///             <term>MOUSEEVENTF_HWHEEL 0x01000</term>
		///             <description>The wheel button is tilted.</description>
		///         </item>
		///     </list>
		///     <para>
		///         The values that specify mouse button status are set to indicate changes in status, not ongoing conditions. For example, if the left mouse
		///         button is pressed and held down, <see cref="MOUSEEVENTF_LEFTDOWN" /> is set when the left button is first pressed, but not for subsequent
		///         motions. Similarly, <see cref="MOUSEEVENTF_LEFTUP" /> is set only when the button is first released.
		///     </para>
		///     <para>
		///         You cannot specify both <see cref="MOUSEEVENTF_WHEEL" /> and either <see cref="MOUSEEVENTF_XDOWN" /> or <see cref="MOUSEEVENTF_XUP" />
		///         simultaneously in the <paramref name="dwFlags" /> parameter, because they both require use of the <paramref name="dwData" /> field.
		///     </para>
		/// </param>
		/// <param name="dx">
		///     The mouse's absolute position along the x-axis or its amount of motion since the last mouse event was generated, depending on the setting of
		///     <see cref="MOUSEEVENTF_ABSOLUTE" />. Absolute data is specified as the mouse's actual x-coordinate; relative data is specified as the number of
		///     mickeys moved. A <paramref name="mickey" /> is the amount that a mouse has to move for it to report that it has moved.
		/// </param>
		/// <param name="dy">
		///     The mouse's absolute position along the y-axis or its amount of motion since the last mouse event was generated, depending on the setting of
		///     <see cref="MOUSEEVENTF_ABSOLUTE" />. Absolute data is specified as the mouse's actual y-coordinate; relative data is specified as the number of
		///     mickeys moved.
		/// </param>
		/// <param name="dwData">
		///     <para>
		///         If <paramref name="dwFlags" /> contains <see cref="MOUSEEVENTF_WHEEL" />, then <paramref name="dwData" /> specifies the amount of wheel
		///         movement. A positive value indicates that the wheel was rotated forward, away from the user; a negative value indicates that the wheel was
		///         rotated backward, toward the user. One wheel click is defined as <see cref="WHEEL_DELTA" />, which is 120.
		///     </para>
		///     <para>
		///         If <paramref name="dwFlags" /> contains <see cref="MOUSEEVENTF_HWHEEL" />, then <paramref name="dwData" /> specifies the amount of wheel
		///         movement. A positive value indicates that the wheel was tilted to the right; a negative value indicates that the wheel was tilted to the
		///         left.
		///     </para>
		///     <para>
		///         If <paramref name="dwFlags" /> contains <see cref="MOUSEEVENTF_XDOWN" /> or <see cref="MOUSEEVENTF_XUP" />, then <paramref name="dwData" />
		///         specifies which X buttons were pressed or released. This value may be any combination of the following flags.
		///     </para>
		///     <para>
		///         If <paramref name="dwFlags" /> is not <see cref="MOUSEEVENTF_WHEEL" />, <see cref="MOUSEEVENTF_XDOWN" />, or <see cref="MOUSEEVENTF_XUP" />,
		///         then <paramref name="dwData" /> should be zero.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>XBUTTON1 0x0001</term>
		///             <description>Set if the first X button was pressed or released.</description>
		///         </item>
		///         <item>
		///             <term>XBUTTON2 0x0002</term>
		///             <description>Set if the second X button was pressed or released.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="dwExtraInfo">
		///     An additional value associated with the mouse event. An application calls <see cref="GetMessageExtraInfo" /> to obtain this extra information.
		/// </param>
		/// <returns>This function has no return value.</returns>
		/// <remarks>
		///     <para>
		///         If the mouse has moved, indicated by <see cref="MOUSEEVENTF_MOVE" /> being set, <paramref name="dx" /> and <paramref name="dy" /> hold
		///         information about that motion. The information is specified as absolute or relative integer values.
		///     </para>
		///     <para>
		///         If <see cref="MOUSEEVENTF_ABSOLUTE" /> value is specified, <paramref name="dx" /> and <paramref name="dy" /> contain normalized absolute
		///         coordinates between 0 and 65,535. The event procedure maps these coordinates onto the display surface. Coordinate (0,0) maps onto the
		///         upper-left corner of the display surface, (65535,65535) maps onto the lower-right corner.
		///     </para>
		///     <para>
		///         If the <see cref="MOUSEEVENTF_ABSOLUTE" /> value is not specified, <paramref name="dx" /> and <paramref name="dy" /> specify relative motions
		///         from when the last mouse event was generated (the last reported position). Positive values mean the mouse moved right (or down); negative
		///         values mean the mouse moved left (or up).
		///     </para>
		///     <para>
		///         Relative mouse motion is subject to the settings for mouse speed and acceleration level. An end user sets these values using the Mouse
		///         application in Control Panel. An application obtains and sets these values with the <see cref="SystemParametersInfo" /> function.
		///     </para>
		///     <para>
		///         The system applies two tests to the specified relative mouse motion when applying acceleration. If the specified distance along either the x
		///         or y axis is greater than the first mouse threshold value, and the mouse acceleration level is not zero, the operating system doubles the
		///         distance. If the specified distance along either the x- or y-axis is greater than the second mouse threshold value, and the mouse
		///         acceleration level is equal to two, the operating system doubles the distance that resulted from applying the first threshold test. It is
		///         thus possible for the operating system to multiply relatively-specified mouse motion along the x- or y-axis by up to four times.
		///     </para>
		///     <para>
		///         Once acceleration has been applied, the system scales the resultant value by the desired mouse speed. Mouse speed can range from 1 (slowest)
		///         to 20 (fastest) and represents how much the pointer moves based on the distance the mouse moves. The default value is 10, which results in no
		///         additional modification to the mouse motion.
		///     </para>
		///     <para>
		///         The <see cref="mouse_event" /> function is used to synthesize mouse events by applications that need to do so. It is also used by
		///         applications that need to obtain more information from the mouse than its position and button state. For example, if a tablet manufacturer
		///         wants to pass pen-based information to its own applications, it can write a DLL that communicates directly to the tablet hardware, obtains
		///         the extra information, and saves it in a queue. The DLL then calls <see cref="mouse_event" /> with the standard button and x/y position data,
		///         along with, in the <paramref name="dwExtraInfo" /> parameter, some pointer or index to the queued extra information. When the application
		///         needs the extra information, it calls the DLL with the pointer or index stored in <paramref name="dwExtraInfo" />, and the DLL returns the
		///         extra information.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "mouse_event")]
		public static extern void mouse_event(MOUSEEVENTF dwFlags, uint dx, uint dy, uint dwData, uint dwExtraInfo);

		/// <summary>
		///     <para>Changes an existing menu item. This function is used to specify the content, appearance, and behavior of the menu item.</para>
		///     <para>
		///         Note:  The <see cref="ModifyMenu" /> function has been superseded by the <see cref="SetMenuItemInfo" /> function. You can still
		///         use <see cref="ModifyMenu" />, however, if you do not need any of the extended features of <see cref="SetMenuItemInfo" />.
		///     </para>
		/// </summary>
		/// <param name="hMnu">A handle to the menu to be changed.</param>
		/// <param name="uPosition">
		///     The menu item to be changed, as determined by the <paramref name="uFlags" /> parameter.
		/// </param>
		/// <param name="uFlags">
		///     <para>
		///         Controls the interpretation of the <paramref name="uPosition" /> parameter and the content, appearance, and behavior of the menu item. This
		///         parameter must include one of the following required values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BYCOMMAND 0x00000000L</term>
		///             <description>
		///                 Indicates that the <paramref name="uPosition" /> parameter gives the identifier of the menu item. The <see cref="MF.MF_BYCOMMAND" />
		///                 flag is the default if neither the <see cref="MF.MF_BYCOMMAND" /> nor <see cref="MF.MF_BYPOSITION" /> flag is specified.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_BYPOSITION 0x00000400L</term>
		///             <description>
		///                 Indicates that the <paramref name="uPosition" /> parameter gives the zero-based relative position of the menu item.
		///             </description>
		///         </item>
		///     </list>
		///     <para>The parameter must also include at least one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BITMAP 0x00000004L</term>
		///             <description>
		///                 Uses a bitmap as the menu item. The <paramref name="lpNewItem" /> parameter contains a handle to the bitmap.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_CHECKED 0x00000008L</term>
		///             <description>
		///                 Places a check mark next to the item. If your application provides check-mark bitmaps (see the <see cref="SetMenuItemBitmaps" />
		///                 function), this flag displays a selected bitmap next to the menu item.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_DISABLED 0x00000002L</term>
		///             <description>Disables the menu item so that it cannot be selected, but this flag does not gray it.</description>
		///         </item>
		///         <item>
		///             <term>MF_ENABLED 0x00000000L</term>
		///             <description>Enables the menu item so that it can be selected and restores it from its grayed state.</description>
		///         </item>
		///         <item>
		///             <term>MF_GRAYED 0x00000001L</term>
		///             <description>Disables the menu item and grays it so that it cannot be selected.</description>
		///         </item>
		///         <item>
		///             <term>MF_MENUBARBREAK 0x00000020L</term>
		///             <description>
		///                 Functions the same as the <see cref="MF.MF_MENUBREAK" /> flag for a menu bar. For a drop-down menu, submenu, or shortcut menu, the new
		///                 column is separated from the old column by a vertical line.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_MENUBREAK 0x00000040L</term>
		///             <description>
		///                 Places the item on a new line (for menu bars) or in a new column (for a drop-down menu, submenu, or shortcut menu) without
		///                 separating columns.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_OWNERDRAW 0x00000100L</term>
		///             <description>
		///                 Specifies that the item is an owner-drawn item. Before the menu is displayed for the first time, the window that owns the menu
		///                 receives a <see cref="WM.WM_MEASUREITEM" /> message to retrieve the width and height of the menu item. The
		///                 <see cref="WM.WM_DRAWITEM" />
		///                 message is then sent to the window procedure of the owner window whenever the appearance of the menu item must be updated.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_POPUP 0x00000010L</term>
		///             <description>
		///                 Specifies that the menu item opens a drop-down menu or submenu. The <paramref name="uIDNewItem" /> parameter specifies a handle to
		///                 the drop-down menu or submenu. This flag is used to add a menu name to a menu bar or a menu item that opens a submenu to a drop-down
		///                 menu, submenu, or shortcut menu.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_SEPARATOR 0x00000800L</term>
		///             <description>
		///                 Draws a horizontal dividing line. This flag is used only in a drop-down menu, submenu, or shortcut menu. The line cannot be grayed,
		///                 disabled, or highlighted. The <paramref name="lpNewItem" /> and <paramref name="uIDNewItem" /> parameters are ignored.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_STRING 0x00000000L</term>
		///             <description>
		///                 Specifies that the menu item is a text string; the <paramref name="lpNewItem" /> parameter is a pointer to the string.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_UNCHECKED 0x00000000L</term>
		///             <description>
		///                 Does not place a check mark next to the item (the default). If your application supplies check-mark bitmaps (see the
		///                 <see cref="SetMenuItemBitmaps" /> function), this flag displays a clear bitmap next to the menu item.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="uIDNewItem">
		///     The identifier of the modified menu item or, if the <paramref name="uFlags" /> parameter has the <see cref="MF.MF_POPUP" /> flag set, a handle to
		///     the drop-down menu or submenu.
		/// </param>
		/// <param name="lpNewItem">
		///     <para>
		///         The contents of the changed menu item. The interpretation of this parameter depends on whether the <paramref name="uFlags" /> parameter
		///         includes the <see cref="MF.MF_BITMAP" />, <see cref="MF.MF_OWNERDRAW" />, or <see cref="MF.MF_STRING" /> flag.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BITMAP 0x00000004L</term>
		///             <description>A bitmap handle.</description>
		///         </item>
		///         <item>
		///             <term>MF_OWNERDRAW 0x00000100L</term>
		///             <description>
		///                 A value supplied by an application that is used to maintain additional data related to the menu item. The value is in the
		///                 <see cref="itemData" /> member of the structure pointed to by the <paramref name="lParam" /> parameter of the
		///                 <see cref="WM.WM_MEASUREITEM" /> or <see cref="WM.WM_DRAWITEM" /> messages sent when the menu item is created or its appearance is
		///                 updated.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_STRING 0x00000000L</term>
		///             <description>A pointer to a null-terminated string (the default).</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If <see cref="ModifyMenu" /> replaces a menu item that opens a drop-down menu or submenu, the function destroys the old drop-down menu or
		///         submenu and frees the memory used by it.
		///     </para>
		///     <para>
		///         In order for keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the
		///         <see cref="WM.WM_MENUCHAR" /> message. See Owner-Drawn Menus and the WM_MENUCHAR Message for more information.
		///     </para>
		///     <para>
		///         The application must call the <see cref="DrawMenuBar" /> function whenever a menu changes, whether the menu is in a displayed window. To
		///         change the attributes of existing menu items, it is much faster to use the <see cref="CheckMenuItem" /> and <see cref="EnableMenuItem" />
		///         functions.
		///     </para>
		///     <para>The following groups of flags cannot be used together:</para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "ModifyMenu")]
		public static extern bool ModifyMenu([In] IntPtr hMnu, uint uPosition, MF uFlags, [MarshalAs(UnmanagedType.SysUInt)] uint uIDNewItem, [In] string lpNewItem);

		/// <summary>
		///     Displays a modal dialog box that contains a system icon, a set of buttons, and a brief application-specific message, such as status or error
		///     information. The message box returns an integer value that indicates which button the user clicked.
		/// </summary>
		/// <param name="hWnd">A handle to the owner window of the message box to be created. If this parameter is NULL, the message box has no owner window.</param>
		/// <param name="lpText">
		///     The message to be displayed. If the string consists of more than one line, you can separate the lines using a carriage return and/or linefeed
		///     character between each line.
		/// </param>
		/// <param name="lpCaption">
		///     The dialog box title. If this parameter is NULL, the default title is <see cref="Error" />.
		/// </param>
		/// <param name="uType">
		///     <para>The contents and behavior of the dialog box. This parameter can be a combination of flags from the following groups of flags.</para>
		///     <para>To indicate the buttons displayed in the message box, specify one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MB_ABORTRETRYIGNORE 0x00000002L</term>
		///             <description>
		///                 The message box contains three push buttons: <see cref="Abort" />, <see cref="Retry" />, and <see cref="Ignore" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_CANCELTRYCONTINUE 0x00000006L</term>
		///             <description>
		///                 The message box contains three push buttons: <see cref="Cancel" />, Try Again, <see cref="Continue" />. Use this message box type
		///                 instead of MB_ABORTRETRYIGNORE.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_HELP 0x00004000L</term>
		///             <description>
		///                 Adds a <see cref="Help" /> button to the message box. When the user clicks the <see cref="Help" /> button or presses F1, the system
		///                 sends a <see cref="WM.WM_HELP" /> message to the owner.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_OK 0x00000000L</term>
		///             <description>
		///                 The message box contains one push button: OK. This is the default.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_OKCANCEL 0x00000001L</term>
		///             <description>
		///                 The message box contains two push buttons: OK and <see cref="Cancel" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_RETRYCANCEL 0x00000005L</term>
		///             <description>
		///                 The message box contains two push buttons: <see cref="Retry" /> and <see cref="Cancel" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_YESNO 0x00000004L</term>
		///             <description>
		///                 The message box contains two push buttons: <see cref="Yes" /> and <see cref="No" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_YESNOCANCEL 0x00000003L</term>
		///             <description>
		///                 The message box contains three push buttons: <see cref="Yes" />, <see cref="No" />, and <see cref="Cancel" />.
		///             </description>
		///         </item>
		///     </list>
		///     <para>To display an icon in the message box, specify one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MB_ICONEXCLAMATION 0x00000030L</term>
		///             <description>An exclamation-point icon appears in the message box.</description>
		///         </item>
		///         <item>
		///             <term>MB_ICONWARNING 0x00000030L</term>
		///             <description>An exclamation-point icon appears in the message box.</description>
		///         </item>
		///         <item>
		///             <term>MB_ICONINFORMATION 0x00000040L</term>
		///             <description>
		///                 An icon consisting of a lowercase letter <paramref name="i" /> in a circle appears in the message box.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_ICONASTERISK 0x00000040L</term>
		///             <description>
		///                 An icon consisting of a lowercase letter <paramref name="i" /> in a circle appears in the message box.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_ICONQUESTION 0x00000020L</term>
		///             <description>
		///                 A question-mark icon appears in the message box. The question-mark message icon is no longer recommended because it does not clearly
		///                 represent a specific type of message and because the phrasing of a message as a question could apply to any message type. In
		///                 addition, users can confuse the message symbol question mark with Help information. Therefore, do not use this question mark message
		///                 symbol in your message boxes. The system continues to support its inclusion only for backward compatibility.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_ICONSTOP 0x00000010L</term>
		///             <description>A stop-sign icon appears in the message box.</description>
		///         </item>
		///         <item>
		///             <term>MB_ICONERROR 0x00000010L</term>
		///             <description>A stop-sign icon appears in the message box.</description>
		///         </item>
		///         <item>
		///             <term>MB_ICONHAND 0x00000010L</term>
		///             <description>A stop-sign icon appears in the message box.</description>
		///         </item>
		///     </list>
		///     <para>To indicate the default button, specify one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MB_DEFBUTTON1 0x00000000L</term>
		///             <description>
		///                 <para>The first button is the default button.</para>
		///                 <para>
		///                     <see cref="MB.MB_DEFBUTTON1" /> is the default unless <see cref="MB.MB_DEFBUTTON2" />, <see cref="MB.MB_DEFBUTTON3" />, or
		///                     <see cref="MB.MB_DEFBUTTON4" /> is specified.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_DEFBUTTON2 0x00000100L</term>
		///             <description>The second button is the default button.</description>
		///         </item>
		///         <item>
		///             <term>MB_DEFBUTTON3 0x00000200L</term>
		///             <description>The third button is the default button.</description>
		///         </item>
		///         <item>
		///             <term>MB_DEFBUTTON4 0x00000300L</term>
		///             <description>The fourth button is the default button.</description>
		///         </item>
		///     </list>
		///     <para>To indicate the modality of the dialog box, specify one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MB_APPLMODAL 0x00000000L</term>
		///             <description>
		///                 <para>
		///                     The user must respond to the message box before continuing work in the window identified by the <paramref name="hWnd" />
		///                     parameter. However, the user can move to the windows of other threads and work in those windows.
		///                 </para>
		///                 <para>
		///                     Depending on the hierarchy of windows in the application, the user may be able to move to other windows within the thread. All
		///                     child windows of the parent of the message box are automatically disabled, but pop-up windows are not.
		///                 </para>
		///                 <para>
		///                     <see cref="MB.MB_APPLMODAL" /> is the default if neither <see cref="MB.MB_SYSTEMMODAL" /> nor <see cref="MB.MB_TASKMODAL" /> is specified.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_SYSTEMMODAL 0x00001000L</term>
		///             <description>
		///                 Same as MB_APPLMODAL except that the message box has the <see cref="WS_EX.WS_EX_TOPMOST" /> style. Use system-modal message boxes to notify
		///                 the user of serious, potentially damaging errors that require immediate attention (for example, running out of memory). This flag has
		///                 no effect on the user's ability to interact with windows other than those associated with <paramref name="hWnd" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_TASKMODAL 0x00002000L</term>
		///             <description>
		///                 Same as <see cref="MB.MB_APPLMODAL" /> except that all the top-level windows belonging to the current thread are disabled if the
		///                 <paramref name="hWnd" /> parameter is NULL. Use this flag when the calling application or library does not have a window handle
		///                 available but still needs to prevent input to other windows in the calling thread without suspending other threads.
		///             </description>
		///         </item>
		///     </list>
		///     <para>To specify other options, use one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MB_DEFAULT_DESKTOP_ONLY 0x00020000L</term>
		///             <description>
		///                 <para>Same as desktop of the interactive window station. For more information, see Window Stations.</para>
		///                 <para>
		///                     If the current input desktop is not the default desktop, <see cref="MessageBox" /> does not return until the user switches to the
		///                     default desktop.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_RIGHT 0x00080000L</term>
		///             <description>The text is right-justified.</description>
		///         </item>
		///         <item>
		///             <term>MB_RTLREADING 0x00100000L</term>
		///             <description>Displays message and caption text using right-to-left reading order on Hebrew and Arabic systems.</description>
		///         </item>
		///         <item>
		///             <term>MB_SETFOREGROUND 0x00010000L</term>
		///             <description>
		///                 The message box becomes the foreground window. Internally, the system calls the <see cref="SetForegroundWindow" /> function for the
		///                 message box.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_TOPMOST 0x00040000L</term>
		///             <description>
		///                 The message box is created with the <see cref="WS_EX.WS_EX_TOPMOST" /> window style.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_SERVICE_NOTIFICATION 0x00200000L</term>
		///             <description>
		///                 <para>
		///                     The caller is a service notifying the user of an event. The function displays a message box on the current active desktop, even
		///                     if there is no user logged on to the computer.
		///                 </para>
		///                 <para>
		///                     Terminal Services: If the calling thread has an impersonation token, the function directs the message box to the session
		///                     specified in the impersonation token.
		///                 </para>
		///                 <para>
		///                     If this flag is set, the <paramref name="hWnd" /> parameter must be NULL. This is so that the message box can appear on a desktop
		///                     other than the desktop corresponding to the <paramref name="hWnd" />.
		///                 </para>
		///                 <para>
		///                     For information on security considerations in regard to using this flag, see Interactive Services. In particular, be aware that
		///                     this flag can produce interactive content on a locked desktop and should therefore be used for only a very limited set of
		///                     scenarios, such as resource exhaustion.
		///                 </para>
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>
		///         If a message box has a Cancel button, the function returns the <see cref="IDCANCEL" /> value if either the ESC key is pressed
		///         or the Cancel button is selected. If the message box has no Cancel button, pressing ESC has no effect.
		///     </para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		///     <para>If the function succeeds, the return value is one of the following menu-item values.</para>
		/// </returns>
		/// <remarks>
		///     The following system icons can be used in a message box by setting the <paramref name="uType" /> parameter to the corresponding flag value.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "MessageBox")]
		public static extern int MessageBox([In] IntPtr hWnd, [In] string lpText, [In] string lpCaption, uint uType);

		/// <summary>Plays a waveform sound. The waveform sound for each sound type is identified by an entry in the registry.</summary>
		/// <param name="uType">
		///     <para>The sound to be played. The sounds are set by the user through the Sound control panel application, and then stored in the registry.</para>
		///     <para>This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>0xFFFFFFFF</term>
		///             <description>A simple beep. If the sound card is not available, the sound is generated using the speaker.</description>
		///         </item>
		///         <item>
		///             <term>MB_ICONASTERISK 0x00000040L</term>
		///             <description>
		///                 See <see cref="MB.MB_ICONINFORMATION" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_ICONEXCLAMATION 0x00000030L</term>
		///             <description>
		///                 See <see cref="MB.MB_ICONWARNING" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_ICONERROR 0x00000010L</term>
		///             <description>The sound specified as the Windows Critical Stop sound.</description>
		///         </item>
		///         <item>
		///             <term>MB_ICONHAND 0x00000010L</term>
		///             <description>
		///                 See <see cref="MB.MB_ICONERROR" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_ICONINFORMATION 0x00000040L</term>
		///             <description>The sound specified as the Windows Asterisk sound.</description>
		///         </item>
		///         <item>
		///             <term>MB_ICONQUESTION 0x00000020L</term>
		///             <description>The sound specified as the Windows Question sound.</description>
		///         </item>
		///         <item>
		///             <term>MB_ICONSTOP 0x00000010L</term>
		///             <description>
		///                 See <see cref="MB.MB_ICONERROR" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MB_ICONWARNING 0x00000030L</term>
		///             <description>The sound specified as the Windows Exclamation sound.</description>
		///         </item>
		///         <item>
		///             <term>MB_OK 0x00000000L</term>
		///             <description>The sound specified as the Windows Default Beep sound.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         After queuing the sound, the <see cref="MessageBeep" /> function returns control to the calling function and plays the sound asynchronously.
		///     </para>
		///     <para>
		///         If it cannot play the specified alert sound, <see cref="MessageBeep" /> attempts to play the system default sound. If it cannot play the
		///         system default sound, the function produces a standard beep sound through the computer speaker.
		///     </para>
		///     <para>The user can disable the warning beep by using the Sound control panel application.</para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "MessageBeep")]
		public static extern bool MessageBeep(uint uType);

		/// <summary>
		///     Loads a string resource from the executable file associated with a specified module, copies the string into a buffer, and appends a terminating
		///     null character.
		/// </summary>
		/// <param name="hInstance">
		///     A handle to an instance of the module whose executable file contains the string resource. To get the handle to the application itself, call the
		///     GetModuleHandle function with NULL.
		/// </param>
		/// <param name="uID">The identifier of the string to be loaded.</param>
		/// <param name="lpBuffer">The buffer is to receive the string.</param>
		/// <param name="nBufferMax">
		///     The size of the buffer, in characters. The string is truncated and null-terminated if it is longer than the number of characters specified. If
		///     this parameter is 0, then <paramref name="lpBuffer" /> receives a read-only pointer to the resource itself.
		/// </param>
		/// <returns>
		///     If the function succeeds, the return value is the number of characters copied into the buffer, not including the terminating null character, or
		///     zero if the string resource does not exist. To get extended error information, call GetLastError.
		/// </returns>
		/// <remarks></remarks>
		[DllImport("user32.dll", EntryPoint = "LoadString")]
		public static extern int LoadString([In] IntPtr hInstance, uint uID, [Out] StringBuilder lpBuffer, int cchBufferMax);

		/// <summary>
		///     <para>Loads the specified cursor resource from the executable (.EXE) file associated with an application instance.</para>
		///     <para>
		///         Note:  This function has been superseded by the <see cref="LoadImage" /> function.
		///     </para>
		/// </summary>
		/// <param name="hInstance">A handle to an instance of the module whose executable file contains the cursor to be loaded.</param>
		/// <param name="lpCursorName">
		///     <para>
		///         The name of the cursor resource to be loaded. Alternatively, this parameter can consist of the resource identifier in the low-order word and
		///         zero in the high-order word. The MAKEINTRESOURCE macro can also be used to create this value. To use one of the predefined
		///         cursors, the application must set the <paramref name="hInstance" /> parameter to NULL and the <paramref name="lpCursorName" /> parameter to
		///         one the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>IDC_APPSTARTING MAKEINTRESOURCE(32650)</term>
		///             <description>Standard arrow and small hourglass</description>
		///         </item>
		///         <item>
		///             <term>IDC_ARROW MAKEINTRESOURCE(32512)</term>
		///             <description>Standard arrow</description>
		///         </item>
		///         <item>
		///             <term>IDC_CROSS MAKEINTRESOURCE(32515)</term>
		///             <description>Crosshair</description>
		///         </item>
		///         <item>
		///             <term>IDC_HAND MAKEINTRESOURCE(32649)</term>
		///             <description>Hand</description>
		///         </item>
		///         <item>
		///             <term>IDC_HELP MAKEINTRESOURCE(32651)</term>
		///             <description>Arrow and question mark</description>
		///         </item>
		///         <item>
		///             <term>IDC_IBEAM MAKEINTRESOURCE(32513)</term>
		///             <description>I-beam</description>
		///         </item>
		///         <item>
		///             <term>IDC_ICON MAKEINTRESOURCE(32641)</term>
		///             <description>Obsolete for applications marked version 4.0 or later.</description>
		///         </item>
		///         <item>
		///             <term>IDC_NO MAKEINTRESOURCE(32648)</term>
		///             <description>Slashed circle</description>
		///         </item>
		///         <item>
		///             <term>IDC_SIZE MAKEINTRESOURCE(32640)</term>
		///             <description>
		///                 Obsolete for applications marked version 4.0 or later. Use <see cref="IDC_SIZEALL" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>IDC_SIZEALL MAKEINTRESOURCE(32646)</term>
		///             <description>Four-pointed arrow pointing north, south, east, and west</description>
		///         </item>
		///         <item>
		///             <term>IDC_SIZENESW MAKEINTRESOURCE(32643)</term>
		///             <description>Double-pointed arrow pointing northeast and southwest</description>
		///         </item>
		///         <item>
		///             <term>IDC_SIZENS MAKEINTRESOURCE(32645)</term>
		///             <description>Double-pointed arrow pointing north and south</description>
		///         </item>
		///         <item>
		///             <term>IDC_SIZENWSE MAKEINTRESOURCE(32642)</term>
		///             <description>Double-pointed arrow pointing northwest and southeast</description>
		///         </item>
		///         <item>
		///             <term>IDC_SIZEWE MAKEINTRESOURCE(32644)</term>
		///             <description>Double-pointed arrow pointing west and east</description>
		///         </item>
		///         <item>
		///             <term>IDC_UPARROW MAKEINTRESOURCE(32516)</term>
		///             <description>Vertical arrow</description>
		///         </item>
		///         <item>
		///             <term>IDC_WAIT MAKEINTRESOURCE(32514)</term>
		///             <description>Hourglass</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the handle to the newly loaded cursor.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="LoadCursor" /> function loads the cursor resource only if it has not been loaded; otherwise, it retrieves the handle to the
		///         existing resource. This function returns a valid cursor handle only if the <paramref name="lpCursorName" /> parameter is a pointer to a
		///         cursor resource. If <paramref name="lpCursorName" /> is a pointer to any type of resource other than a cursor (such as an icon), the return
		///         value is not NULL, even though it is not a valid cursor handle.
		///     </para>
		///     <para>
		///         The <see cref="LoadCursor" /> function searches the cursor resource most appropriate for the cursor for the current display device. The
		///         cursor resource can be a color or monochrome bitmap.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "LoadCursor")]
		public static extern IntPtr LoadCursor([In] IntPtr hInstance, [In] string lpCursorName);

		/// <summary>
		///     <para>
		///         [<see cref="LoadBitmap" /> is available for use in the operating systems specified in the Requirements section. It may be altered or
		///         unavailable in subsequent versions. Instead, use <see cref="LoadImage" /> and <see cref="DrawFrameControl" />.]
		///     </para>
		///     <para>
		///         The <see cref="LoadBitmap" /> function loads the specified bitmap resource from a module's executable file.
		///     </para>
		/// </summary>
		/// <param name="hInstance">A handle to the instance of the module whose executable file contains the bitmap to be loaded.</param>
		/// <param name="lpBitmapName">
		///     A pointer to a null-terminated string that contains the name of the bitmap resource to be loaded. Alternatively, this parameter can consist of
		///     the resource identifier in the low-order word and zero in the high-order word. The MAKEINTRESOURCE macro can be used to create
		///     this value.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the handle to the specified bitmap.</para>
		///     <para>If the function fails, the return value is NULL.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If the bitmap pointed to by the <paramref name="lpBitmapName" /> parameter does not exist or there is insufficient memory to load the bitmap,
		///         the function fails.
		///     </para>
		///     <para>
		///         <see cref="LoadBitmap" /> creates a compatible bitmap of the display, which cannot be selected to a printer. To load a bitmap that you can
		///         select to a printer, call <see cref="LoadImage" /> and specify LR_CREATEDIBSECTION to create a DIB section. A DIB section can be selected to
		///         any device.
		///     </para>
		///     <para>
		///         An application can use the <see cref="LoadBitmap" /> function to access predefined bitmaps. To do so, the application must set the
		///         <paramref name="hInstance" /> parameter to NULL and the <paramref name="lpBitmapName" /> parameter to one of the following values.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "LoadBitmap")]
		public static extern IntPtr LoadBitmap([In] IntPtr hInstance, [In] string lpBitmapName);

		/// <summary>
		///     <para>
		///         Synthesizes a keystroke. The system can use such a synthesized keystroke to generate a <see cref="WM.WM_KEYUP" /> or
		///         <see cref="WM.WM_KEYDOWN" />
		///         message. The keyboard driver's interrupt handler calls the <see cref="keybd_event" /> function.
		///     </para>
		///     <para>
		///         Note:  This function has been superseded. Use <see cref="SendInput" /> instead.
		///     </para>
		/// </summary>
		/// <param name="bVk">A virtual-key code. The code must be a value in the range 1 to 254. For a complete list, see Virtual Key Codes.</param>
		/// <param name="bScan">A hardware scan code for the key.</param>
		/// <param name="dwFlags">
		///     <para>Controls various aspects of function operation. This parameter can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>KEYEVENTF_EXTENDEDKEY 0x0001</term>
		///             <description>If specified, the scan code was preceded by a prefix byte having the value 0xE0 (224).</description>
		///         </item>
		///         <item>
		///             <term>KEYEVENTF_KEYUP 0x0002</term>
		///             <description>If specified, the key is being released. If not specified, the key is being depressed.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="dwExtraInfo">An additional value associated with the key stroke.</param>
		/// <returns>This function does not return a value.</returns>
		/// <remarks>
		///     An application can simulate a press of the PRINTSCRN key in order to obtain a screen snapshot and save it to the clipboard. To do this, call
		///     <see cref="keybd_event" /> with the <paramref name="bVk" /> parameter set to <see cref="VK.VK_SNAPSHOT" />.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "keybd_event")]
		public static extern void keybd_event(byte bVk, byte bScan, KEYEVENTF dwFlags, uint dwExtraInfo);

		/// <summary>
		///     The <see cref="IsRectEmpty" /> function determines whether the specified rectangle is empty. An empty rectangle is one that has no area; that is,
		///     the coordinate of the right side is less than or equal to the coordinate of the left side, or the coordinate of the bottom side is less than or
		///     equal to the coordinate of the top side.
		/// </summary>
		/// <param name="lprc">
		///     Pointer to a <see cref="RECT" /> structure that contains the logical coordinates of the rectangle.
		/// </param>
		/// <returns>
		///     <para>If the rectangle is empty, the return value is nonzero.</para>
		///     <para>If the rectangle is not empty, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all
		///     rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used
		///     determine the units of measure.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "IsRectEmpty")]
		public static extern bool IsRectEmpty([In] ref RECT lprc);

		/// <summary>Determines whether the calling thread is already a GUI thread. It can also optionally convert the thread to a GUI thread.</summary>
		/// <param name="bConvert">If TRUE and the thread is not a GUI thread, convert the thread to a GUI thread.</param>
		/// <returns>
		///     <para>The function returns a nonzero value in the following situations:</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "IsGUIThread")]
		public static extern bool IsGUIThread([MarshalAs(UnmanagedType.Bool)] bool bConvert);

		/// <summary>
		///     <para>Inserts a new menu item into a menu, moving other items down the menu.</para>
		///     <para>
		///         Note:  The <see cref="InsertMenu" /> function has been superseded by the <see cref="InsertMenuItem" /> function. You can still
		///         use <see cref="InsertMenu" />, however, if you do not need any of the extended features of <see cref="InsertMenuItem" />.
		///     </para>
		/// </summary>
		/// <param name="hMenu">A handle to the menu to be changed.</param>
		/// <param name="uPosition">
		///     The menu item before which the new menu item is to be inserted, as determined by the <paramref name="uFlags" /> parameter.
		/// </param>
		/// <param name="uFlags">
		///     <para>
		///         Controls the interpretation of the <paramref name="uPosition" /> parameter and the content, appearance, and behavior of the new menu item.
		///         This parameter must include one of the following required values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BYCOMMAND 0x00000000L</term>
		///             <description>
		///                 Indicates that the <paramref name="uPosition" /> parameter gives the identifier of the menu item. The <see cref="MF.MF_BYCOMMAND" />
		///                 flag is the default if neither the <see cref="MF.MF_BYCOMMAND" /> nor <see cref="MF.MF_BYPOSITION" /> flag is specified.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_BYPOSITION 0x00000400L</term>
		///             <description>
		///                 Indicates that the <paramref name="uPosition" /> parameter gives the zero-based relative position of the new menu item. If
		///                 <paramref name="uPosition" /> is -1, the new menu item is appended to the end of the menu.
		///             </description>
		///         </item>
		///     </list>
		///     <para>The parameter must also include at least one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BITMAP 0x00000004L</term>
		///             <description>
		///                 Uses a bitmap as the menu item. The <paramref name="lpNewItem" /> parameter contains a handle to the bitmap.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_CHECKED 0x00000008L</term>
		///             <description>
		///                 Places a check mark next to the menu item. If the application provides check-mark bitmaps (see <see cref="SetMenuItemBitmaps" />),
		///                 this flag displays the check-mark bitmap next to the menu item.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_DISABLED 0x00000002L</term>
		///             <description>Disables the menu item so that it cannot be selected, but does not gray it.</description>
		///         </item>
		///         <item>
		///             <term>MF_ENABLED 0x00000000L</term>
		///             <description>Enables the menu item so that it can be selected and restores it from its grayed state.</description>
		///         </item>
		///         <item>
		///             <term>MF_GRAYED 0x00000001L</term>
		///             <description>Disables the menu item and grays it so it cannot be selected.</description>
		///         </item>
		///         <item>
		///             <term>MF_MENUBARBREAK 0x00000020L</term>
		///             <description>
		///                 Functions the same as the <see cref="MF.MF_MENUBREAK" /> flag for a menu bar. For a drop-down menu, submenu, or shortcut menu, the new
		///                 column is separated from the old column by a vertical line.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_MENUBREAK 0x00000040L</term>
		///             <description>
		///                 Places the item on a new line (for menu bars) or in a new column (for a drop-down menu, submenu, or shortcut menu) without
		///                 separating columns.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_OWNERDRAW 0x00000100L</term>
		///             <description>
		///                 Specifies that the item is an owner-drawn item. Before the menu is displayed for the first time, the window that owns the menu
		///                 receives a <see cref="WM.WM_MEASUREITEM" /> message to retrieve the width and height of the menu item. The
		///                 <see cref="WM.WM_DRAWITEM" />
		///                 message is then sent to the window procedure of the owner window whenever the appearance of the menu item must be updated.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_POPUP 0x00000010L</term>
		///             <description>
		///                 Specifies that the menu item opens a drop-down menu or submenu. The <paramref name="uIDNewItem" /> parameter specifies a handle to
		///                 the drop-down menu or submenu. This flag is used to add a menu name to a menu bar or a menu item that opens a submenu to a drop-down
		///                 menu, submenu, or shortcut menu.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_SEPARATOR 0x00000800L</term>
		///             <description>
		///                 Draws a horizontal dividing line. This flag is used only in a drop-down menu, submenu, or shortcut menu. The line cannot be grayed,
		///                 disabled, or highlighted. The <paramref name="lpNewItem" /> and <paramref name="uIDNewItem" /> parameters are ignored.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_STRING 0x00000000L</term>
		///             <description>
		///                 Specifies that the menu item is a text string; the <paramref name="lpNewItem" /> parameter is a pointer to the string.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_UNCHECKED 0x00000000L</term>
		///             <description>
		///                 Does not place a check mark next to the menu item (default). If the application supplies check-mark bitmaps (see the
		///                 <see cref="SetMenuItemBitmaps" /> function), this flag displays the clear bitmap next to the menu item.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="uIDNewItem">
		///     The identifier of the new menu item or, if the <paramref name="uFlags" /> parameter has the <see cref="MF.MF_POPUP" /> flag set, a handle to the
		///     drop-down menu or submenu.
		/// </param>
		/// <param name="lpNewItem">
		///     <para>
		///         The content of the new menu item. The interpretation of <paramref name="lpNewItem" /> depends on whether the <paramref name="uFlags" />
		///         parameter includes the <see cref="MF.MF_BITMAP" />, <see cref="MF.MF_OWNERDRAW" />, or <see cref="MF.MF_STRING" /> flag, as follows.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BITMAP 0x00000004L</term>
		///             <description>Contains a bitmap handle.</description>
		///         </item>
		///         <item>
		///             <term>MF_OWNERDRAW 0x00000100L</term>
		///             <description>
		///                 Contains an application-supplied value that can be used to maintain additional data related to the menu item. The value is in the
		///                 <see cref="itemData" /> member of the structure pointed to by the <paramref name="lParam" /> parameter of the
		///                 <see cref="WM.WM_MEASUREITEM" /> or <see cref="WM.WM_DRAWITEM" /> message sent when the menu item is created or its appearance is
		///                 updated.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_STRING 0x00000000L</term>
		///             <description>Contains a pointer to a null-terminated string (the default).</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The application must call the <see cref="DrawMenuBar" /> function whenever a menu changes, whether the menu is in a displayed window.
		///     </para>
		///     <para>The following groups of flags cannot be used together:</para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "InsertMenu")]
		public static extern bool InsertMenu(
			[In] IntPtr hMenu, uint uPosition, MF uFlags, [MarshalAs(UnmanagedType.SysUInt)] uint uIDNewItem, [In] string lpNewItem);

		/// <summary>
		///     The <see cref="InflateRect" /> function increases or decreases the width and height of the specified rectangle. The <see cref="InflateRect" />
		///     function adds <paramref name="dx" /> units to the left and right ends of the rectangle and <paramref name="dy" /> units to the top and bottom.
		///     The <paramref name="dx" /> and <paramref name="dy" /> parameters are signed values; positive values increase the width and height, and negative
		///     values decrease them.
		/// </summary>
		/// <param name="lprc">
		///     A pointer to the <see cref="RECT" /> structure that increases or decreases in size.
		/// </param>
		/// <param name="dx">The amount to increase or decrease the rectangle width. This parameter must be negative to decrease the width.</param>
		/// <param name="dy">The amount to increase or decrease the rectangle height. This parameter must be negative to decrease the height.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all
		///     rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used
		///     determine the units of measure.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "InflateRect")]
		public static extern bool InflateRect(ref RECT lprc, int dx, int dy);

		/// <summary>
		///     <para>
		///         The <see cref="GrayString" /> function draws gray text at the specified location. The function draws the text by copying it into a memory
		///         bitmap, graying the bitmap, and then copying the bitmap to the screen. The function grays the text regardless of the selected brush and
		///         background. <see cref="GrayString" /> uses the font currently selected for the specified device context.
		///     </para>
		///     <para>
		///         If thelpOutputFuncparameter is NULL, GDI uses the <see cref="TextOut" /> function, and thelpDataparameter is assumed to be a pointer to the
		///         character string to be output. If the characters to be output cannot be handled by <see cref="TextOut" /> (for example, the string is stored
		///         as a bitmap), the application must supply its own output function.
		///     </para>
		/// </summary>
		/// <param name="hDC">A handle to the device context.</param>
		/// <param name="hBrush">
		///     A handle to the brush to be used for graying. If this parameter is NULL, the text is grayed with the same brush that was used to
		///     draw window text.
		/// </param>
		/// <param name="lpOutputFunc">
		///     A pointer to the application-defined function that will draw the string, or, if <see cref="TextOut" /> is to be used to draw the string, it is a
		///     NULL pointer. For details, see the <see cref="OutputProc" /> callback function.
		/// </param>
		/// <param name="lpData">
		///     A pointer to data to be passed to the output function. If the <paramref name="lpOutputFunc" /> parameter is NULL, <paramref name="lpData" /> must
		///     be a pointer to the string to be output.
		/// </param>
		/// <param name="nCount">
		///     The number of characters to be output. If the <paramref name="nCount" /> parameter is zero, <see cref="GrayString" /> calculates the length of
		///     the string (assuming <paramref name="lpData" /> is a pointer to the string). If <paramref name="nCount" /> is 1 and the function pointed to by
		///     <paramref name="lpOutputFunc" /> returns FALSE, the image is shown but not grayed.
		/// </param>
		/// <param name="X">The device x-coordinate of the starting position of the rectangle that encloses the string.</param>
		/// <param name="Y">The device y-coordinate of the starting position of the rectangle that encloses the string.</param>
		/// <param name="nWidth">
		///     The width, in device units, of the rectangle that encloses the string. If this parameter is zero, <see cref="GrayString" /> calculates the width
		///     of the area, assuming <paramref name="lpData" /> is a pointer to the string.
		/// </param>
		/// <param name="nHeight">
		///     The height, in device units, of the rectangle that encloses the string. If this parameter is zero, <see cref="GrayString" /> calculates the
		///     height of the area, assuming <paramref name="lpData" /> is a pointer to the string.
		/// </param>
		/// <returns>
		///     <para>If the string is drawn, the return value is nonzero.</para>
		///     <para>
		///         If either the <see cref="TextOut" /> function or the application-defined output function returned zero, or there was insufficient memory to
		///         create a memory bitmap for graying, the return value is zero.
		///     </para>
		/// </returns>
		/// <remarks>
		///     Without calling <see cref="GrayString" />, an application can draw grayed strings on devices that support a solid gray color. The system color
		///     COLOR_GRAYTEXT is the solid-gray system color used to draw disabled text. The application can call the <see cref="GetSysColor" /> function to
		///     retrieve the color value of COLOR_GRAYTEXT. If the color is other than zero (black), the application can call the <see cref="SetTextColor" />
		///     function to set the text color to the color value and then draw the string directly. If the retrieved color is black, the application must call
		///     <see cref="GrayString" /> to gray the text.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GrayString")]
		public static extern bool GrayString(
			[In] IntPtr hDC, [In] IntPtr hBrush, OutputProc lpOutputFunc, [MarshalAs(UnmanagedType.SysInt)] int lpData, int nCount, int X, int Y, int nWidth,
			int nHeight);

		/// <summary>
		///     <para>
		///         The <see cref="GetWindowDC" /> function retrieves the device context (DC) for the entire window, including title bar, menus, and scroll bars.
		///         A window device context permits painting anywhere in a window, because the origin of the device context is the upper-left corner of the
		///         window instead of the client area.
		///     </para>
		///     <para>
		///         <see cref="GetWindowDC" /> assigns default attributes to the window device context each time it retrieves the device context. Previous
		///         attributes are lost.
		///     </para>
		/// </summary>
		/// <param name="hWnd">
		///     <para>
		///         A handle to the window with a device context that is to be retrieved. If this value is NULL, <see cref="GetWindowDC" /> retrieves the device
		///         context for the entire screen.
		///     </para>
		///     <para>
		///         If this parameter is NULL, <see cref="GetWindowDC" /> retrieves the device context for the primary display monitor. To get the device context
		///         for other display monitors, use the <see cref="EnumDisplayMonitors" /> and <see cref="CreateDC" /> functions.
		///     </para>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to a device context for the specified window.</para>
		///     <para>
		///         If the function fails, the return value is NULL, indicating an error or an invalid <paramref name="hWnd" /> parameter.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         <see cref="GetWindowDC" /> is intended for special painting effects within a window's nonclient area. Painting in nonclient areas of any
		///         window is not recommended.
		///     </para>
		///     <para>
		///         The <see cref="GetSystemMetrics" /> function can be used to retrieve the dimensions of various parts of the nonclient area, such as the title
		///         bar, menu, and scroll bars.
		///     </para>
		///     <para>
		///         The <see cref="GetDC" /> function can be used to retrieve a device context for the entire screen.
		///     </para>
		///     <para>
		///         After painting is complete, the <see cref="ReleaseDC" /> function must be called to release the device context. Not releasing the window
		///         device context has serious effects on painting requested by applications.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetWindowDC")]
		public static extern IntPtr GetWindowDC([In] IntPtr hWnd);

		/// <summary>
		///     Retrieves the current color of the specified display element. Display elements are the parts of a window and the display that appear on the
		///     system display screen.
		/// </summary>
		/// <param name="nIndex">
		///     <para>The display element whose color is to be retrieved. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>COLOR_3DDKSHADOW 21</term>
		///             <description>Dark shadow for three-dimensional display elements.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_3DFACE 15</term>
		///             <description>Face color for three-dimensional display elements and for dialog box backgrounds.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_3DHIGHLIGHT 20</term>
		///             <description>Highlight color for three-dimensional display elements (for edges facing the light source.)</description>
		///         </item>
		///         <item>
		///             <term>COLOR_3DHILIGHT 20</term>
		///             <description>Highlight color for three-dimensional display elements (for edges facing the light source.)</description>
		///         </item>
		///         <item>
		///             <term>COLOR_3DLIGHT 22</term>
		///             <description>Light color for three-dimensional display elements (for edges facing the light source.)</description>
		///         </item>
		///         <item>
		///             <term>COLOR_3DSHADOW 16</term>
		///             <description>Shadow color for three-dimensional display elements (for edges facing away from the light source).</description>
		///         </item>
		///         <item>
		///             <term>COLOR_ACTIVEBORDER 10</term>
		///             <description>Active window border.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_ACTIVECAPTION 2</term>
		///             <description>
		///                 <para>Active window title bar.</para>
		///                 <para>Specifies the left side color in the color gradient of an active window's title bar if the gradient effect is enabled.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>COLOR_APPWORKSPACE 12</term>
		///             <description>Background color of multiple document interface (MDI) applications.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_BACKGROUND 1</term>
		///             <description>Desktop.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_BTNFACE 15</term>
		///             <description>Face color for three-dimensional display elements and for dialog box backgrounds.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_BTNHIGHLIGHT 20</term>
		///             <description>Highlight color for three-dimensional display elements (for edges facing the light source.)</description>
		///         </item>
		///         <item>
		///             <term>COLOR_BTNHILIGHT 20</term>
		///             <description>Highlight color for three-dimensional display elements (for edges facing the light source.)</description>
		///         </item>
		///         <item>
		///             <term>COLOR_BTNSHADOW 16</term>
		///             <description>Shadow color for three-dimensional display elements (for edges facing away from the light source).</description>
		///         </item>
		///         <item>
		///             <term>COLOR_BTNTEXT 18</term>
		///             <description>Text on push buttons.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_CAPTIONTEXT 9</term>
		///             <description>Text in caption, size box, and scroll bar arrow box.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_DESKTOP 1</term>
		///             <description>Desktop.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_GRADIENTACTIVECAPTION 27</term>
		///             <description>
		///                 Right side color in the color gradient of an active window's title bar. COLOR_ACTIVECAPTION specifies the left side color. Use
		///                 SPI_GETGRADIENTCAPTIONS with the <see cref="SystemParametersInfo" /> function to determine whether the gradient effect is enabled.
		///             </description>
		///         </item>
		///         <item>
		///             <term>COLOR_GRADIENTINACTIVECAPTION 28</term>
		///             <description>
		///                 Right side color in the color gradient of an inactive window's title bar. COLOR_INACTIVECAPTION specifies the left side
		///                 color.
		///             </description>
		///         </item>
		///         <item>
		///             <term>COLOR_GRAYTEXT 17</term>
		///             <description>Grayed (disabled) text. This color is set to 0 if the current display driver does not support a solid gray color.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_HIGHLIGHT 13</term>
		///             <description>Item(s) selected in a control.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_HIGHLIGHTTEXT 14</term>
		///             <description>Text of item(s) selected in a control.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_HOTLIGHT 26</term>
		///             <description>Color for a hyperlink or hot-tracked item.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_INACTIVEBORDER 11</term>
		///             <description>Inactive window border.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_INACTIVECAPTION 3</term>
		///             <description>
		///                 <para>Inactive window caption.</para>
		///                 <para>Specifies the left side color in the color gradient of an inactive window's title bar if the gradient effect is enabled.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>COLOR_INACTIVECAPTIONTEXT 19</term>
		///             <description>Color of text in an inactive caption.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_INFOBK 24</term>
		///             <description>Background color for tooltip controls.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_INFOTEXT 23</term>
		///             <description>Text color for tooltip controls.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_MENU 4</term>
		///             <description>Menu background.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_MENUHILIGHT 29</term>
		///             <description>
		///                 <para>
		///                     The color used to highlight menu items when the menu appears as a flat menu (see <see cref="SystemParametersInfo" />). The
		///                     highlighted menu item is outlined with COLOR_HIGHLIGHT.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>COLOR_MENUBAR 30</term>
		///             <description>
		///                 <para>
		///                     The background color for the menu bar when menus appear as flat menus (see <see cref="SystemParametersInfo" />). However,
		///                     COLOR_MENU continues to specify the background color of the menu popup.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>COLOR_MENUTEXT 7</term>
		///             <description>Text in menus.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_SCROLLBAR 0</term>
		///             <description>Scroll bar gray area.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_WINDOW 5</term>
		///             <description>Window background.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_WINDOWFRAME 6</term>
		///             <description>Window frame.</description>
		///         </item>
		///         <item>
		///             <term>COLOR_WINDOWTEXT 8</term>
		///             <description>Text in windows.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>The function returns the red, green, blue (RGB) color value of the given element.</para>
		///     <para>
		///         If the <paramref name="nIndex" /> parameter is out of range, the return value is zero. Because zero is also a valid RGB value, you cannot use
		///         <see cref="GetSysColor" /> to determine whether a system color is supported by the current platform. Instead, use the
		///         <see cref="GetSysColorBrush" /> function, which returns NULL if the color is not supported.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         To display the component of the RGB value, use the <see cref="GetRValue" />, <see cref="GetGValue" />, and <see cref="GetBValue" /> macros.
		///     </para>
		///     <para>System colors for monochrome displays are usually interpreted as shades of gray.</para>
		///     <para>
		///         To paint with a system color brush, an application should use GetSysColorBrush(nIndex), instead of CreateSolidBrush(GetSysColor(nIndex)),
		///         because <see cref="GetSysColorBrush" /> returns a cached brush, instead of allocating a new one.
		///     </para>
		///     <para>
		///         Color is an important visual element of most user interfaces. For guidelines about using color in your applications, see <see cref="Color" />
		///         .
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetSysColor")]
		public static extern uint GetSysColor(int nIndex);

		/// <summary>
		///     <para>
		///         Retrieves a message from the calling thread's message queue. The function dispatches incoming sent messages until a posted message is
		///         available for retrieval.
		///     </para>
		///     <para>
		///         Unlike <see cref="GetMessage" />, the <see cref="PeekMessage" /> function does not wait for a message to be posted before returning.
		///     </para>
		/// </summary>
		/// <param name="lpMsg">
		///     A pointer to an <see cref="MSG" /> structure that receives message information from the thread's message queue.
		/// </param>
		/// <param name="hWnd">
		///     <para>A handle to the window whose messages are to be retrieved. The window must belong to the current thread.</para>
		///     <para>
		///         If <paramref name="hWnd" /> is NULL, <see cref="GetMessage" /> retrieves messages for any window that belongs to the current thread, and any
		///         messages on the current thread's message queue whose <see cref="hwnd" /> value is NULL (see the <see cref="MSG" /> structure). Therefore if
		///         hWnd is NULL, both window messages and thread messages are processed.
		///     </para>
		///     <para>
		///         If <paramref name="hWnd" /> is -1, <see cref="GetMessage" /> retrieves only messages on the current thread's message queue whose
		///         <see cref="hwnd" /> value is NULL, that is, thread messages as posted by <see cref="PostMessage" /> (when the <paramref name="hWnd" />
		///         parameter is NULL) or <see cref="PostThreadMessage" />.
		///     </para>
		/// </param>
		/// <param name="wMsgFilterMin">
		///     <para>
		///         The integer value of the lowest message value to be retrieved. Use <see cref="WM.WM_KEYFIRST" /> (0x0100) to specify the first keyboard
		///         message or <see cref="WM.WM_MOUSEFIRST" /> (0x0200) to specify the first mouse message.
		///     </para>
		///     <para>
		///         Use <see cref="WM.WM_INPUT" /> here and in <paramref name="wMsgFilterMax" /> to specify only the <see cref="WM.WM_INPUT" /> messages.
		///     </para>
		///     <para>
		///         If <paramref name="wMsgFilterMin" /> and <paramref name="wMsgFilterMax" /> are both zero, <see cref="GetMessage" /> returns all available
		///         messages (that is, no range filtering is performed).
		///     </para>
		/// </param>
		/// <param name="wMsgFilterMax">
		///     <para>
		///         The integer value of the highest message value to be retrieved. Use <see cref="WM.WM_KEYLAST" /> to specify the last keyboard message or
		///         <see cref="WM.WM_MOUSELAST" /> to specify the last mouse message.
		///     </para>
		///     <para>
		///         Use <see cref="WM.WM_INPUT" /> here and in <paramref name="wMsgFilterMin" /> to specify only the <see cref="WM.WM_INPUT" /> messages.
		///     </para>
		///     <para>
		///         If <paramref name="wMsgFilterMin" /> and <paramref name="wMsgFilterMax" /> are both zero, <see cref="GetMessage" /> returns all available
		///         messages (that is, no range filtering is performed).
		///     </para>
		/// </param>
		/// <returns>
		///     <para>
		///         If the function retrieves a message other than <see cref="WM.WM_QUIT" />, the return value is nonzero.
		///     </para>
		///     <para>
		///         If the function retrieves the <see cref="WM.WM_QUIT" /> message, the return value is zero.
		///     </para>
		///     <para>
		///         If there is an error, the return value is -1. For example, the function fails if <paramref name="hWnd" /> is an invalid window handle or
		///         <paramref name="lpMsg" /> is an invalid pointer. To get extended error information, call GetLastError.
		///     </para>
		///     <para>Because the return value can be nonzero, zero, or -1, avoid code like this:</para>
		/// </returns>
		/// <remarks>
		///     <para>An application typically uses the return value to determine whether to end the main message loop and exit the program.</para>
		///     <para>
		///         The <see cref="GetMessage" /> function retrieves messages associated with the window identified by the <paramref name="hWnd" /> parameter or
		///         any of its children, as specified by the <see cref="IsChild" /> function, and within the range of message values given by the
		///         <paramref name="wMsgFilterMin" /> and <paramref name="wMsgFilterMax" /> parameters. Note that an application can only use the low word in the
		///         <paramref name="wMsgFilterMin" /> and <paramref name="wMsgFilterMax" /> parameters; the high word is reserved for the system.
		///     </para>
		///     <para>
		///         Note that <see cref="GetMessage" /> always retrieves <see cref="WM.WM_QUIT" /> messages, no matter which values you specify for
		///         <paramref name="wMsgFilterMin" /> and <paramref name="wMsgFilterMax" />.
		///     </para>
		///     <para>
		///         During this call, the system delivers pending, nonqueued messages, that is, messages sent to windows owned by the calling thread using the
		///         <see cref="SendMessage" />, <see cref="SendMessageCallback" />, <see cref="SendMessageTimeout" />, or <see cref="SendNotifyMessage" />
		///         function. Then the first queued message that matches the specified filter is retrieved. The system may also process internal events. If no
		///         filter is specified, messages are processed in the following order:
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetMessage")]
		public static extern bool GetMessage([Out] out MSG lpMsg, [In] IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax);

		/// <summary>Retrieves information about a specified menu.</summary>
		/// <param name="hmenu">A handle on a menu.</param>
		/// <param name="lpcmi">
		///     A pointer to a <see cref="MENUINFO" /> structure containing information for the menu. Note that you must set the <see cref="cbSize" /> member to
		///     sizeof(MENUINFO) before calling this function.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetMenuInfo")]
		public static extern bool GetMenuInfo([In] IntPtr hmenu, ref MENUINFO lpcmi);

		/// <summary>
		///     Retrieves the status of the specified virtual key. The status specifies whether the key is up, down, or toggled (on, off—alternating each time
		///     the key is pressed).
		/// </summary>
		/// <param name="nVirtKey">
		///     <para>
		///         A virtual key. If the desired virtual key is a letter or digit (A through Z, a through z, or 0 through 9), <paramref name="nVirtKey" /> must
		///         be set to the ASCII value of that character. For other keys, it must be a virtual-key code.
		///     </para>
		///     <para>
		///         If a non-English keyboard layout is used, virtual keys with values in the range ASCII A through Z and 0 through 9 are used to specify most of
		///         the character keys. For example, for the German keyboard layout, the virtual key of value ASCII O (0x4F) refers to the "o" key, whereas
		///         VK_OEM_1 refers to the "o with umlaut" key.
		///     </para>
		/// </param>
		/// <returns>The return value specifies the status of the specified virtual key, as follows:</returns>
		/// <remarks>
		///     <para>
		///         The key status returned from this function changes as a thread reads key messages from its message queue. The status does not reflect the
		///         interrupt-level state associated with the hardware. Use the <see cref="GetAsyncKeyState" /> function to retrieve that information.
		///     </para>
		///     <para>
		///         An application calls <see cref="GetKeyState" /> in response to a keyboard-input message. This function retrieves the state of the key when
		///         the input message was generated.
		///     </para>
		///     <para>
		///         To retrieve state information for all the virtual keys, use the <see cref="GetKeyboardState" /> function.
		///     </para>
		///     <para>
		///         An application can use the virtual key code constants <see cref="VK.VK_SHIFT" />, <see cref="VK.VK_CONTROL" />, and <see cref="VK.VK_MENU" /> as
		///         values for the <paramref name="nVirtKey" /> parameter. This gives the status of the SHIFT, CTRL, or ALT keys without distinguishing between
		///         left and right. An application can also use the following virtual-key code constants as values for <paramref name="nVirtKey" /> to
		///         distinguish between the left and right instances of those keys:
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetKeyState")]
		public static extern short GetKeyState(int nVirtKey);

		/// <summary>Retrieves information about the specified icon or cursor.</summary>
		/// <param name="hIcon">
		///     <para>A handle to the icon or cursor. To retrieve information about a standard icon or cursor, specify one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>IDC_APPSTARTING MAKEINTRESOURCE(32650)</term>
		///             <description>Standard arrow and small hourglass cursor.</description>
		///         </item>
		///         <item>
		///             <term>IDC_ARROW MAKEINTRESOURCE(32512)</term>
		///             <description>Standard arrow cursor.</description>
		///         </item>
		///         <item>
		///             <term>IDC_CROSS MAKEINTRESOURCE(32515)</term>
		///             <description>Crosshair cursor.</description>
		///         </item>
		///         <item>
		///             <term>IDC_HAND MAKEINTRESOURCE(32649)</term>
		///             <description>Hand cursor.</description>
		///         </item>
		///         <item>
		///             <term>IDC_HELP MAKEINTRESOURCE(32651)</term>
		///             <description>Arrow and question mark cursor.</description>
		///         </item>
		///         <item>
		///             <term>IDC_IBEAM MAKEINTRESOURCE(32513)</term>
		///             <description>I-beam cursor.</description>
		///         </item>
		///         <item>
		///             <term>IDC_NO MAKEINTRESOURCE(32648)</term>
		///             <description>Slashed circle cursor.</description>
		///         </item>
		///         <item>
		///             <term>IDC_SIZEALL MAKEINTRESOURCE(32646)</term>
		///             <description>Four-pointed arrow cursor pointing north, south, east, and west.</description>
		///         </item>
		///         <item>
		///             <term>IDC_SIZENESW MAKEINTRESOURCE(32643)</term>
		///             <description>Double-pointed arrow cursor pointing northeast and southwest.</description>
		///         </item>
		///         <item>
		///             <term>IDC_SIZENS MAKEINTRESOURCE(32645)</term>
		///             <description>Double-pointed arrow cursor pointing north and south.</description>
		///         </item>
		///         <item>
		///             <term>IDC_SIZENWSE MAKEINTRESOURCE(32642)</term>
		///             <description>Double-pointed arrow cursor pointing northwest and southeast.</description>
		///         </item>
		///         <item>
		///             <term>IDC_SIZEWE MAKEINTRESOURCE(32644)</term>
		///             <description>Double-pointed arrow cursor pointing west and east.</description>
		///         </item>
		///         <item>
		///             <term>IDC_UPARROW MAKEINTRESOURCE(32516)</term>
		///             <description>Vertical arrow cursor.</description>
		///         </item>
		///         <item>
		///             <term>IDC_WAIT MAKEINTRESOURCE(32514)</term>
		///             <description>Hourglass cursor.</description>
		///         </item>
		///         <item>
		///             <term>IDI_APPLICATION MAKEINTRESOURCE(32512)</term>
		///             <description>Application icon.</description>
		///         </item>
		///         <item>
		///             <term>IDI_ASTERISK MAKEINTRESOURCE(32516)</term>
		///             <description>Asterisk icon.</description>
		///         </item>
		///         <item>
		///             <term>IDI_EXCLAMATION MAKEINTRESOURCE(32515)</term>
		///             <description>Exclamation point icon.</description>
		///         </item>
		///         <item>
		///             <term>IDI_HAND MAKEINTRESOURCE(32513)</term>
		///             <description>Stop sign icon.</description>
		///         </item>
		///         <item>
		///             <term>IDI_QUESTION MAKEINTRESOURCE(32514)</term>
		///             <description>Question-mark icon.</description>
		///         </item>
		///         <item>
		///             <term>IDI_WINLOGO MAKEINTRESOURCE(32517)</term>
		///             <description>
		///                 <para>Application icon.</para>
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="piconinfo">
		///     A pointer to an <see cref="ICONINFO" /> structure. The function fills in the structure's members.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is nonzero and the function fills in the members of the specified <see cref="ICONINFO" />
		///         structure.
		///     </para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <see cref="GetIconInfo" /> creates bitmaps for the <see cref="hbmMask" /> and <see cref="hbmCol" />or members of <see cref="ICONINFO" />. The
		///     calling application must manage these bitmaps and delete them when they are no longer necessary.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetIconInfo")]
		public static extern bool GetIconInfo([In] IntPtr hIcon, [Out] out ICONINFO piconinfo);

		/// <summary>
		///     Copies the caret's position to the specified <see cref="POINT" /> structure.
		/// </summary>
		/// <param name="lpPoint">
		///     A pointer to the <see cref="POINT" /> structure that is to receive the client coordinates of the caret.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>The caret position is always given in the client coordinates of the window that contains the caret.</remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "GetCaretPos")]
		public static extern bool GetCaretPos([Out] out POINT lpPoint);

		/// <summary>Retrieves the handle to the ancestor of the specified window.</summary>
		/// <param name="hwnd">A handle to the window whose ancestor is to be retrieved. If this parameter is the desktop window, the function returns NULL.</param>
		/// <param name="gaFlags">
		///     <para>The ancestor to be retrieved. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>GA_PARENT 1</term>
		///             <description>
		///                 Retrieves the parent window. This does not include the owner, as it does with the <see cref="GetParent" /> function.
		///             </description>
		///         </item>
		///         <item>
		///             <term>GA_ROOT 2</term>
		///             <description>Retrieves the root window by walking the chain of parent windows.</description>
		///         </item>
		///         <item>
		///             <term>GA_ROOTOWNER 3</term>
		///             <description>
		///                 Retrieves the owned root window by walking the chain of parent and owner windows returned by <see cref="GetParent" />.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>The return value is the handle to the ancestor window.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetAncestor")]
		public static extern IntPtr GetAncestor([In] IntPtr hwnd, GA gaFlags);

		/// <summary>
		///     <para>Flashes the specified window one time. It does not change the active state of the window.</para>
		///     <para>
		///         To flash the window a specified number of times, use the <see cref="FlashWindowEx" /> function.
		///     </para>
		/// </summary>
		/// <param name="hWnd">A handle to the window to be flashed. The window can be either open or minimized.</param>
		/// <param name="bInvert">
		///     <para>
		///         If this parameter is TRUE, the window is flashed from one state to the other. If it is FALSE, the window is returned to its original state
		///         (either active or inactive).
		///     </para>
		///     <para>
		///         When an application is minimized and this parameter is TRUE, the taskbar window button flashes active/inactive. If it is FALSE, the taskbar
		///         window button flashes inactive, meaning that it does not change colors. It flashes, as if it were being redrawn, but it does not provide the
		///         visual invert clue to the user.
		///     </para>
		/// </param>
		/// <returns>
		///     The return value specifies the window's state before the call to the <see cref="FlashWindow" /> function. If the window caption was drawn as
		///     active before the call, the return value is nonzero. Otherwise, the return value is zero.
		/// </returns>
		/// <remarks>
		///     <para>
		///         Flashing a window means changing the appearance of its caption bar as if the window were changing from inactive to active status, or vice
		///         versa. (An inactive caption bar changes to an active caption bar; an active caption bar changes to an inactive caption bar.)
		///     </para>
		///     <para>
		///         Typically, a window is flashed to inform the user that the window requires attention but that it does not currently have the keyboard
		///         focus.
		///     </para>
		///     <para>
		///         The <see cref="FlashWindow" /> function flashes the window only once; for repeated flashing, the application should create a system timer.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "FlashWindow")]
		public static extern bool FlashWindow([In] IntPtr hWnd, [MarshalAs(UnmanagedType.Bool)] bool bInvert);

		/// <summary>
		///     <para>
		///         Retrieves a handle to the top-level window whose class name and window name match the specified strings. This function does not search child
		///         windows. This function does not perform a case-sensitive search.
		///     </para>
		///     <para>
		///         To search child windows, beginning with a specified child window, use the <see cref="FindWindowEx" /> function.
		///     </para>
		/// </summary>
		/// <param name="lpClassName">
		///     <para>
		///         The class name or a class atom created by a previous call to the <see cref="RegisterClass" /> or <see cref="RegisterClassEx" /> function. The
		///         atom must be in the low-order word of <paramref name="lpClassName" />; the high-order word must be zero.
		///     </para>
		///     <para>
		///         If <paramref name="lpClassName" /> points to a string, it specifies the window class name. The class name can be any name registered with
		///         <see cref="RegisterClass" /> or <see cref="RegisterClassEx" />, or any of the predefined control-class names.
		///     </para>
		///     <para>
		///         If <paramref name="lpClassName" /> is NULL, it finds any window whose title matches the <paramref name="lpWindowName" /> parameter.
		///     </para>
		/// </param>
		/// <param name="lpWindowName">The window name (the window's title). If this parameter is NULL, all window names match.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to the window that has the specified class name and window name.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     If the <paramref name="lpWindowName" /> parameter is not NULL, <see cref="FindWindow" /> calls the <see cref="GetWindowText" /> function to
		///     retrieve the window name for comparison. For a description of a potential problem that can arise, see the Remarks for
		///     <see cref="GetWindowText" />.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "FindWindow")]
		public static extern IntPtr FindWindow([In] string lpClassName, [In] string lpWindowName);

		/// <summary>
		///     Enumerates all top-level windows on the screen by passing the handle to each window, in turn, to an application-defined callback function.
		///     <see cref="EnumWindows" /> continues until the last top-level window is enumerated or the callback function returns FALSE.
		/// </summary>
		/// <param name="lpEnumFunc">
		///     A pointer to an application-defined callback function. For more information, see <see cref="EnumWindowsProc" />.
		/// </param>
		/// <param name="lParam">An application-defined value to be passed to the callback function.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		///     <para>
		///         If <see cref="EnumWindowsProc" /> returns zero, the return value is also zero. In this case, the callback function should call
		///         SetLastError to obtain a meaningful error code to be returned to the caller of <see cref="EnumWindows" />.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="EnumWindows" /> function does not enumerate child windows, with the exception of a few top-level windows owned by the system
		///         that have the <see cref="WS.WS_CHILD" /> style.
		///     </para>
		///     <para>
		///         This function is more reliable than calling the <see cref="GetWindow" /> function in a loop. An application that calls
		///         <see cref="GetWindow" /> to perform this task risks being caught in an infinite loop or referencing a handle to a window that has been
		///         destroyed.
		///     </para>
		///     <para>
		///         Note:  For Windows 8 and later, <see cref="EnumWindows" /> enumerates only top-level windows of desktop apps.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "EnumWindows")]
		public static extern bool EnumWindows(EnumWindowsProc lpEnumFunc, [MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>
		///     The <see cref="DrawTextEx" /> function draws formatted text in the specified rectangle.
		/// </summary>
		/// <param name="hdc">A handle to the device context in which to draw.</param>
		/// <param name="lpchText">
		///     <para>
		///         A pointer to the string that contains the text to draw. If the <paramref name="cchText" /> parameter is -1, the string must be
		///         null-terminated.
		///     </para>
		///     <para>
		///         If <paramref name="dwDTFormat" /> includes DT_MODIFYSTRING, the function could add up to four additional characters to this string. The
		///         buffer containing the string should be large enough to accommodate these extra characters.
		///     </para>
		/// </param>
		/// <param name="cchText">
		///     The length of the string pointed to by <paramref name="lpchText" />. If <paramref name="cchText" /> is -1, then the <paramref name="lpchText" />
		///     parameter is assumed to be a pointer to a null-terminated string and <see cref="DrawTextEx" /> computes the character count automatically.
		/// </param>
		/// <param name="lprc">
		///     A pointer to a <see cref="RECT" /> structure that contains the rectangle, in logical coordinates, in which the text is to be formatted.
		/// </param>
		/// <param name="dwDTFormat">
		///     <para>The formatting options. This parameter can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>DT_BOTTOM</term>
		///             <description>Justifies the text to the bottom of the rectangle. This value is used only with the DT_SINGLELINE value.</description>
		///         </item>
		///         <item>
		///             <term>DT_CALCRECT</term>
		///             <description>
		///                 Determines the width and height of the rectangle. If there are multiple lines of text, <see cref="DrawTextEx" /> uses the width of
		///                 the rectangle pointed to by the <paramref name="lprc" /> parameter and extends the base of the rectangle to bound the last line of
		///                 text. If there is only one line of text, <see cref="DrawTextEx" /> modifies the right side of the rectangle so that it bounds the
		///                 last character in the line. In either case, <see cref="DrawTextEx" /> returns the height of the formatted text, but does not draw the
		///                 text.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_CENTER</term>
		///             <description>Centers text horizontally in the rectangle.</description>
		///         </item>
		///         <item>
		///             <term>DT_EDITCONTROL</term>
		///             <description>
		///                 Duplicates the text-displaying characteristics of a multiline edit control. Specifically, the average character width is calculated
		///                 in the same manner as for an edit control, and the function does not display a partially visible last line.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_END_ELLIPSIS</term>
		///             <description>
		///                 <para>
		///                     For displayed text, replaces the end of a string with ellipses so that the result fits in the specified rectangle. Any word (not
		///                     at the end of the string) that goes beyond the limits of the rectangle is truncated without ellipses. The string is not modified
		///                     unless the DT_MODIFYSTRING flag is specified.
		///                 </para>
		///                 <para>Compare with DT_PATH_ELLIPSIS and DT_WORD_ELLIPSIS.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_EXPANDTABS</term>
		///             <description>Expands tab characters. The default number of characters per tab is eight.</description>
		///         </item>
		///         <item>
		///             <term>DT_EXTERNALLEADING</term>
		///             <description>
		///                 Includes the font external leading in line height. Normally, external leading is not included in the height of a line of
		///                 text.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_HIDEPREFIX</term>
		///             <description>
		///                 <para>
		///                     Ignores the ampersand (&amp;) prefix character in the text. The letter that follows will not be underlined, but other
		///                     mnemonic-prefix characters are still processed.
		///                 </para>
		///                 <para>Example:</para>
		///                 <para>input string: "A&amp;bc&amp;&amp;d"</para>
		///                 <para>normal: "Abc&amp;d"</para>
		///                 <para>DT_HIDEPREFIX: "Abc&amp;d"</para>
		///                 <para>Compare with DT_NOPREFIX and DT_PREFIXONLY.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_INTERNAL</term>
		///             <description>Uses the system font to calculate text metrics.</description>
		///         </item>
		///         <item>
		///             <term>DT_LEFT</term>
		///             <description>Aligns text to the left.</description>
		///         </item>
		///         <item>
		///             <term>DT_MODIFYSTRING</term>
		///             <description>
		///                 Modifies the specified string to match the displayed text. This value has no effect unless DT_END_ELLIPSIS or
		///                 DT_PATH_ELLIPSIS is specified.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_NOCLIP</term>
		///             <description>
		///                 Draws without clipping. <see cref="DrawTextEx" /> is somewhat faster when DT_NOCLIP is used.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_NOFULLWIDTHCHARBREAK</term>
		///             <description>
		///                 Prevents a line break at a DBCS (double-wide character string), so that the line-breaking rule is equivalent to SBCS strings. For
		///                 example, this can be used in Korean windows, for more readability of icon labels. This value has no effect unless DT_WORDBREAK is
		///                 specified.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_NOPREFIX</term>
		///             <description>
		///                 Turns off processing of prefix characters. Normally, <see cref="DrawTextEx" /> interprets the ampersand (&amp;) mnemonic-prefix
		///                 character as a directive to underscore the character that follows, and the double-ampersand (&amp;&amp;) mnemonic-prefix characters
		///                 as a directive to print a single ampersand. By specifying DT_NOPREFIX, this processing is turned off. Compare with DT_HIDEPREFIX and
		///                 DT_PREFIXONLY
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_PATH_ELLIPSIS</term>
		///             <description>
		///                 <para>
		///                     For displayed text, replaces characters in the middle of the string with ellipses so that the result fits in the specified
		///                     rectangle. If the string contains backslash (\) characters, DT_PATH_ELLIPSIS preserves as much as possible of the text after the
		///                     last backslash. The string is not modified unless the DT_MODIFYSTRING flag is specified.
		///                 </para>
		///                 <para>Compare with DT_END_ELLIPSIS and DT_WORD_ELLIPSIS.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_PREFIXONLY</term>
		///             <description>
		///                 <para>
		///                     Draws only an underline at the position of the character following the ampersand (&amp;) prefix character. Does not draw any
		///                     character in the string.
		///                 </para>
		///                 <para>Example:</para>
		///                 <para>input string: "A&amp;bc&amp;&amp;d"</para>
		///                 <para>normal: "Abc&amp;d"</para>
		///                 <para>PREFIXONLY: " _ "</para>
		///                 <para>Compare with DT_NOPREFIX and DT_HIDEPREFIX.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_RIGHT</term>
		///             <description>Aligns text to the right.</description>
		///         </item>
		///         <item>
		///             <term>DT_RTLREADING</term>
		///             <description>
		///                 Layout in right-to-left reading order for bidirectional text when the font selected into the <paramref name="hdc" /> is a Hebrew or
		///                 Arabic font. The default reading order for all text is left-to-right.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_SINGLELINE</term>
		///             <description>Displays text on a single line only. Carriage returns and line feeds do not break the line.</description>
		///         </item>
		///         <item>
		///             <term>DT_TABSTOP</term>
		///             <description>
		///                 Sets tab stops. The <see cref="DRAWTEXTPARAMS" /> structure pointed to by the <paramref name="lpDTParams" /> parameter specifies the
		///                 number of average character widths per tab stop.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_TOP</term>
		///             <description>Justifies the text to the top of the rectangle.</description>
		///         </item>
		///         <item>
		///             <term>DT_VCENTER</term>
		///             <description>Centers text vertically. This value is used only with the DT_SINGLELINE value.</description>
		///         </item>
		///         <item>
		///             <term>DT_WORDBREAK</term>
		///             <description>
		///                 Breaks words. Lines are automatically broken between words if a word extends past the edge of the rectangle specified by the
		///                 <paramref name="lprc" /> parameter. A carriage return-line feed sequence also breaks the line.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_WORD_ELLIPSIS</term>
		///             <description>
		///                 <para>Truncates any word that does not fit in the rectangle and adds ellipses.</para>
		///                 <para>Compare with DT_END_ELLIPSIS and DT_PATH_ELLIPSIS.</para>
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="lpDTParams">
		///     A pointer to a <see cref="DRAWTEXTPARAMS" /> structure that specifies additional formatting options. This parameter can be NULL.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is the text height in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is
		///         the offset from lprc->top to the bottom of the drawn text
		///     </para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="DrawTextEx" /> function supports only fonts whose escapement and orientation are both zero.
		///     </para>
		///     <para>The text alignment mode for the device context must include the TA_LEFT, TA_TOP, and TA_NOUPDATECP flags.</para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DrawTextEx")]
		public static extern int DrawTextEx([In] IntPtr hdc, StringBuilder lpchText, int cchText, ref RECT lprc, uint format, [In] IntPtr lpdtp);

		/// <summary>
		///     Redraws the menu bar of the specified window. If the menu bar changes after the system has created the window, this function must be called to
		///     draw the changed menu bar.
		/// </summary>
		/// <param name="hWnd">A handle to the window whose menu bar is to be redrawn.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DrawMenuBar")]
		public static extern bool DrawMenuBar([In] IntPtr hWnd);

		/// <summary>
		///     The <see cref="DrawCaption" /> function draws a window caption.
		/// </summary>
		/// <param name="hwnd">A handle to a window that supplies text and an icon for the window caption.</param>
		/// <param name="hdc">A handle to a device context. The function draws the window caption into this device context.</param>
		/// <param name="lprc">
		///     A pointer to a <see cref="RECT" /> structure that specifies the bounding rectangle for the window caption in logical coordinates.
		/// </param>
		/// <param name="uFlags">
		///     <para>The drawing options. This parameter can be zero or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>DC_ACTIVE</term>
		///             <description>The function uses the colors that denote an active caption.</description>
		///         </item>
		///         <item>
		///             <term>DC_BUTTONS</term>
		///             <description>If set, the function draws the buttons in the caption bar (to minimize, restore, or close an application).</description>
		///         </item>
		///         <item>
		///             <term>DC_GRADIENT</term>
		///             <description>
		///                 <para>
		///                     When this flag is set, the function uses COLOR_GRADIENTACTIVECAPTION (if the DC_ACTIVE flag was set) or
		///                     COLOR_GRADIENTINACTIVECAPTION for the title-bar color.
		///                 </para>
		///                 <para>If this flag is not set, the function uses COLOR_ACTIVECAPTION or COLOR_INACTIVECAPTION for both colors.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>DC_ICON</term>
		///             <description>The function draws the icon when drawing the caption text.</description>
		///         </item>
		///         <item>
		///             <term>DC_INBUTTON</term>
		///             <description>The function draws the caption as a button.</description>
		///         </item>
		///         <item>
		///             <term>DC_SMALLCAP</term>
		///             <description>The function draws a small caption, using the current small caption font.</description>
		///         </item>
		///         <item>
		///             <term>DC_TEXT</term>
		///             <description>The function draws the caption text when drawing the caption.</description>
		///         </item>
		///     </list>
		///     <para>If DC_SMALLCAP is specified, the function draws a normal window caption.</para>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DrawCaption")]
		public static extern bool DrawCaption([In] IntPtr hwnd, [In] IntPtr hdc, [In] ref RECT lprc, DC uFlags);

		/// <summary>
		///     Replaces the contents of a list box with the names of the subdirectories and files in a specified directory. You can filter the list of names by
		///     specifying a set of file attributes. The list can optionally include mapped drives.
		/// </summary>
		/// <param name="hDlg">A handle to the dialog box that contains the list box.</param>
		/// <param name="lpPathSpec">
		///     <para>
		///         A pointer to a buffer containing a null-terminated string that specifies an absolute path, relative path, or filename. An absolute path can
		///         begin with a drive letter (for example, d:\) or a UNC name (for example, \\ <paramref name="machinename" />\ <paramref name="sharename" />).
		///     </para>
		///     <para>
		///         The function splits the string into a directory and a filename. The function searches the directory for names that match the filename. If the
		///         string does not specify a directory, the function searches the current directory.
		///     </para>
		///     <para>
		///         If the string includes a filename, the filename must contain at least one wildcard character (? or *). If the string does not include a
		///         filename, the function behaves as if you had specified the asterisk wildcard character (*) as the filename. All names in the specified
		///         directory that match the filename and have the attributes specified by the <paramref name="uFileType" /> parameter are added to the list box.
		///     </para>
		/// </param>
		/// <param name="nIDListBox">
		///     The identifier of a list box in the <paramref name="hDlg" /> dialog box. If this parameter is zero, <see cref="DlgDirList" /> does not try to
		///     fill a list box.
		/// </param>
		/// <param name="nIDStaticPath">
		///     The identifier of a static control in the <paramref name="hDlg" /> dialog box. <see cref="DlgDirList" /> sets the text of this control to display
		///     the current drive and directory. This parameter can be zero if you do not want to display the current drive and directory.
		/// </param>
		/// <param name="uFileType">
		///     <para>
		///         Specifies the attributes of the files or directories to be added to the list box. This parameter can be one or more of the following
		///         values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>DDL_ARCHIVE</term>
		///             <description>Includes archived files.</description>
		///         </item>
		///         <item>
		///             <term>DDL_DIRECTORY</term>
		///             <description>Includes subdirectories. Subdirectory names are enclosed in square brackets ([ ]).</description>
		///         </item>
		///         <item>
		///             <term>DDL_DRIVES</term>
		///             <description>
		///                 All mapped drives are added to the list. Drives are listed in the form [- <paramref name="x" />-], where <paramref name="x" /> is the
		///                 drive letter.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DDL_EXCLUSIVE</term>
		///             <description>
		///                 Includes only files with the specified attributes. By default, read/write files are listed even if DDL_READWRITE is not
		///                 specified.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DDL_HIDDEN</term>
		///             <description>Includes hidden files.</description>
		///         </item>
		///         <item>
		///             <term>DDL_READONLY</term>
		///             <description>Includes read-only files.</description>
		///         </item>
		///         <item>
		///             <term>DDL_READWRITE</term>
		///             <description>Includes read/write files with no additional attributes. This is the default setting.</description>
		///         </item>
		///         <item>
		///             <term>DDL_SYSTEM</term>
		///             <description>Includes system files.</description>
		///         </item>
		///         <item>
		///             <term>DDL_POSTMSGS</term>
		///             <description>
		///                 If set, <see cref="DlgDirList" /> uses the <see cref="PostMessage" /> function to send messages to the list box. If not set,
		///                 <see cref="DlgDirList" /> uses the <see cref="SendMessage" /> function.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>
		///         If the function fails, the return value is zero. For example, if the string specified by <paramref name="lpPathSpec" /> is not a valid path,
		///         the function fails. To get extended error information, call .
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If <paramref name="lpPathSpec" /> specifies a directory, <see cref="DlgDirListComboBox" /> changes the current directory to the specified
		///         directory before filling the list box. The text of the static control identified by the <paramref name="nIDStaticPath" /> parameter is set to
		///         the name of the new current directory.
		///     </para>
		///     <para>
		///         <see cref="DlgDirList" /> sends the <see cref="LB_RESETCONTENT" /> and <see cref="LB_DIR" /> messages to the list box.
		///     </para>
		///     <para>
		///         Windows NT 4.0 and later: If <paramref name="uFileType" /> includes the DDL_DIRECTORY flag and <paramref name="lpPathSpec" /> specifies a
		///         first-level directory, such as C:\TEMP, the list box will always include a ".." entry for the root directory. This is true even if the root
		///         directory has hidden or system attributes and the DDL_HIDDEN and DDL_SYSTEM flags are not specified. The root directory of an NTFS volume has
		///         hidden and system attributes.
		///     </para>
		///     <para>Windows NT/2000/XP: The directory listing displays long filenames, if any.</para>
		///     <para>
		///         Windows 95/98/Me: The directory listing displays short filenames (the 8.3 form). You can use the or functions to get the corresponding long
		///         filename.
		///     </para>
		///     <para>
		///         Windows 95/98/Me: DlgDirListW is supported by the Microsoft Layer for Unicode. To use this, you must add certain files to your
		///         application, as outlined in Microsoft Layer for Unicode on Windows Me/98/95 Systems.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DlgDirList")]
		public static extern int DlgDirList([In] IntPtr hDlg, IntPtr lpPathSpec, int nIDListBox, int nIDStaticPath, uint uFileType);

		/// <summary>Destroys the specified menu and frees any memory that the menu occupies.</summary>
		/// <param name="hMenu">A handle to the menu to be destroyed.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Before closing, an application must use the <see cref="DestroyMenu" /> function to destroy a menu not assigned to a window. A menu that is
		///         assigned to a window is automatically destroyed when the application closes.
		///     </para>
		///     <para>
		///         <see cref="DestroyMenu" /> is recursive, that is, it will destroy the menu and all its submenus.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DestroyMenu")]
		public static extern bool DestroyMenu([In] IntPtr hMenu);

		/// <summary>Destroys an icon and frees any memory the icon occupied.</summary>
		/// <param name="hIcon">A handle to the icon to be destroyed. The icon must not be in use.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     It is only necessary to call <see cref="DestroyIcon" /> for icons and cursors created with the following functions:
		///     <see cref="CreateIconFromResourceEx" /> (if called without the <see cref="LR_SHARED" /> flag), <see cref="CreateIconIndirect" />, and
		///     <see cref="CopyIcon" />. Do not use this function to destroy a shared icon. A shared icon is valid as long as the module from which it was loaded
		///     remains in memory. The following functions obtain a shared icon.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DestroyIcon")]
		public static extern bool DestroyIcon([In] IntPtr hIcon);

		/// <summary>
		///     Calls the default dialog box window procedure to provide default processing for any window messages that a dialog box with a private window class
		///     does not process.
		/// </summary>
		/// <param name="hDlg">A handle to the dialog box.</param>
		/// <param name="Msg">The message.</param>
		/// <param name="wParam">Additional message-specific information.</param>
		/// <param name="lParam">Additional message-specific information.</param>
		/// <returns>The return value specifies the result of the message processing and depends on the message sent.</returns>
		/// <remarks>
		///     <para>
		///         The <see cref="DefDlgProc" /> function is the window procedure for the predefined class of dialog box. This procedure provides internal
		///         processing for the dialog box by forwarding messages to the dialog box procedure and carrying out default processing for any messages that
		///         the dialog box procedure returns as FALSE. Applications that create custom window procedures for their custom dialog boxes often use
		///         <see cref="DefDlgProc" /> instead of the <see cref="DefWindowProc" /> function to carry out default message processing.
		///     </para>
		///     <para>
		///         Applications create custom dialog box classes by filling a <see cref="WNDCLASS" /> structure with appropriate information and registering the
		///         class with the <see cref="RegisterClass" /> function. Some applications fill the structure by using the <see cref="GetClassInfo" /> function,
		///         specifying the name of the predefined dialog box. In such cases, the applications modify at least the <see cref="WNDCLASS.lpszClassName" /> member
		///         before registering. In all cases, the <see cref="WNDCLASS.cbWndExtra" /> member of <see cref="WNDCLASS" /> for a custom dialog box class must be set
		///         to at least <see cref="DLGWINDOWEXTRA" />.
		///     </para>
		///     <para>
		///         The <see cref="DefDlgProc" /> function must not be called by a dialog box procedure; doing so results in recursive execution.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.SysInt)]
		[DllImport("user32.dll", EntryPoint = "DefDlgProc")]
		public static extern int DefDlgProc(
			[In] IntPtr hDlg, uint Msg, [MarshalAs(UnmanagedType.SysUInt)] uint wParam, [MarshalAs(UnmanagedType.SysInt)] int lParam);

		/// <summary>
		///     Creates a new shape for the system caret and assigns ownership of the caret to the specified window. The caret shape can be a line, a block, or a
		///     bitmap.
		/// </summary>
		/// <param name="hWnd">A handle to the window that owns the caret.</param>
		/// <param name="hBitmap">
		///     <para>
		///         A handle to the bitmap that defines the caret shape. If this parameter is NULL, the caret is solid. If this parameter is (HBITMAP) 1, the
		///         caret is gray. If this parameter is a bitmap handle, the caret is the specified bitmap. The bitmap handle must have been created by the
		///         <see cref="CreateBitmap" />, <see cref="CreateDIBitmap" />, or <see cref="LoadBitmap" /> function.
		///     </para>
		///     <para>
		///         If <paramref name="hBitmap" /> is a bitmap handle, <see cref="CreateCaret" /> ignores the <paramref name="nWidth" /> and
		///         <paramref name="nHeight" /> parameters; the bitmap defines its own width and height.
		///     </para>
		/// </param>
		/// <param name="nWidth">
		///     The width of the caret, in logical units. If this parameter is zero, the width is set to the system-defined window border width. If
		///     <paramref name="hBitmap" /> is a bitmap handle, <see cref="CreateCaret" /> ignores this parameter.
		/// </param>
		/// <param name="nHeight">
		///     The height of the caret, in logical units. If this parameter is zero, the height is set to the system-defined window border height. If
		///     <paramref name="hBitmap" /> is a bitmap handle, <see cref="CreateCaret" /> ignores this parameter.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <paramref name="nWidth" /> and <paramref name="nHeight" /> parameters specify the caret's width and height, in logical units; the exact
		///         width and height, in pixels, depend on the window's mapping mode.
		///     </para>
		///     <para>
		///         <see cref="CreateCaret" /> automatically destroys the previous caret shape, if any, regardless of the window that owns the caret. The caret
		///         is hidden until the application calls the <see cref="ShowCaret" /> function to make the caret visible.
		///     </para>
		///     <para>
		///         The system provides one caret per queue. A window should create a caret only when it has the keyboard focus or is active. The window should
		///         destroy the caret before losing the keyboard focus or becoming inactive.
		///     </para>
		///     <para>
		///         You can retrieve the width or height of the system's window border by using the <see cref="GetSystemMetrics" /> function, specifying the
		///         <see cref="SM.SM_CXBORDER" /> and <see cref="SM.SM_CYBORDER" /> values. Using the window border width or height guarantees that the caret will be
		///         visible on a high-resolution screen.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "CreateCaret")]
		public static extern bool CreateCaret([In] IntPtr hWnd, [In] IntPtr hBitmap, int nWidth, int nHeight);

		/// <summary>Minimizes (but does not destroy) the specified window.</summary>
		/// <param name="hWnd">A handle to the window to be minimized.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     To destroy a window, an application must use the <see cref="DestroyWindow" /> function.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "CloseWindow")]
		public static extern bool CloseWindow([In] IntPtr hWnd);

		/// <summary>
		///     Retrieves the pointer to the preceding character in a string. This function can handle strings consisting of either single- or multi-byte
		///     characters.
		/// </summary>
		/// <param name="CodePage">
		///     <para>
		///         The identifier of the code page to use to check lead-byte ranges. Can be one of the code-page values provided in Code Page Identifiers, or
		///         one of the following predefined values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>CP_ACP 0</term>
		///             <description>Use system default ANSI code page.</description>
		///         </item>
		///         <item>
		///             <term>CP_MACCP 2</term>
		///             <description>Use the system default Macintosh code page.</description>
		///         </item>
		///         <item>
		///             <term>CP_OEMCP 1</term>
		///             <description>Use system default OEM code page.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="lpStart">The beginning of the string.</param>
		/// <param name="lpCurrentChar">A character in a null-terminated string.</param>
		/// <param name="dwFlags">This parameter is reserved and must be zero.</param>
		/// <returns>
		///     The return value is a pointer to the preceding character in the string, or to the first character in the string if the
		///     <paramref name="lpCurrentChar" /> parameter equals the <paramref name="lpStart" /> parameter.
		/// </returns>
		/// <remarks>
		///     CharPrevExA specifies a code-page to use, whereas <see cref="CharPrev" /> (if called as an ANSI function) uses the system default
		///     code-page.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.LPStr)]
		[DllImport("user32.dll", EntryPoint = "CharPrevEx")]
		public static extern string CharPrevEx(
			CP CodePage, [In] string lpStart, [In] [MarshalAs(UnmanagedType.LPStr)] string lpCurrentChar, uint dwFlags);

		/// <summary>
		///     Retrieves a pointer to the next character in a string. This function can handle strings consisting of either single- or multi-byte
		///     characters.
		/// </summary>
		/// <param name="lpsz">A character in a null-terminated string.</param>
		/// <returns>
		///     <para>The return value is a pointer to the next character in the string, or to the terminating null character if at the end of the string.</para>
		///     <para>
		///         If <paramref name="lpsz" /> points to the terminating null character, the return value is equal to <paramref name="lpsz" />.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         When called as an ANSI function, <see cref="CharNext" /> uses the system default code-page, whereas <see cref="CharNextExA" /> specifies a
		///         code-page to use.
		///     </para>
		///     <para>
		///         This function works with default "user" expectations of characters when dealing with diacritics. For example: A string that contains U+0061
		///         U+030a "LATIN SMALL LETTER A" + COMBINING RING ABOVE" — which looks like "å", will advance two code points, not one. A string that contains
		///         U+0061 U+0301 U+0302 U+0303 U+0304 — which looks like "a´^~¯", will advance five code points, not one, and so on.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.LPStr)]
		[DllImport("user32.dll", EntryPoint = "CharNextEx")]
		public static extern string CharNextEx(CP CodePage, [In] [MarshalAs(UnmanagedType.LPStr)] string lpCurrentChar, uint dwFlags);

		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "ChangeMenu")]
		public static extern bool ChangeMenu([In] IntPtr hMenu, uint cmd, [In] string lpszNewItem, uint cmdInsert, MF flags);

		/// <summary>
		///     Appends a new item to the end of the specified menu bar, drop-down menu, submenu, or shortcut menu. You can use this function to specify the
		///     content, appearance, and behavior of the menu item.
		/// </summary>
		/// <param name="hMenu">A handle to the menu bar, drop-down menu, submenu, or shortcut menu to be changed.</param>
		/// <param name="uFlags">
		///     <para>Controls the appearance and behavior of the new menu item. This parameter can be a combination of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BITMAP 0x00000004L</term>
		///             <description>
		///                 Uses a bitmap as the menu item. The <paramref name="lpNewItem" /> parameter contains a handle to the bitmap.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_CHECKED 0x00000008L</term>
		///             <description>
		///                 Places a check mark next to the menu item. If the application provides check-mark bitmaps (see <see cref="SetMenuItemBitmaps" />,
		///                 this flag displays the check-mark bitmap next to the menu item.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_DISABLED 0x00000002L</term>
		///             <description>Disables the menu item so that it cannot be selected, but the flag does not gray it.</description>
		///         </item>
		///         <item>
		///             <term>MF_ENABLED 0x00000000L</term>
		///             <description>Enables the menu item so that it can be selected, and restores it from its grayed state.</description>
		///         </item>
		///         <item>
		///             <term>MF_GRAYED 0x00000001L</term>
		///             <description>Disables the menu item and grays it so that it cannot be selected.</description>
		///         </item>
		///         <item>
		///             <term>MF_MENUBARBREAK 0x00000020L</term>
		///             <description>
		///                 Functions the same as the <see cref="MF.MF_MENUBREAK" /> flag for a menu bar. For a drop-down menu, submenu, or shortcut menu, the new
		///                 column is separated from the old column by a vertical line.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_MENUBREAK 0x00000040L</term>
		///             <description>
		///                 Places the item on a new line (for a menu bar) or in a new column (for a drop-down menu, submenu, or shortcut menu) without
		///                 separating columns.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_OWNERDRAW 0x00000100L</term>
		///             <description>
		///                 Specifies that the item is an owner-drawn item. Before the menu is displayed for the first time, the window that owns the menu
		///                 receives a <see cref="WM.WM_MEASUREITEM" /> message to retrieve the width and height of the menu item. The
		///                 <see cref="WM.WM_DRAWITEM" /> message is then sent to the window procedure of the owner window whenever the appearance of the menu
		///                 item must be updated.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_POPUP 0x00000010L</term>
		///             <description>
		///                 Specifies that the menu item opens a drop-down menu or submenu. The <paramref name="uIDNewItem" /> parameter specifies a handle to
		///                 the drop-down menu or submenu. This flag is used to add a menu name to a menu bar, or a menu item that opens a submenu to a drop-down
		///                 menu, submenu, or shortcut menu.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_SEPARATOR 0x00000800L</term>
		///             <description>
		///                 Draws a horizontal dividing line. This flag is used only in a drop-down menu, submenu, or shortcut menu. The line cannot be grayed,
		///                 disabled, or highlighted. The <paramref name="lpNewItem" /> and <paramref name="uIDNewItem" /> parameters are ignored.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_STRING 0x00000000L</term>
		///             <description>
		///                 Specifies that the menu item is a text string; the <paramref name="lpNewItem" /> parameter is a pointer to the string.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_UNCHECKED 0x00000000L</term>
		///             <description>
		///                 Does not place a check mark next to the item (default). If the application supplies check-mark bitmaps (see
		///                 <see cref="SetMenuItemBitmaps" />), this flag displays the clear bitmap next to the menu item.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="uIDNewItem">
		///     The identifier of the new menu item or, if the <paramref name="uFlags" /> parameter is set to <see cref="MF.MF_POPUP" />, a handle to the drop-down
		///     menu or submenu.
		/// </param>
		/// <param name="lpNewItem">
		///     <para>
		///         The content of the new menu item. The interpretation of <paramref name="lpNewItem" /> depends on whether the <paramref name="uFlags" />
		///         parameter includes the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BITMAP 0x00000004L</term>
		///             <description>Contains a bitmap handle.</description>
		///         </item>
		///         <item>
		///             <term>MF_OWNERDRAW 0x00000100L</term>
		///             <description>
		///                 Contains an application-supplied value that can be used to maintain additional data related to the menu item. The value is in the
		///                 <see cref="itemData" /> member of the structure pointed to by the <paramref name="lParam" /> parameter of the
		///                 <see cref="WM.WM_MEASUREITEM" /> or <see cref="WM.WM_DRAWITEM" /> message sent when the menu is created or its appearance is updated.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_STRING 0x00000000L</term>
		///             <description>Contains a pointer to a null-terminated string.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call
		///     GetLastError.
		/// </returns>
		/// <remarks>
		///     <para>
		///         The application must call the <see cref="DrawMenuBar" /> function whenever a menu changes, whether the menu is in a displayed window.
		///     </para>
		///     <para>
		///         To get keyboard accelerators to work with bitmap or owner-drawn menu items, the owner of the menu must process the
		///         <see cref="WM.WM_MENUCHAR" /> message. For more information, see Owner-Drawn Menus and the WM_MENUCHAR Message.
		///     </para>
		///     <para>The following groups of flags cannot be used together:</para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "AppendMenu")]
		public static extern bool AppendMenu([In] IntPtr hMenu, MF uFlags, [MarshalAs(UnmanagedType.SysUInt)] uint uIDNewItem, [In] string lpNewItem);

		/// <summary>
		///     <para>
		///         Writes formatted data to the specified buffer using a pointer to a list of arguments. The items pointed to by the argument list are converted
		///         and copied to an output buffer according to the corresponding format specification in the format-control string. The function appends a
		///         terminating null character to the characters it writes, but the return value does not include the terminating null character in its character
		///         count.
		///     </para>
		///     <para>
		///         Warning:  Do not use. Consider using one of the following functions instead: <see cref="StringCbVPrintf" />,
		///         <see cref="StringCbVPrintfEx" />, <see cref="StringCchVPrintf" />, or <see cref="StringCchVPrintfEx" />. See Security Considerations.
		///     </para>
		/// </summary>
		/// <param name="lpOutput">The buffer that is to receive the formatted output. The maximum size of the buffer is 1,024 bytes.</param>
		/// <param name="lpFmt">
		///     The format-control specifications. In addition to ordinary ASCII characters, a format specification for each argument appears in this string. For
		///     more information about the format specification, see the wsprintf function.
		/// </param>
		/// <param name="arglist">
		///     Each element of this list specifies an argument for the format-control string. The number, type, and interpretation of the arguments depend on
		///     the corresponding format-control specifications in the <paramref name="lpFmt" /> parameter.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the number of characters stored in the buffer, not counting the terminating null character.</para>
		///     <para>
		///         If the function fails, the return value is less than the length of the expected output. To get extended error information, call
		///         GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     The function copies the format-control string into the output buffer character by character, starting with the first character in the string.
		///     When it encounters a format specification in the string, the function retrieves the value of the next available argument (starting with the first
		///     argument in the list), converts that value into the specified format, and copies the result to the output buffer. The function continues to copy
		///     characters and expand format specifications in this way until it reaches the end of the format-control string. If there are more arguments than
		///     format specifications, the extra arguments are ignored. If there are not enough arguments for all of the format specifications, the results are
		///     undefined.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "wvsprintf")]
		public static extern int wvsprintf(
			[Out] StringBuilder lpOutput, [In] string lpFmt, [In] [MarshalAs(UnmanagedType.LPStr)] string arglist);

		/// <summary>
		///     <para>
		///         [This function has been superseded by the <see cref="VkKeyScanEx" /> function. You can still use <see cref="VkKeyScan" />, however, if you do
		///         not need to specify a keyboard layout.]
		///     </para>
		///     <para>Translates a character to the corresponding virtual-key code and shift state for the current keyboard.</para>
		/// </summary>
		/// <param name="ch">The character to be translated into a virtual-key code.</param>
		/// <returns>
		///     If the function succeeds, the low-order byte of the return value contains the virtual-key code and the high-order byte contains the shift state,
		///     which can be a combination of the following flag bits.
		/// </returns>
		/// <remarks>
		///     <para>
		///         For keyboard layouts that use the right-hand ALT key as a shift key (for example, the French keyboard layout), the shift state is represented
		///         by the value 6, because the right-hand ALT key is converted internally into CTRL+ALT.
		///     </para>
		///     <para>
		///         Translations for the numeric keypad (VK_NUMPAD0 through VK_DIVIDE) are ignored. This function is intended to translate characters into
		///         keystrokes from the main keyboard section only. For example, the character "7" is translated into VK_7, not VK_NUMPAD7.
		///     </para>
		///     <para>
		///         <see cref="VkKeyScan" /> is used by applications that send characters by using the <see cref="WM.WM_KEYUP" /> and
		///         <see cref="WM.WM_KEYDOWN" /> messages.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "VkKeyScan")]
		public static extern short VkKeyScan(char ch);

		/// <summary>Sets the specified window's show state.</summary>
		/// <param name="hWnd">A handle to the window.</param>
		/// <param name="nCmdShow">
		///     <para>
		///         Controls how the window is to be shown. This parameter is ignored the first time an application calls <see cref="ShowWindow" />, if the
		///         program that launched the application provides a <see cref="STARTUPINFO" /> structure. Otherwise, the first time <see cref="ShowWindow" /> is
		///         called, the value should be the value obtained by the <see cref="WinMain" /> function in its <paramref name="nCmdShow" /> parameter. In
		///         subsequent calls, this parameter can be one of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>SW_FORCEMINIMIZE 11</term>
		///             <description>
		///                 Minimizes a window, even if the thread that owns the window is not responding. This flag should only be used when minimizing windows
		///                 from a different thread.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SW_HIDE 0</term>
		///             <description>Hides the window and activates another window.</description>
		///         </item>
		///         <item>
		///             <term>SW_MAXIMIZE 3</term>
		///             <description>Maximizes the specified window.</description>
		///         </item>
		///         <item>
		///             <term>SW_MINIMIZE 6</term>
		///             <description>Minimizes the specified window and activates the next top-level window in the Z order.</description>
		///         </item>
		///         <item>
		///             <term>SW_RESTORE 9</term>
		///             <description>
		///                 Activates and displays the window. If the window is minimized or maximized, the system restores it to its original size and position.
		///                 An application should specify this flag when restoring a minimized window.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SW_SHOW 5</term>
		///             <description>Activates the window and displays it in its current size and position.</description>
		///         </item>
		///         <item>
		///             <term>SW_SHOWDEFAULT 10</term>
		///             <description>
		///                 Sets the show state based on the SW_ value specified in the <see cref="STARTUPINFO" /> structure passed to the
		///                 <see cref="CreateProcess" /> function by the program that started the application.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SW_SHOWMAXIMIZED 3</term>
		///             <description>Activates the window and displays it as a maximized window.</description>
		///         </item>
		///         <item>
		///             <term>SW_SHOWMINIMIZED 2</term>
		///             <description>Activates the window and displays it as a minimized window.</description>
		///         </item>
		///         <item>
		///             <term>SW_SHOWMINNOACTIVE 7</term>
		///             <description>
		///                 Displays the window as a minimized window. This value is similar to <see cref="SW_SHOWMINIMIZED" />, except the window is not
		///                 activated.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SW_SHOWNA 8</term>
		///             <description>
		///                 Displays the window in its current size and position. This value is similar to <see cref="SW_SHOW" />, except that the window is not
		///                 activated.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SW_SHOWNOACTIVATE 4</term>
		///             <description>
		///                 Displays a window in its most recent size and position. This value is similar to <see cref="SW_SHOWNORMAL" />, except that the window
		///                 is not activated.
		///             </description>
		///         </item>
		///         <item>
		///             <term>SW_SHOWNORMAL 1</term>
		///             <description>
		///                 Activates and displays a window. If the window is minimized or maximized, the system restores it to its original size and position.
		///                 An application should specify this flag when displaying the window for the first time.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the window was previously visible, the return value is nonzero.</para>
		///     <para>If the window was previously hidden, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         To perform certain special effects when showing or hiding a window, use <see cref="AnimateWindow" />.
		///     </para>
		///     <para>
		///         The first time an application calls <see cref="ShowWindow" />, it should use the <see cref="WinMain" /> function's
		///         <paramref name="nCmdShow" /> parameter as its <paramref name="nCmdShow" /> parameter. Subsequent calls to <see cref="ShowWindow" /> must use
		///         one of the values in the given list, instead of the one specified by the <see cref="WinMain" /> function's <paramref name="nCmdShow" />
		///         parameter.
		///     </para>
		///     <para>
		///         As noted in the discussion of the <paramref name="nCmdShow" /> parameter, the <paramref name="nCmdShow" /> value is ignored in the first call
		///         to <see cref="ShowWindow" /> if the program that launched the application specifies startup information in the structure. In this case,
		///         <see cref="ShowWindow" /> uses the information specified in the <see cref="STARTUPINFO" /> structure to show the window. On subsequent calls,
		///         the application must call <see cref="ShowWindow" /> with <paramref name="nCmdShow" /> set to <see cref="SW_SHOWDEFAULT" /> to use the startup
		///         information provided by the program that launched the application. This behavior is designed for the following situations:
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "ShowWindow")]
		public static extern bool ShowWindow([In] IntPtr hWnd, int nCmdShow);

		/// <summary>Displays or hides the cursor.</summary>
		/// <param name="bShow">
		///     If <paramref name="bShow" /> is TRUE, the display count is incremented by one. If <paramref name="bShow" /> is FALSE, the display count is
		///     decremented by one.
		/// </param>
		/// <returns>The return value specifies the new display counter.</returns>
		/// <remarks>
		///     This function sets an internal display counter that determines whether the cursor should be displayed. The cursor is displayed only if the
		///     display count is greater than or equal to 0. If a mouse is installed, the initial display count is 0. If no mouse is installed, the display count
		///     is –1.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "ShowCursor")]
		public static extern int ShowCursor([MarshalAs(UnmanagedType.Bool)] bool bShow);

		/// <summary>
		///     <para>
		///         Sets the mouse capture to the specified window belonging to the current thread.<see cref="SetCapture" /> captures mouse input either when the
		///         mouse is over the capturing window, or when the mouse button was pressed while the mouse was over the capturing window and the button is
		///         still down. Only one window at a time can capture the mouse.
		///     </para>
		///     <para>
		///         If the mouse cursor is over a window created by another thread, the system will direct mouse input to the specified window only if a mouse
		///         button is down.
		///     </para>
		/// </summary>
		/// <param name="hWnd">A handle to the window in the current thread that is to capture the mouse.</param>
		/// <returns>The return value is a handle to the window that had previously captured the mouse. If there is no such window, the return value is NULL.</returns>
		/// <remarks>
		///     <para>
		///         Only the foreground window can capture the mouse. When a background window attempts to do so, the window receives messages only for mouse
		///         events that occur when the cursor hot spot is within the visible portion of the window. Also, even if the foreground window has captured the
		///         mouse, the user can still click another window, bringing it to the foreground.
		///     </para>
		///     <para>
		///         When the window no longer requires all mouse input, the thread that created the window should call the <see cref="ReleaseCapture" /> function
		///         to release the mouse.
		///     </para>
		///     <para>This function cannot be used to capture mouse input meant for another process.</para>
		///     <para>When the mouse is captured, menu hotkeys and other keyboard accelerators do not work.</para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetCapture")]
		public static extern IntPtr SetCapture([In] IntPtr hWnd);

		/// <summary>
		///     Deletes a menu item or detaches a submenu from the specified menu. If the menu item opens a drop-down menu or submenu, <see cref="RemoveMenu" />
		///     does not destroy the menu or its handle, allowing the menu to be reused. Before this function is called, the <see cref="GetSubMenu" /> function
		///     should retrieve a handle to the drop-down menu or submenu.
		/// </summary>
		/// <param name="hMenu">A handle to the menu to be changed.</param>
		/// <param name="uPosition">
		///     The menu item to be deleted, as determined by the <paramref name="uFlags" /> parameter.
		/// </param>
		/// <param name="uFlags">
		///     <para>
		///         Indicates how the <paramref name="uPosition" /> parameter is interpreted. This parameter must be one of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BYCOMMAND 0x00000000L</term>
		///             <description>
		///                 Indicates that <paramref name="uPosition" /> gives the identifier of the menu item. If neither the <see cref="MF.MF_BYCOMMAND" /> nor
		///                 <see cref="MF.MF_BYPOSITION" /> flag is specified, the <see cref="MF.MF_BYCOMMAND" /> flag is the default flag.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_BYPOSITION 0x00000400L</term>
		///             <description>
		///                 Indicates that <paramref name="uPosition" /> gives the zero-based relative position of the menu item.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     The application must call the <see cref="DrawMenuBar" /> function whenever a menu changes, whether the menu is in a displayed window.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "RemoveMenu")]
		public static extern bool RemoveMenu([In] IntPtr hMenu, uint uPosition, MF uFlags);

		/// <summary>
		///     The <see cref="OffsetRect" /> function moves the specified rectangle by the specified offsets.
		/// </summary>
		/// <param name="lprc">
		///     Pointer to a <see cref="RECT" /> structure that contains the logical coordinates of the rectangle to be moved.
		/// </param>
		/// <param name="dx">Specifies the amount to move the rectangle left or right. This parameter must be a negative value to move the rectangle to the left.</param>
		/// <param name="dy">Specifies the amount to move the rectangle up or down. This parameter must be a negative value to move the rectangle up.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all
		///     rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used
		///     determine the units of measure.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "OffsetRect")]
		public static extern bool OffsetRect(ref RECT lprc, int dx, int dy);

		/// <summary>
		///     <para>Translates a string from the OEM-defined character set into either an ANSI or a wide-character string.</para>
		///     <para>
		///         Warning:  Do not use. See Security Considerations.
		///     </para>
		/// </summary>
		/// <param name="lpszSrc">A null-terminated string of characters from the OEM-defined character set.</param>
		/// <param name="lpszDst">
		///     The destination buffer, which receives the translated string. If the <see cref="OemToChar" /> function is being used as an ANSI function, the
		///     string can be translated in place by setting the <paramref name="lpszDst" /> parameter to the same address as the <paramref name="lpszSrc" />
		///     parameter. This cannot be done if <see cref="OemToChar" /> is being used as a wide-character function.
		/// </param>
		/// <returns>
		///     The return value is always nonzero except when you pass the same address to <paramref name="lpszSrc" /> and <paramref name="lpszDst" /> in the
		///     wide-character version of the function. In this case the function returns zero and GetLastError returns <see cref="ERROR_INVALID_ADDRESS" />.
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "OemToChar")]
		public static extern bool OemToChar([In] [MarshalAs(UnmanagedType.LPStr)] string lpszSrc, [Out] StringBuilder lpszDst);

		/// <summary>
		///     Maps OEMASCII codes 0 through 0x0FF into the OEM scan codes and shift states. The function provides information that allows a program to send OEM
		///     text to another program by simulating keyboard input.
		/// </summary>
		/// <param name="wOemChar">The ASCII value of the OEM character.</param>
		/// <returns>
		///     The low-order word of the return value contains the scan code of the OEM character, and the high-order word contains the shift state, which can
		///     be a combination of the following bits.
		/// </returns>
		/// <remarks>
		///     <para>
		///         This function does not provide translations for characters that require CTRL+ALT or dead keys. Characters not translated by this function
		///         must be copied by simulating input using the ALT+ keypad mechanism. The NUMLOCK key must be off.
		///     </para>
		///     <para>
		///         This function does not provide translations for characters that cannot be typed with one keystroke using the current keyboard layout, such as
		///         characters with diacritics requiring dead keys. Characters not translated by this function may be simulated using the ALT+ keypad mechanism.
		///         The NUMLOCK key must be on.
		///     </para>
		///     <para>
		///         This function is implemented using the <see cref="VkKeyScan" /> function.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "OemKeyScan")]
		public static extern uint OemKeyScan(ushort wOemChar);

		/// <summary>
		///     Changes the position and dimensions of the specified window. For a top-level window, the position and dimensions are relative to the upper-left
		///     corner of the screen. For a child window, they are relative to the upper-left corner of the parent window's client area.
		/// </summary>
		/// <param name="hWnd">A handle to the window.</param>
		/// <param name="X">The new position of the left side of the window.</param>
		/// <param name="Y">The new position of the top of the window.</param>
		/// <param name="nWidth">The new width of the window.</param>
		/// <param name="nHeight">The new height of the window.</param>
		/// <param name="bRepaint">
		///     Indicates whether the window is to be repainted. If this parameter is TRUE, the window receives a message. If the parameter is FALSE, no
		///     repainting of any kind occurs. This applies to the client area, the nonclient area (including the title bar and scroll bars), and any part of the
		///     parent window uncovered as a result of moving a child window.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If the <paramref name="bRepaint" /> parameter is TRUE, the system sends the <see cref="WM.WM_PAINT" /> message to the window procedure
		///         immediately after moving the window (that is, the <see cref="MoveWindow" /> function calls the <see cref="UpdateWindow" /> function). If
		///         <paramref name="bRepaint" /> is FALSE, the application must explicitly invalidate or redraw any parts of the window and parent window that
		///         need redrawing.
		///     </para>
		///     <para>
		///         <see cref="MoveWindow" /> sends the <see cref="WM.WM_WINDOWPOSCHANGING" />, <see cref="WM.WM_WINDOWPOSCHANGED" />, <see cref="WM.WM_MOVE" />,
		///         <see cref="WM.WM_SIZE" />, and <see cref="WM.WM_NCCALCSIZE" /> messages to the window.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "MoveWindow")]
		public static extern bool MoveWindow([In] IntPtr hWnd, int X, int Y, int nWidth, int nHeight, [MarshalAs(UnmanagedType.Bool)] bool bRepaint);

		/// <summary>Loads an icon, cursor, animated cursor, or bitmap.</summary>
		/// <param name="hinst">
		///     <para>
		///         A handle to the module of either a DLL or executable (.exe) that contains the image to be loaded. For more information, see
		///         GetModuleHandle. Note that as of 32-bit Windows, an instance handle (<see cref="HINSTANCE" />), such as the application
		///         instance handle exposed by system function call of <see cref="WinMain" />, and a module handle (<see cref="HMODULE" />) are the same thing.
		///     </para>
		///     <para>To load an OEM image, set this parameter to NULL.</para>
		///     <para>To load a stand-alone resource (icon, cursor, or bitmap file)—for example, c:\myimage.bmp—set this parameter to NULL.</para>
		/// </param>
		/// <param name="lpszName">
		///     <para>
		///         The image to be loaded. If the <paramref name="hinst" /> parameter is non-NULL and the <paramref name="fuLoad" /> parameter omits
		///         <see cref="LR_LOADFROMFILE" />, <paramref name="lpszName" /> specifies the image resource in the <paramref name="hinst" /> module. If the
		///         image resource is to be loaded by name from the module, the <paramref name="lpszName" /> parameter is a pointer to a null-terminated string
		///         that contains the name of the image resource. If the image resource is to be loaded by ordinal from the module, use the
		///         MAKEINTRESOURCE macro to convert the image ordinal into a form that can be passed to the <see cref="LoadImage" /> function.
		///         For more information, see the Remarks section below.
		///     </para>
		///     <para>
		///         If the <paramref name="hinst" /> parameter is NULL and the <paramref name="fuLoad" /> parameter omits the <see cref="LR_LOADFROMFILE" />
		///         value, the <paramref name="lpszName" /> specifies the OEM image to load. The OEM image identifiers are defined in Winuser.h and have the
		///         following prefixes.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>OBM_</term>
		///             <description>OEM bitmaps</description>
		///         </item>
		///         <item>
		///             <term>OIC_</term>
		///             <description>OEM icons</description>
		///         </item>
		///         <item>
		///             <term>OCR_</term>
		///             <description>OEM cursors</description>
		///         </item>
		///     </list>
		///     <para>
		///         To pass these constants to the <see cref="LoadImage" /> function, use the MAKEINTRESOURCE macro. For example, to load the
		///         <see cref="OCR_NORMAL" /> cursor, pass MAKEINTRESOURCE(OCR_NORMAL) as the <paramref name="lpszName" /> parameter, NULL as the
		///         <paramref name="hinst" /> parameter, and <see cref="LR_SHARED" /> as one of the flags to the <paramref name="fuLoad" /> parameter.
		///     </para>
		///     <para>
		///         If the <paramref name="fuLoad" /> parameter includes the <see cref="LR_LOADFROMFILE" /> value, <paramref name="lpszName" /> is the name of
		///         the file that contains the stand-alone resource (icon, cursor, or bitmap file). Therefore, set <paramref name="hinst" /> to NULL.
		///     </para>
		/// </param>
		/// <param name="uType">
		///     <para>The type of image to be loaded. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>IMAGE_BITMAP 0</term>
		///             <description>Loads a bitmap.</description>
		///         </item>
		///         <item>
		///             <term>IMAGE_CURSOR 2</term>
		///             <description>Loads a cursor.</description>
		///         </item>
		///         <item>
		///             <term>IMAGE_ICON 1</term>
		///             <description>Loads an icon.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="cxDesired">
		///     The width, in pixels, of the icon or cursor. If this parameter is zero and the <paramref name="fuLoad" /> parameter is
		///     <see cref="LR_DEFAULTSIZE" />, the function uses the <see cref="SM.SM_CXICON" /> or <see cref="SM.SM_CXCURSOR" /> system metric value to set the width.
		///     If this parameter is zero and <see cref="LR_DEFAULTSIZE" /> is not used, the function uses the actual resource width.
		/// </param>
		/// <param name="cyDesired">
		///     The height, in pixels, of the icon or cursor. If this parameter is zero and the <paramref name="fuLoad" /> parameter is
		///     <see cref="LR_DEFAULTSIZE" />, the function uses the <see cref="SM.SM_CYICON" /> or <see cref="SM.SM_CYCURSOR" /> system metric value to set the
		///     height. If this parameter is zero and <see cref="LR_DEFAULTSIZE" /> is not used, the function uses the actual resource height.
		/// </param>
		/// <param name="fuLoad">
		///     <para>This parameter can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>LR_CREATEDIBSECTION 0x00002000</term>
		///             <description>
		///                 When the <paramref name="uType" /> parameter specifies <see cref="IMAGE_BITMAP" />, causes the function to return a DIB section
		///                 bitmap rather than a compatible bitmap. This flag is useful for loading a bitmap without mapping it to the colors of the display
		///                 device.
		///             </description>
		///         </item>
		///         <item>
		///             <term>LR_DEFAULTCOLOR 0x00000000</term>
		///             <description>
		///                 The default flag; it does nothing. All it means is "not <see cref="LR_MONOCHROME" />".
		///             </description>
		///         </item>
		///         <item>
		///             <term>LR_DEFAULTSIZE 0x00000040</term>
		///             <description>
		///                 Uses the width or height specified by the system metric values for cursors or icons, if the <paramref name="cxDesired" /> or
		///                 <paramref name="cyDesired" /> values are set to zero. If this flag is not specified and <paramref name="cxDesired" /> and
		///                 <paramref name="cyDesired" /> are set to zero, the function uses the actual resource size. If the resource contains multiple images,
		///                 the function uses the size of the first image.
		///             </description>
		///         </item>
		///         <item>
		///             <term>LR_LOADFROMFILE 0x00000010</term>
		///             <description>
		///                 Loads the stand-alone image from the file specified by <paramref name="lpszName" /> (icon, cursor, or bitmap file).
		///             </description>
		///         </item>
		///         <item>
		///             <term>LR_LOADMAP3DCOLORS 0x00001000</term>
		///             <description>
		///                 <para>Searches the color table for the image and replaces the following shades of gray with the corresponding 3-D color.</para>
		///                 <para>Do not use this option if you are loading a bitmap with a color depth greater than 8bpp.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>LR_LOADTRANSPARENT 0x00000020</term>
		///             <description>
		///                 <para>
		///                     Retrieves the color value of the first pixel in the image and replaces the corresponding entry in the color table with the
		///                     default window color (<see cref="COLOR.COLOR_WINDOW" />). All pixels in the image that use that entry become the default window color.
		///                     This value applies only to images that have corresponding color tables.
		///                 </para>
		///                 <para>Do not use this option if you are loading a bitmap with a color depth greater than 8bpp.</para>
		///                 <para>
		///                     If <paramref name="fuLoad" /> includes both the <see cref="LR_LOADTRANSPARENT" /> and <see cref="LR_LOADMAP3DCOLORS" /> values,
		///                     <see cref="LR_LOADTRANSPARENT" /> takes precedence. However, the color table entry is replaced with <see cref="COLOR.COLOR_3DFACE" />
		///                     rather than <see cref="COLOR.COLOR_WINDOW" />.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>LR_MONOCHROME 0x00000001</term>
		///             <description>Loads the image in black and white.</description>
		///         </item>
		///         <item>
		///             <term>LR_SHARED 0x00008000</term>
		///             <description>
		///                 <para>
		///                     Shares the image handle if the image is loaded multiple times. If <see cref="LR_SHARED" /> is not set, a second call to
		///                     <see cref="LoadImage" /> for the same resource will load the image again and return a different handle.
		///                 </para>
		///                 <para>When you use this flag, the system will destroy the resource when it is no longer needed.</para>
		///                 <para>
		///                     Do not use <see cref="LR_SHARED" /> for images that have non-standard sizes, that may change after loading, or that are loaded
		///                     from a file.
		///                 </para>
		///                 <para>
		///                     When loading a system icon or cursor, you must use <see cref="LR_SHARED" /> or the function will fail to load the resource.
		///                 </para>
		///                 <para>This function finds the first image in the cache with the requested resource name, regardless of the size requested.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>LR_VGACOLOR 0x00000080</term>
		///             <description>Uses true VGA colors.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the handle of the newly loaded image.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If <see cref="IS_INTRESOURCE" />(<paramref name="lpszName" />) is TRUE, then <paramref name="lpszName" /> specifies the integer identifier of
		///         the given resource. Otherwise, it is a pointer to a null- terminated string. If the first character of the string is a pound sign (#), then
		///         the remaining characters represent a decimal number that specifies the integer identifier of the resource. For example, the string "#258"
		///         represents the identifier 258.
		///     </para>
		///     <para>
		///         When you are finished using a bitmap, cursor, or icon you loaded without specifying the <see cref="LR_SHARED" /> flag, you can release its
		///         associated memory by calling one of the functions in the following table.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "LoadImage")]
		public static extern IntPtr LoadImage([In] IntPtr hInst, [In] string name, uint type, int cx, int cy, uint fuLoad);

		/// <summary>
		///     The <see cref="InvertRect" /> function inverts a rectangle in a window by performing a logical NOT operation on the color values for each pixel
		///     in the rectangle's interior.
		/// </summary>
		/// <param name="hDC">A handle to the device context.</param>
		/// <param name="lprc">
		///     A pointer to a <see cref="RECT" /> structure that contains the logical coordinates of the rectangle to be inverted.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     On monochrome screens, <see cref="InvertRect" /> makes white pixels black and black pixels white. On color screens, the inversion depends on how
		///     colors are generated for the screen. Calling <see cref="InvertRect" /> twice for the same rectangle restores the display to its previous colors.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "InvertRect")]
		public static extern bool InvertRect([In] IntPtr hDC, [In] ref RECT lprc);

		/// <summary>Retrieves a handle to the drop-down menu or submenu activated by the specified menu item.</summary>
		/// <param name="hMenu">A handle to the menu.</param>
		/// <param name="nPos">The zero-based relative position in the specified menu of an item that activates a drop-down menu or submenu.</param>
		/// <returns>
		///     If the function succeeds, the return value is a handle to the drop-down menu or submenu activated by the menu item. If the menu item does not
		///     activate a drop-down menu or submenu, the return value is NULL.
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetSubMenu")]
		public static extern IntPtr GetSubMenu([In] IntPtr hMenu, int nPos);

		/// <summary>Retrieves a handle to a control in the specified dialog box.</summary>
		/// <param name="hDlg">A handle to the dialog box that contains the control.</param>
		/// <param name="nIDDlgItem">The identifier of the control to be retrieved.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the window handle of the specified control.</para>
		///     <para>
		///         If the function fails, the return value is NULL, indicating an invalid dialog box handle or a nonexistent control. To get extended error
		///         information, call GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     You can use the <see cref="GetDlgItem" /> function with any parent-child window pair, not just with dialog boxes. As long as the
		///     <paramref name="hDlg" /> parameter specifies a parent window and the child window has a unique identifier (as specified by the
		///     <paramref name="hMenu" /> parameter in the CreateWindow or <see cref="CreateWindowEx" /> function that created the child window),
		///     <see cref="GetDlgItem" /> returns a valid handle to the child window.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetDlgItem")]
		public static extern IntPtr GetDlgItem([In] IntPtr hDlg, int nIDDlgItem);

		/// <summary>
		///     Retrieves a handle to the window (if any) that has captured the mouse. Only one window at a time can capture the mouse; this window receives
		///     mouse input whether or not the cursor is within its borders.
		/// </summary>
		/// <returns>
		///     The return value is a handle to the capture window associated with the current thread. If no window in the thread has captured the mouse, the
		///     return value is NULL.
		/// </returns>
		/// <remarks>
		///     <para>
		///         A NULL return value means the current thread has not captured the mouse. However, it is possible that another thread or process has captured
		///         the mouse.
		///     </para>
		///     <para>
		///         To get a handle to the capture window on another thread, use the <see cref="GetGUIThreadInfo" /> function.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetCapture")]
		public static extern IntPtr GetCapture();

		/// <summary>
		///     <para>
		///         Enumerates all entries in the property list of a window by passing them, one by one, to the specified callback function.
		///         <see cref="EnumProps" /> continues until the last entry is enumerated or the callback function returns FALSE.
		///     </para>
		///     <para>
		///         To pass application-defined data to the callback function, use <see cref="EnumPropsEx" /> function.
		///     </para>
		/// </summary>
		/// <param name="hWnd">A handle to the window whose property list is to be enumerated.</param>
		/// <param name="lpEnumFunc">
		///     A pointer to the callback function. For more information about the callback function, see the <see cref="PropEnumProc" /> function.
		/// </param>
		/// <returns>
		///     <para>
		///         The return value specifies the last value returned by the callback function. It is -1 if the function did not find a property for
		///         enumeration.
		///     </para>
		/// </returns>
		/// <remarks>
		///     An application can remove only those properties it has added. It must not remove properties added by other applications or by the system
		///     itself.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "EnumProps")]
		public static extern int EnumProps([In] IntPtr hWnd, PropEnumProc lpEnumFunc);

		/// <summary>
		///     The <see cref="DrawState" /> function displays an image and applies a visual effect to indicate a state, such as a disabled or default state.
		/// </summary>
		/// <param name="hdc">A handle to the device context to draw in.</param>
		/// <param name="hbr">
		///     A handle to the brush used to draw the image, if the state specified by the <paramref name="fuFlags" /> parameter is DSS_MONO. This parameter is
		///     ignored for other states.
		/// </param>
		/// <param name="lpOutputFunc">
		///     A pointer to an application-defined callback function used to render the image. This parameter is required if the image type in
		///     <paramref name="fuFlags" /> is DST_COMPLEX. It is optional and can be NULL if the image type is DST_TEXT. For all other image types, this
		///     parameter is ignored. For more information about the callback function, see the <see cref="DrawStateProc" /> function.
		/// </param>
		/// <param name="lData">Information about the image. The meaning of this parameter depends on the image type.</param>
		/// <param name="wData">
		///     Information about the image. The meaning of this parameter depends on the image type. It is, however, zero extended for use with the
		///     <see cref="DrawStateProc" /> function.
		/// </param>
		/// <param name="x">The horizontal location, in device units, at which to draw the image.</param>
		/// <param name="y">The vertical location, in device units, at which to draw the image.</param>
		/// <param name="cx">
		///     The width of the image, in device units. This parameter is required if the image type is DST_COMPLEX. Otherwise, it can be zero to calculate the
		///     width of the image.
		/// </param>
		/// <param name="cy">
		///     The height of the image, in device units. This parameter is required if the image type is DST_COMPLEX. Otherwise, it can be zero to calculate the
		///     height of the image.
		/// </param>
		/// <param name="fuFlags">
		///     <para>The image type and state. This parameter can be one of the following type values.</para>
		///     <list type="table">
		///         <item>
		///             <term>DST_BITMAP</term>
		///             <description>
		///                 The image is a bitmap. The <paramref name="lData" /> parameter is the bitmap handle. Note that the bitmap cannot already be selected
		///                 into an existing device context.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DST_COMPLEX</term>
		///             <description>
		///                 The image is application defined. To render the image, <see cref="DrawState" /> calls the callback function specified by the
		///                 <paramref name="lpOutputFunc" /> parameter.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DST_ICON</term>
		///             <description>
		///                 The image is an icon. The <paramref name="lData" /> parameter is the icon handle.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DST_PREFIXTEXT</term>
		///             <description>
		///                 The image is text that may contain an accelerator mnemonic. <see cref="DrawState" /> interprets the ampersand (&amp;) prefix
		///                 character as a directive to underscore the character that follows. The <paramref name="lData" /> parameter is a pointer to the
		///                 string, and the <paramref name="wData" /> parameter specifies the length. If <paramref name="wData" /> is zero, the string must be
		///                 null-terminated.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DST_TEXT</term>
		///             <description>
		///                 The image is text. The <paramref name="lData" /> parameter is a pointer to the string, and the <paramref name="wData" /> parameter
		///                 specifies the length. If <paramref name="wData" /> is zero, the string must be null-terminated.
		///             </description>
		///         </item>
		///     </list>
		///     <para>This parameter can also be one of the following state values.</para>
		///     <list type="table">
		///         <item>
		///             <term>DSS_DISABLED</term>
		///             <description>Embosses the image.</description>
		///         </item>
		///         <item>
		///             <term>DSS_HIDEPREFIX</term>
		///             <description>
		///                 Ignores the ampersand (&amp;) prefix character in the text, thus the letter that follows will not be underlined. This must be used
		///                 with DST_PREFIXTEXT.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DSS_MONO</term>
		///             <description>
		///                 Draws the image using the brush specified by the <paramref name="hbr" /> parameter.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DSS_NORMAL</term>
		///             <description>Draws the image without any modification.</description>
		///         </item>
		///         <item>
		///             <term>DSS_PREFIXONLY</term>
		///             <description>
		///                 Draws only the underline at the position of the letter after the ampersand (&amp;) prefix character. No text in the string is drawn.
		///                 This must be used with DST_PREFIXTEXT.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DSS_RIGHT</term>
		///             <description>Aligns the text to the right.</description>
		///         </item>
		///         <item>
		///             <term>DSS_UNION</term>
		///             <description>Dithers the image.</description>
		///         </item>
		///     </list>
		///     <para>For all states except DSS_NORMAL, the image is converted to monochrome before the visual effect is applied.</para>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DrawState")]
		public static extern bool DrawState(
			[In] IntPtr hdc, [In] IntPtr hbrFore, DrawStateProc qfnCallBack, [MarshalAs(UnmanagedType.SysInt)] int lData,
			[MarshalAs(UnmanagedType.SysUInt)] uint wData, int x, int y, int cx, int cy, uint uFlags);

		/// <summary>
		///     Draws an icon or cursor into the specified device context, performing the specified raster operations, and stretching or compressing the icon or
		///     cursor as specified.
		/// </summary>
		/// <param name="hdc">A handle to the device context into which the icon or cursor will be drawn.</param>
		/// <param name="xLeft">The logical x-coordinate of the upper-left corner of the icon or cursor.</param>
		/// <param name="yTop">The logical y-coordinate of the upper-left corner of the icon or cursor.</param>
		/// <param name="hIcon">A handle to the icon or cursor to be drawn. This parameter can identify an animated cursor.</param>
		/// <param name="cxWidth">
		///     The logical width of the icon or cursor. If this parameter is zero and the <paramref name="diFlags" /> parameter is <see cref="DI.DI_DEFAULTSIZE" />
		///     , the function uses the <see cref="SM.SM_CXICON" /> system metric value to set the width. If this parameter is zero and
		///     <see cref="DI.DI_DEFAULTSIZE" /> is not used, the function uses the actual resource width.
		/// </param>
		/// <param name="cyWidth">
		///     The logical height of the icon or cursor. If this parameter is zero and the <paramref name="diFlags" /> parameter is
		///     <see cref="DI.DI_DEFAULTSIZE" />, the function uses the <see cref="SM.SM_CYICON" /> system metric value to set the width. If this parameter is zero and
		///     <see cref="DI.DI_DEFAULTSIZE" /> is not used, the function uses the actual resource height.
		/// </param>
		/// <param name="istepIfAniCur">
		///     The index of the frame to draw, if <paramref name="hIcon" /> identifies an animated cursor. This parameter is ignored if
		///     <paramref name="hIcon" /> does not identify an animated cursor.
		/// </param>
		/// <param name="hbrFlickerFreeDraw">
		///     A handle to a brush that the system uses for flicker-free drawing. If <paramref name="hbrFlickerFreeDraw" /> is a valid brush handle, the system
		///     creates an offscreen bitmap using the specified brush for the background color, draws the icon or cursor into the bitmap, and then copies the
		///     bitmap into the device context identified by <paramref name="hdc" />. If <paramref name="hbrFlickerFreeDraw" /> is NULL, the system draws the
		///     icon or cursor directly into the device context.
		/// </param>
		/// <param name="diFlags">
		///     <para>The drawing flags. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>DI_COMPAT 0x0004</term>
		///             <description>This flag is ignored.</description>
		///         </item>
		///         <item>
		///             <term>DI_DEFAULTSIZE 0x0008</term>
		///             <description>
		///                 Draws the icon or cursor using the width and height specified by the system metric values for icons, if the
		///                 <paramref name="cxWidth" /> and <paramref name="cyWidth" /> parameters are set to zero. If this flag is not specified and
		///                 <paramref name="cxWidth" /> and <paramref name="cyWidth" /> are set to zero, the function uses the actual resource size.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DI_IMAGE 0x0002</term>
		///             <description>Draws the icon or cursor using the image.</description>
		///         </item>
		///         <item>
		///             <term>DI_MASK 0x0001</term>
		///             <description>Draws the icon or cursor using the mask.</description>
		///         </item>
		///         <item>
		///             <term>DI_NOMIRROR 0x0010</term>
		///             <description>
		///                 Draws the icon as an unmirrored icon. By default, the icon is drawn as a mirrored icon if <paramref name="hdc" /> is mirrored.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DI_NORMAL 0x0003</term>
		///             <description>
		///                 Combination of <see cref="DI.DI_IMAGE" /> and <see cref="DI.DI_MASK" />.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="DrawIconEx" /> function places the icon's upper-left corner at the location specified by the <paramref name="xLeft" /> and
		///         <paramref name="yTop" /> parameters. The location is subject to the current mapping mode of the device context.
		///     </para>
		///     <para>
		///         To duplicate DrawIcon (hDC, X, Y, hIcon), call <see cref="DrawIconEx" /> as follows:
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DrawIconEx")]
		public static extern bool DrawIconEx(
			[In] IntPtr hdc, int xLeft, int yTop, [In] IntPtr hIcon, int cxWidth, int cyWidth, uint istepIfAniCur, [In] IntPtr hbrFlickerFreeDraw, DI diFlags);

		[DllImport("user32.dll", EntryPoint = "DragObject")]
		public static extern uint DragObject([In] IntPtr hwndParent, [In] IntPtr hwndFrom, uint fmt, uint data, [In] IntPtr hcur);

		/// <summary>
		///     Captures the mouse and tracks its movement until the user releases the left button, presses the ESC key, or moves the mouse outside the drag
		///     rectangle around the specified point. The width and height of the drag rectangle are specified by the <see cref="SM.SM_CXDRAG" /> and
		///     <see cref="SM.SM_CYDRAG" /> values returned by the <see cref="GetSystemMetrics" /> function.
		/// </summary>
		/// <param name="hwnd">A handle to the window receiving mouse input.</param>
		/// <param name="pt">
		///     Initial position of the mouse, in screen coordinates. The function determines the coordinates of the drag rectangle by using this
		///     point.
		/// </param>
		/// <returns>
		///     <para>If the user moved the mouse outside of the drag rectangle while holding down the left button, the return value is nonzero.</para>
		///     <para>If the user did not move the mouse outside of the drag rectangle while holding down the left button, the return value is zero.</para>
		/// </returns>
		/// <remarks>The system metrics for the drag rectangle are configurable, allowing for larger or smaller drag rectangles.</remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DragDetect")]
		public static extern bool DragDetect([In] IntPtr hwnd, POINT pt);

		/// <summary>
		///     Deletes an item from the specified menu. If the menu item opens a menu or submenu, this function destroys the handle to the menu or submenu and
		///     frees the memory used by the menu or submenu.
		/// </summary>
		/// <param name="hMenu">A handle to the menu to be changed.</param>
		/// <param name="uPosition">
		///     The menu item to be deleted, as determined by the <paramref name="uFlags" /> parameter.
		/// </param>
		/// <param name="uFlags">
		///     <para>
		///         Indicates how the <paramref name="uPosition" /> parameter is interpreted. This parameter must be one of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>MF_BYCOMMAND 0x00000000L</term>
		///             <description>
		///                 Indicates that <paramref name="uPosition" /> gives the identifier of the menu item. The <see cref="MF.MF_BYCOMMAND" /> flag is the
		///                 default flag if neither the <see cref="MF.MF_BYCOMMAND" /> nor <see cref="MF.MF_BYPOSITION" /> flag is specified.
		///             </description>
		///         </item>
		///         <item>
		///             <term>MF_BYPOSITION 0x00000400L</term>
		///             <description>
		///                 Indicates that <paramref name="uPosition" /> gives the zero-based relative position of the menu item.
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     The application must call the <see cref="DrawMenuBar" /> function whenever a menu changes, whether the menu is in a displayed window.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DeleteMenu")]
		public static extern bool DeleteMenu([In] IntPtr hMenu, uint uPosition, MF uFlags);

		/// <summary>Copies data from the specified Dynamic Data Exchange (DDE) object to the specified local buffer.</summary>
		/// <param name="hData">A handle to the DDE object that contains the data to copy.</param>
		/// <param name="pDst">
		///     A pointer to the buffer that receives the data. If this parameter is NULL, the <see cref="DdeGetData" /> function returns the amount of data, in
		///     bytes, that would be copied to the buffer.
		/// </param>
		/// <param name="cbMax">
		///     The maximum amount of data, in bytes, to copy to the buffer pointed to by the <paramref name="pDst" /> parameter. Typically, this parameter
		///     specifies the length of the buffer pointed to by <paramref name="pDst" />.
		/// </param>
		/// <param name="cbOff">An offset within the DDE object. Data is copied from the object beginning at this offset.</param>
		/// <returns>
		///     <para>
		///         If the <paramref name="pDst" /> parameter points to a buffer, the return value is the size, in bytes, of the memory object associated with
		///         the data handle or the size specified in the <paramref name="cbMax" /> parameter, whichever is lower.
		///     </para>
		///     <para>
		///         If the <paramref name="pDst" /> parameter is NULL, the return value is the size, in bytes, of the memory object associated with the data
		///         handle.
		///     </para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "DdeGetData")]
		public static extern uint DdeGetData(IntPtr hData, ref byte pDst, uint cbMax, uint cbOff);

		/// <summary>
		///     Establishes a conversation with a server application that supports the specified service name and topic name pair. If more than one such server
		///     exists, the system selects only one.
		/// </summary>
		/// <param name="idInst">
		///     The application instance identifier obtained by a previous call to the <see cref="DdeInitialize" /> function.
		/// </param>
		/// <param name="hszService">
		///     A handle to the string that specifies the service name of the server application with which a conversation is to be established. This handle must
		///     have been created by a previous call to the <see cref="DdeCreateStringHandle" /> function. If this parameter is 0L, a conversation is established
		///     with any available server.
		/// </param>
		/// <param name="hszTopic">
		///     A handle to the string that specifies the name of the topic on which a conversation is to be established. This handle must have been created by a
		///     previous call to <see cref="DdeCreateStringHandle" />. If this parameter is 0L, a conversation on any topic supported by the selected server is
		///     established.
		/// </param>
		/// <param name="pCC">
		///     A pointer to the <see cref="CONVCONTEXT" /> structure that contains conversation context information. If this parameter is NULL, the server
		///     receives the default <see cref="CONVCONTEXT" /> structure during the <see cref="XTYP_CONNECT" /> or <see cref="XTYP_WILDCONNECT" /> transaction.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the handle to the established conversation.</para>
		///     <para>If the function fails, the return value is 0L.</para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The client application cannot make assumptions regarding the server selected. If an instance-specific name is specified in the
		///         <paramref name="hszService" /> parameter, a conversation is established with only the specified instance. Instance-specific service names are
		///         passed to an application's Dynamic Data Exchange (DDE) callback function during the <see cref="XTYP_REGISTER" /> and
		///         <see cref="XTYP_UNREGISTER" /> transactions.
		///     </para>
		///     <para>
		///         All members of the default <see cref="CONVCONTEXT" /> structure are set to zero except <paramref name="cb" />, which specifies the size of
		///         the structure, and <paramref name="iCodePage" />, which specifies <see cref="CP_WINANSI" /> (the default code page) or
		///         <see cref="CP_WINUNICODE" />, depending on whether the ANSI or Unicode version of the <see cref="DdeInitialize" /> function was called by the
		///         client application.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DdeConnect")]
		public static extern IntPtr DdeConnect(uint idInst, IntPtr hszService, IntPtr hszTopic, ref CONVCONTEXT pCC);

		/// <summary>
		///     Adds data to the specified Dynamic Data Exchange (DDE) object. An application can add data starting at any offset from the beginning of the
		///     object. If new data overlaps data already in the object, the new data overwrites the old data in the bytes where the overlap occurs. The contents
		///     of locations in the object that have not been written to are undefined.
		/// </summary>
		/// <param name="hData">A handle to the DDE object that receives additional data.</param>
		/// <param name="pSrc">The data to be added to the DDE object.</param>
		/// <param name="cb">The length, in bytes, of the data to be added to the DDE object, including the terminating NULL, if the data is a string.</param>
		/// <param name="cbOff">An offset, in bytes, from the beginning of the DDE object. The additional data is copied to the object beginning at this offset.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a new handle to the DDE object. The new handle is used in all references to the object.</para>
		///     <para>If the function fails, the return value is zero.</para>
		///     <para>
		///         The <see cref="DdeGetLastError" /> function can be used to get the error code, which can be one of the following values:
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         After a data handle has been used as a parameter in another Dynamic Data Exchange Management Library function or has been returned by a DDE
		///         callback function, the handle can be used only for read access to the DDE object identified by the handle.
		///     </para>
		///     <para>
		///         If the amount of memory originally allocated is less than is needed to hold the added data, <see cref="DdeAddData" /> reallocates a global
		///         memory object of the appropriate size.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DdeAddData")]
		public static extern IntPtr DdeAddData(IntPtr hData, ref byte pSrc, uint cb, uint cbOff);

		/// <summary>
		///     Creates a menu. The menu is initially empty, but it can be filled with menu items by using the <see cref="InsertMenuItem" />,
		///     <see cref="AppendMenu" />, and <see cref="InsertMenu" /> functions.
		/// </summary>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to the newly created menu.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     Resources associated with a menu that is assigned to a window are freed automatically. If the menu is not assigned to a window, an application
		///     must free system resources associated with the menu before closing. An application frees menu resources by calling the <see cref="DestroyMenu" />
		///     function.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CreateMenu")]
		public static extern IntPtr CreateMenu();

		/// <summary>Creates an icon that has the specified size, colors, and bit patterns.</summary>
		/// <param name="hInstance">A handle to the instance of the module creating the icon.</param>
		/// <param name="nWidth">The width, in pixels, of the icon.</param>
		/// <param name="nHeight">The height, in pixels, of the icon.</param>
		/// <param name="cPlanes">The number of planes in the XOR bitmask of the icon.</param>
		/// <param name="cBitsPixel">The number of bits-per-pixel in the XOR bitmask of the icon.</param>
		/// <param name="lpbANDbits">An array of bytes that contains the bit values for the AND bitmask of the icon. This bitmask describes a monochrome bitmap.</param>
		/// <param name="lpbXORbits">
		///     An array of bytes that contains the bit values for the XOR bitmask of the icon. This bitmask describes a monochrome or
		///     device-dependent color bitmap.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to an icon.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <paramref name="nWidth" /> and <paramref name="nHeight" /> parameters must specify a width and height supported by the current display
		///         driver, because the system cannot create icons of other sizes. To determine the width and height supported by the display driver, use the
		///         <see cref="GetSystemMetrics" /> function, specifying the <see cref="SM.SM_CXICON" /> or <see cref="SM.SM_CYICON" /> value.
		///     </para>
		///     <para>
		///         <see cref="CreateIcon" /> applies the following truth table to the AND and XOR bitmasks.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CreateIcon")]
		public static extern IntPtr CreateIcon(
			[In] IntPtr hInstance, int nWidth, int nHeight, byte cPlanes, byte cBitsPixel, [In] ref byte lpbANDbits, [In] ref byte lpbXORbits);

		/// <summary>
		///     Confines the cursor to a rectangular area on the screen. If a subsequent cursor position (set by the <see cref="SetCursorPos" /> function or the
		///     mouse) lies outside the rectangle, the system automatically adjusts the position to keep the cursor inside the rectangular area.
		/// </summary>
		/// <param name="lpRect">
		///     A pointer to the structure that contains the screen coordinates of the upper-left and lower-right corners of the confining rectangle. If this
		///     parameter is NULL, the cursor is free to move anywhere on the screen.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The cursor is a shared resource. If an application confines the cursor, it must release the cursor by using <see cref="ClipCursor" /> before
		///         relinquishing control to another application.
		///     </para>
		///     <para>
		///         The calling process must have <see cref="WINSTA_WRITEATTRIBUTES" /> access to the window station.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "ClipCursor")]
		public static extern bool ClipCursor([In] ref RECT lpRect);

		/// <summary>
		///     Converts a character string or a single character to uppercase. If the operand is a character string, the function converts the characters
		///     in place.
		/// </summary>
		/// <param name="lpsz">
		///     A null-terminated string, or a single character. If the high-order word of this parameter is zero, the low-order word must contain a single
		///     character to be converted.
		/// </param>
		/// <returns>
		///     <para>
		///         If the operand is a character string, the function returns a pointer to the converted string. Because the string is converted in place, the
		///         return value is equal to <paramref name="lpsz" />.
		///     </para>
		///     <para>
		///         If the operand is a single character, the return value is a 32-bit value whose high-order word is zero, and low-order word contains the
		///         converted character.
		///     </para>
		///     <para>
		///         There is no indication of success or failure. Failure is rare. There is no extended error information for this function; do not call
		///         GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Note that <see cref="CharUpper" /> always maps lowercase I ("i") to uppercase I, even when the current language is Turkish or Azeri. If you
		///         need a function that is linguistically sensitive in this respect, call <see cref="LCMapString" />.
		///     </para>
		///     <para>Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.</para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CharUpper")]
		public static extern string CharUpper(string lpsz);

		/// <summary>
		///     <para>Translates a string into the OEM-defined character set.</para>
		///     <para>
		///         Warning:  Do not use. See Security Considerations.
		///     </para>
		/// </summary>
		/// <param name="lpszSrc">The null-terminated string to be translated.</param>
		/// <param name="lpszDst">
		///     The destination buffer, which receives the translated string. If the <see cref="CharToOem" /> function is being used as an ANSI function, the
		///     string can be translated in place by setting the <paramref name="lpszDst" /> parameter to the same address as the <paramref name="lpszSrc" />
		///     parameter. This cannot be done if <see cref="CharToOem" /> is being used as a wide-character function.
		/// </param>
		/// <returns>
		///     The return value is always nonzero except when you pass the same address to <paramref name="lpszSrc" /> and <paramref name="lpszDst" /> in the
		///     wide-character version of the function. In this case the function returns zero and GetLastError returns <see cref="ERROR_INVALID_ADDRESS" />.
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "CharToOem")]
		public static extern bool CharToOem([In] string lpszSrc, [Out] [MarshalAs(UnmanagedType.LPStr)] StringBuilder lpszDst);

		/// <summary>
		///     Converts a character string or a single character to lowercase. If the operand is a character string, the function converts the characters
		///     in place.
		/// </summary>
		/// <param name="lpsz">
		///     A null-terminated string, or specifies a single character. If the high-order word of this parameter is zero, the low-order word must contain a
		///     single character to be converted.
		/// </param>
		/// <returns>
		///     <para>
		///         If the operand is a character string, the function returns a pointer to the converted string. Because the string is converted in place, the
		///         return value is equal to <paramref name="lpsz" />.
		///     </para>
		///     <para>
		///         If the operand is a single character, the return value is a 32-bit value whose high-order word is zero, and low-order word contains the
		///         converted character.
		///     </para>
		///     <para>
		///         There is no indication of success or failure. Failure is rare. There is no extended error information for this function; do not call
		///         GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Note that <see cref="CharLower" /> always maps uppercase I to lowercase I ("i"), even when the current language is Turkish or Azeri. If you
		///         need a function that is linguistically sensitive in this respect, call <see cref="LCMapString" />.
		///     </para>
		///     <para>Conversion to Unicode in the ANSI version of the function is done with the system default locale in all cases.</para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CharLower")]
		public static extern string CharLower(IntPtr lpsz);

		/// <summary>
		///     The <see cref="BeginPaint" /> function prepares the specified window for painting and fills a <see cref="PAINTSTRUCT" /> structure with
		///     information about the painting.
		/// </summary>
		/// <param name="hwnd">Handle to the window to be repainted.</param>
		/// <param name="lpPaint">
		///     Pointer to the <see cref="PAINTSTRUCT" /> structure that will receive painting information.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the handle to a display device context for the specified window.</para>
		///     <para>If the function fails, the return value is NULL, indicating that no display device context is available.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="BeginPaint" /> function automatically sets the clipping region of the device context to exclude any area outside the update
		///         region. The update region is set by the <see cref="InvalidateRect" /> or <see cref="InvalidateRgn" /> function and by the system after
		///         sizing, moving, creating, scrolling, or any other operation that affects the client area. If the update region is marked for erasing,
		///         <see cref="BeginPaint" /> sends a <see cref="WM.WM_ERASEBKGND" /> message to the window.
		///     </para>
		///     <para>
		///         An application should not call <see cref="BeginPaint" /> except in response to a <see cref="WM.WM_PAINT" /> message. Each call to
		///         <see cref="BeginPaint" /> must have a corresponding call to the <see cref="EndPaint" /> function.
		///     </para>
		///     <para>
		///         If the caret is in the area to be painted, <see cref="BeginPaint" /> automatically hides the caret to prevent it from being erased.
		///     </para>
		///     <para>
		///         If the window's class has a background brush, <see cref="BeginPaint" /> uses that brush to erase the background of the update region before
		///         returning.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "BeginPaint")]
		public static extern IntPtr BeginPaint([In] IntPtr hWnd, [Out] out PAINTSTRUCT lpPaint);

		/// <summary>
		///     The <see cref="UnionRect" /> function creates the union of two rectangles. The union is the smallest rectangle that contains both source
		///     rectangles.
		/// </summary>
		/// <param name="lprcDst">
		///     A pointer to the <see cref="RECT" /> structure that will receive a rectangle containing the rectangles pointed to by the
		///     <paramref name="lprcSrc1" /> and <paramref name="lprcSrc2" /> parameters.
		/// </param>
		/// <param name="lprcSrc1">
		///     A pointer to the <see cref="RECT" /> structure that contains the first source rectangle.
		/// </param>
		/// <param name="lprcSrc2">
		///     A pointer to the <see cref="RECT" /> structure that contains the second source rectangle.
		/// </param>
		/// <returns>
		///     <para>If the specified structure contains a nonempty rectangle, the return value is nonzero.</para>
		///     <para>If the specified structure does not contain a nonempty rectangle, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The system ignores the dimensions of an empty rectangle that is, a rectangle in which all coordinates are set to zero, so that it has no
		///         height or no width.
		///     </para>
		///     <para>
		///         Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all
		///         rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used
		///         determine the units of measure.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "UnionRect")]
		public static extern bool UnionRect([Out] out RECT lprcDst, [In] ref RECT lprcSrc1, [In] ref RECT lprcSrc2);

		/// <summary>
		///     <para>Translates the specified virtual-key code and keyboard state to the corresponding Unicode character or characters.</para>
		///     <para>
		///         To specify a handle to the keyboard layout to use to translate the specified code, use the <see cref="ToUnicodeEx" /> function.
		///     </para>
		/// </summary>
		/// <param name="wVirtKey">The virtual-key code to be translated. See Virtual-Key Codes.</param>
		/// <param name="wScanCode">The hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up.</param>
		/// <param name="lpKeyState">
		///     A pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of one key. If the
		///     high-order bit of a byte is set, the key is down.
		/// </param>
		/// <param name="pwszBuff">
		///     The buffer that receives the translated Unicode character or characters. However, this buffer may be returned without being null-terminated even
		///     though the variable name suggests that it is null-terminated.
		/// </param>
		/// <param name="cchBuff">
		///     The size, in characters, of the buffer pointed to by the <paramref name="pwszBuff" /> parameter.
		/// </param>
		/// <param name="wFlags">The behavior of the function. If bit 0 is set, a menu is active. Bits 1 through 31 are reserved.</param>
		/// <returns>The function returns one of the following values.</returns>
		/// <remarks>
		///     <para>
		///         The parameters supplied to the <see cref="ToUnicode" /> function might not be sufficient to translate the virtual-key code because a previous
		///         dead key is stored in the keyboard layout.
		///     </para>
		///     <para>
		///         Typically, <see cref="ToUnicode" /> performs the translation based on the virtual-key code. In some cases, however, bit 15 of the
		///         <paramref name="wScanCode" /> parameter can be used to distinguish between a key press and a key release.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "ToUnicode")]
		public static extern int ToUnicode(
			uint wVirtKey, uint wScanCode, [In] IntPtr lpKeyState, [Out] [MarshalAs(UnmanagedType.LPWStr)] StringBuilder pwszBuff, int cchBuff, TU wFlags);

		/// <summary>
		///     Translates the specified virtual-key code and keyboard state to the corresponding character or characters. The function translates the code using
		///     the input language and physical keyboard layout identified by the input locale identifier.
		/// </summary>
		/// <param name="uVirtKey">The virtual-key code to be translated. See Virtual-Key Codes.</param>
		/// <param name="uScanCode">The hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up (not pressed).</param>
		/// <param name="lpKeyState">
		///     <para>
		///         A pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of one key. If
		///         the high-order bit of a byte is set, the key is down (pressed).
		///     </para>
		///     <para>
		///         The low bit, if set, indicates that the key is toggled on. In this function, only the toggle bit of the CAPS LOCK key is relevant. The toggle
		///         state of the NUM LOCK and SCOLL LOCK keys is ignored.
		///     </para>
		/// </param>
		/// <param name="lpChar">A pointer to the buffer that receives the translated character or characters.</param>
		/// <param name="uFlags">This parameter must be 1 if a menu is active, zero otherwise.</param>
		/// <param name="dwhkl">
		///     Input locale identifier to use to translate the code. This parameter can be any input locale identifier previously returned by the
		///     <see cref="LoadKeyboardLayout" /> function.
		/// </param>
		/// <returns>If the specified key is a dead key, the return value is negative. Otherwise, it is one of the following values.</returns>
		/// <remarks>
		///     <para>
		///         The input locale identifier is a broader concept than a keyboard layout, since it can also encompass a speech-to-text converter, an Input
		///         Method Editor (IME), or any other form of input.
		///     </para>
		///     <para>
		///         The parameters supplied to the <see cref="ToAsciiEx" /> function might not be sufficient to translate the virtual-key code, because a
		///         previous dead key is stored in the keyboard layout.
		///     </para>
		///     <para>
		///         Typically, <see cref="ToAsciiEx" /> performs the translation based on the virtual-key code. In some cases, however, bit 15 of the
		///         <paramref name="uScanCode" /> parameter may be used to distinguish between a key press and a key release. The scan code is used for
		///         translating ALT+number key combinations.
		///     </para>
		///     <para>
		///         Although NUM LOCK is a toggle key that affects keyboard behavior, <see cref="ToAsciiEx" /> ignores the toggle setting (the low bit) of
		///         <paramref name="lpKeyState" /> (<see cref="VK.VK_NUMLOCK" />) because the <paramref name="uVirtKey" /> parameter alone is sufficient to
		///         distinguish the cursor movement keys (<see cref="VK.VK_HOME" />, <see cref="VK.VK_INSERT" />, and so on) from the numeric keys (
		///         <see cref="VK.VK_DECIMAL" />, <see cref="VK.VK_NUMPAD0" /> - <see cref="VK.VK_NUMPAD9" />).
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "ToAsciiEx")]
		public static extern int ToAsciiEx(uint uVirtKey, uint uScanCode, [In] IntPtr lpKeyState, [Out] out ushort lpChar, TA uFlags, [In] IntPtr dwhkl);

		/// <summary>Makes the caret visible on the screen at the caret's current position. When the caret becomes visible, it begins flashing automatically.</summary>
		/// <param name="hWnd">
		///     A handle to the window that owns the caret. If this parameter is NULL, <see cref="ShowCaret" /> searches the current task for the window that
		///     owns the caret.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         <see cref="ShowCaret" /> shows the caret only if the specified window owns the caret, the caret has a shape, and the caret has not been
		///         hidden two or more times in a row. If one or more of these conditions is not met, <see cref="ShowCaret" /> does nothing and returns FALSE.
		///     </para>
		///     <para>
		///         Hiding is cumulative. If your application calls <see cref="HideCaret" /> five times in a row, it must also call <see cref="ShowCaret" /> five
		///         times before the caret reappears.
		///     </para>
		///     <para>
		///         The system provides one caret per queue. A window should create a caret only when it has the keyboard focus or is active. The window should
		///         destroy the caret before losing the keyboard focus or becoming inactive.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "ShowCaret")]
		public static extern bool ShowCaret([In] IntPtr hWnd);

		/// <summary>Changes the parent window of the specified child window.</summary>
		/// <param name="hWndChild">A handle to the child window.</param>
		/// <param name="hWndNewParent">
		///     A handle to the new parent window. If this parameter is NULL, the desktop window becomes the new parent window. If this parameter is
		///     HWND_MESSAGE, the child window becomes a message-only window.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to the previous parent window.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         An application can use the <see cref="SetParent" /> function to set the parent window of a pop-up, overlapped, or child window.
		///     </para>
		///     <para>
		///         If the window identified by the <paramref name="hWndChild" /> parameter is visible, the system performs the appropriate redrawing and
		///         repainting.
		///     </para>
		///     <para>
		///         For compatibility reasons, <see cref="SetParent" /> does not modify the <see cref="WS.WS_CHILD" /> or <see cref="WS.WS_POPUP" /> window styles of
		///         the window whose parent is being changed. Therefore, if <paramref name="hWndNewParent" /> is NULL, you should also clear the
		///         <see cref="WS.WS_CHILD" /> bit and set the <see cref="WS.WS_POPUP" /> style after calling <see cref="SetParent" />. Conversely, if
		///         <paramref name="hWndNewParent" /> is not NULL and the window was previously a child of the desktop, you should clear the
		///         <see cref="WS.WS_POPUP" /> style and set the <see cref="WS.WS_CHILD" /> style before calling <see cref="SetParent" />.
		///     </para>
		///     <para>
		///         When you change the parent of a window, you should synchronize the UISTATE of both windows. For more information, see
		///         <see cref="WM.WM_CHANGEUISTATE" /> and <see cref="WM.WM_UPDATEUISTATE" />.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetParent")]
		public static extern IntPtr SetParent([In] IntPtr hWndChild, [In] IntPtr hWndNewParent);

		/// <summary>Sets the cursor shape.</summary>
		/// <param name="hCursor">
		///     A handle to the cursor. The cursor must have been created by the <see cref="CreateCursor" /> function or loaded by the <see cref="LoadCursor" />
		///     or <see cref="LoadImage" /> function. If this parameter is NULL, the cursor is removed from the screen.
		/// </param>
		/// <returns>
		///     <para>The return value is the handle to the previous cursor, if there was one.</para>
		///     <para>If there was no previous cursor, the return value is NULL.</para>
		/// </returns>
		/// <remarks>
		///     <para>The cursor is set only if the new cursor is different from the previous cursor; otherwise, the function returns immediately.</para>
		///     <para>
		///         The cursor is a shared resource. A window should set the cursor shape only when the cursor is in its client area or when the window is
		///         capturing mouse input. In systems without a mouse, the window should restore the previous cursor before the cursor leaves the client area or
		///         before it relinquishes control to another window.
		///     </para>
		///     <para>
		///         If your application must set the cursor while it is in a window, make sure the class cursor for the specified window's class is set to NULL.
		///         If the class cursor is not NULL, the system restores the class cursor each time the mouse is moved.
		///     </para>
		///     <para>
		///         The cursor is not shown on the screen if the internal cursor display count is less than zero. This occurs if the application uses the
		///         <see cref="ShowCursor" /> function to hide the cursor more times than to show the cursor.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetCursor")]
		public static extern IntPtr SetCursor([In] IntPtr hCursor);

		/// <summary>Synthesizes keystrokes, mouse motions, and button clicks.</summary>
		/// <param name="nInputs">
		///     The number of structures in the <paramref name="pInputs" /> array.
		/// </param>
		/// <param name="pInputs">
		///     An array of <see cref="INPUT" /> structures. Each structure represents an event to be inserted into the keyboard or mouse input stream.
		/// </param>
		/// <param name="cbSize">
		///     The size, in bytes, of an <see cref="INPUT" /> structure. If <paramref name="cbSize" /> is not the size of an <see cref="INPUT" /> structure, the
		///     function fails.
		/// </param>
		/// <returns>
		///     <para>
		///         The function returns the number of events that it successfully inserted into the keyboard or mouse input stream. If the function returns
		///         zero, the input was already blocked by another thread. To get extended error information, call GetLastError.
		///     </para>
		///     <para>
		///         This function fails when it is blocked by UIPI. Note that neither GetLastError nor the return value will indicate the failure was caused by
		///         UIPI blocking.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         This function is subject to UIPI. Applications are permitted to inject input only into applications that are at an equal or lesser
		///         integrity level.
		///     </para>
		///     <para>
		///         The <see cref="SendInput" /> function inserts the events in the <see cref="INPUT" /> structures serially into the keyboard or mouse input
		///         stream. These events are not interspersed with other keyboard or mouse input events inserted either by the user (with the keyboard or mouse)
		///         or by calls to <see cref="keybd_event" />, <see cref="mouse_event" />, or other calls to <see cref="SendInput" />.
		///     </para>
		///     <para>
		///         This function does not reset the keyboard's current state. Any keys that are already pressed when the function is called might interfere with
		///         the events that this function generates. To avoid this problem, check the keyboard's state with the <see cref="GetAsyncKeyState" /> function
		///         and correct as necessary.
		///     </para>
		///     <para>
		///         Because the touch keyboard uses the surrogate macros defined in winnls.h to send input to the system, a listener on the keyboard event hook
		///         must decode input originating from the touch keyboard. For more information, see Surrogates and Supplementary Characters.
		///     </para>
		///     <para>
		///         An accessibility application can use <see cref="SendInput" /> to inject keystrokes corresponding to application launch shortcut keys that are
		///         handled by the shell. This functionality is not guaranteed to work for other types of applications.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SendInput")]
		public static extern uint SendInput(
			uint nInputs, [MarshalAs(UnmanagedType.LPArray, ArraySubType = UnmanagedType.Struct, SizeParamIndex = 0)] INPUT[] pInputs, int cbSize);

		/// <summary>
		///     The <see cref="ReleaseDC" /> function releases a device context (DC), freeing it for use by other applications. The effect of the
		///     <see cref="ReleaseDC" /> function depends on the type of DC. It frees only common and window DCs. It has no effect on class or private DCs.
		/// </summary>
		/// <param name="hWnd">A handle to the window whose DC is to be released.</param>
		/// <param name="hDC">A handle to the DC to be released.</param>
		/// <returns>
		///     <para>The return value indicates whether the DC was released. If the DC was released, the return value is 1.</para>
		///     <para>If the DC was not released, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The application must call the <see cref="ReleaseDC" /> function for each call to the <see cref="GetWindowDC" /> function and for each call to
		///         the <see cref="GetDC" /> function that retrieves a common DC.
		///     </para>
		///     <para>
		///         An application cannot use the <see cref="ReleaseDC" /> function to release a DC that was created by calling the CreateDC
		///         function; instead, it must use the DeleteDC function. <see cref="ReleaseDC" /> must be called from the same thread that called
		///         <see cref="GetDC" />.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "ReleaseDC")]
		public static extern int ReleaseDC([In] IntPtr hWnd, [In] IntPtr hDC);

		/// <summary>Loads the specified menu resource from the executable (.exe) file associated with an application instance.</summary>
		/// <param name="hInstance">A handle to the module containing the menu resource to be loaded.</param>
		/// <param name="lpMenuName">
		///     The name of the menu resource. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the
		///     high-order word. To create this value, use the MAKEINTRESOURCE macro.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to the menu resource.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     The <see cref="DestroyMenu" /> function is used, before an application closes, to destroy the menu and free memory that the loaded menu occupied.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "LoadMenu")]
		public static extern IntPtr LoadMenu([In] IntPtr hInstance, [In] string lpMenuName);

		/// <summary>
		///     <para>Loads the specified icon resource from the executable (.exe) file associated with an application instance.</para>
		///     <para>
		///         Note:  This function has been superseded by the <see cref="LoadImage" /> function.
		///     </para>
		/// </summary>
		/// <param name="hInstance">
		///     A handle to an instance of the module whose executable file contains the icon to be loaded. This parameter must be NULL when a standard icon is
		///     being loaded.
		/// </param>
		/// <param name="lpIconName">
		///     <para>
		///         The name of the icon resource to be loaded. Alternatively, this parameter can contain the resource identifier in the low-order word and zero
		///         in the high-order word. Use the MAKEINTRESOURCE macro to create this value.
		///     </para>
		///     <para>
		///         To use one of the predefined icons, set the <paramref name="hInstance" /> parameter to NULL and the <paramref name="lpIconName" /> parameter
		///         to one of the following values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>IDI_APPLICATION MAKEINTRESOURCE(32512)</term>
		///             <description>Default application icon.</description>
		///         </item>
		///         <item>
		///             <term>IDI_ASTERISK MAKEINTRESOURCE(32516)</term>
		///             <description>
		///                 Asterisk icon. Same as <see cref="IDI_INFORMATION" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>IDI_ERROR MAKEINTRESOURCE(32513)</term>
		///             <description>Hand-shaped icon.</description>
		///         </item>
		///         <item>
		///             <term>IDI_EXCLAMATION MAKEINTRESOURCE(32515)</term>
		///             <description>
		///                 Exclamation point icon. Same as <see cref="IDI_WARNING" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>IDI_HAND MAKEINTRESOURCE(32513)</term>
		///             <description>
		///                 Hand-shaped icon. Same as <see cref="IDI_ERROR" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>IDI_INFORMATION MAKEINTRESOURCE(32516)</term>
		///             <description>Asterisk icon.</description>
		///         </item>
		///         <item>
		///             <term>IDI_QUESTION MAKEINTRESOURCE(32514)</term>
		///             <description>Question mark icon.</description>
		///         </item>
		///         <item>
		///             <term>IDI_SHIELD MAKEINTRESOURCE(32518)</term>
		///             <description>Security Shield icon.</description>
		///         </item>
		///         <item>
		///             <term>IDI_WARNING MAKEINTRESOURCE(32515)</term>
		///             <description>Exclamation point icon.</description>
		///         </item>
		///         <item>
		///             <term>IDI_WINLOGO MAKEINTRESOURCE(32517)</term>
		///             <description>
		///                 <para>Default application icon.</para>
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to the newly loaded icon.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         <see cref="LoadIcon" /> loads the icon resource only if it has not been loaded; otherwise, it retrieves a handle to the existing resource.
		///         The function searches the icon resource for the icon most appropriate for the current display. The icon resource can be a color or monochrome
		///         bitmap.
		///     </para>
		///     <para>
		///         <see cref="LoadIcon" /> can only load an icon whose size conforms to the <see cref="SM.SM_CXICON" /> and <see cref="SM.SM_CYICON" /> system metric
		///         values. Use the <see cref="LoadImage" /> function to load icons of other sizes.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "LoadIcon")]
		public static extern IntPtr LoadIcon([In] IntPtr hInstance, [In] string lpIconName);

		/// <summary>Destroys the specified timer.</summary>
		/// <param name="hWnd">
		///     A handle to the window associated with the specified timer. This value must be the same as the <paramref name="hWnd" /> value passed to the
		///     <see cref="SetTimer" /> function that created the timer.
		/// </param>
		/// <param name="uIDEvent">
		///     The timer to be destroyed. If the window handle passed to <see cref="SetTimer" /> is valid, this parameter must be the same as the
		///     nIDEvent value passed to <see cref="SetTimer" />. If the application calls <see cref="SetTimer" /> with
		///     <paramref name="hWnd" /> set to NULL, this parameter must be the timer identifier returned by <see cref="SetTimer" />.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     The <see cref="KillTimer" /> function does not remove <see cref="WM.WM_TIMER" /> messages already posted to the message queue.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "KillTimer")]
		public static extern bool KillTimer([In] IntPtr hWnd, [MarshalAs(UnmanagedType.SysUInt)] uint uIDEvent);

		/// <summary>Removes the caret from the screen. Hiding a caret does not destroy its current shape or invalidate the insertion point.</summary>
		/// <param name="hWnd">
		///     A handle to the window that owns the caret. If this parameter is NULL, <see cref="HideCaret" /> searches the current task for the window that
		///     owns the caret.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         <see cref="HideCaret" /> hides the caret only if the specified window owns the caret. If the specified window does not own the caret,
		///         <see cref="HideCaret" /> does nothing and returns FALSE.
		///     </para>
		///     <para>
		///         Hiding is cumulative. If your application calls <see cref="HideCaret" /> five times in a row, it must also call <see cref="ShowCaret" /> five
		///         times before the caret is displayed.
		///     </para>
		///     <para>For an example, see Hiding a Caret.</para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "HideCaret")]
		public static extern bool HideCaret([In] IntPtr hWnd);

		/// <summary>
		///     Retrieves a handle to a window that has the specified relationship (Z-Order or owner) to the specified window.
		/// </summary>
		/// <param name="hWnd">
		///     A handle to a window. The window handle retrieved is relative to this window, based on the value of the <paramref name="uCmd" /> parameter.
		/// </param>
		/// <param name="uCmd">
		///     <para>
		///         The relationship between the specified window and the window whose handle is to be retrieved. This parameter can be one of the following
		///         values.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>GW_CHILD 5</term>
		///             <description>
		///                 The retrieved handle identifies the child window at the top of the Z order, if the specified window is a parent window; otherwise,
		///                 the retrieved handle is NULL. The function examines only child windows of the specified window. It does not examine descendant
		///                 windows.
		///             </description>
		///         </item>
		///         <item>
		///             <term>GW_ENABLEDPOPUP 6</term>
		///             <description>
		///                 The retrieved handle identifies the enabled popup window owned by the specified window (the search uses the first such window found
		///                 using <see cref="GW.GW_HWNDNEXT" />); otherwise, if there are no enabled popup windows, the retrieved handle is that of the specified
		///                 window.
		///             </description>
		///         </item>
		///         <item>
		///             <term>GW_HWNDFIRST 0</term>
		///             <description>
		///                 <para>The retrieved handle identifies the window of the same type that is highest in the Z order.</para>
		///                 <para>
		///                     If the specified window is a topmost window, the handle identifies a topmost window. If the specified window is a top-level
		///                     window, the handle identifies a top-level window. If the specified window is a child window, the handle identifies a sibling
		///                     window.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>GW_HWNDLAST 1</term>
		///             <description>
		///                 <para>The retrieved handle identifies the window of the same type that is lowest in the Z order.</para>
		///                 <para>
		///                     If the specified window is a topmost window, the handle identifies a topmost window. If the specified window is a top-level
		///                     window, the handle identifies a top-level window. If the specified window is a child window, the handle identifies a sibling
		///                     window.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>GW_HWNDNEXT 2</term>
		///             <description>
		///                 <para>The retrieved handle identifies the window below the specified window in the Z order.</para>
		///                 <para>
		///                     If the specified window is a topmost window, the handle identifies a topmost window. If the specified window is a top-level
		///                     window, the handle identifies a top-level window. If the specified window is a child window, the handle identifies a sibling
		///                     window.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>GW_HWNDPREV 3</term>
		///             <description>
		///                 <para>The retrieved handle identifies the window above the specified window in the Z order.</para>
		///                 <para>
		///                     If the specified window is a topmost window, the handle identifies a topmost window. If the specified window is a top-level
		///                     window, the handle identifies a top-level window. If the specified window is a child window, the handle identifies a sibling
		///                     window.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>GW_OWNER 4</term>
		///             <description>The retrieved handle identifies the specified window's owner window, if any. For more information, see Owned Windows.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is a window handle. If no window exists with the specified relationship to the specified window,
		///         the return value is NULL. To get extended error information, call GetLastError.
		///     </para>
		/// </returns>
		/// <remarks>
		///     The <see cref="EnumChildWindows" /> function is more reliable than calling <see cref="GetWindow" /> in a loop. An application that calls
		///     <see cref="GetWindow" /> to perform this task risks being caught in an infinite loop or referencing a handle to a window that has been destroyed.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetWindow")]
		public static extern IntPtr GetWindow([In] IntPtr hWnd, GW uCmd);

		/// <summary>
		///     <para>Retrieves a handle to the specified window's parent or owner.</para>
		///     <para>
		///         To retrieve a handle to a specified ancestor, use the <see cref="GetAncestor" /> function.
		///     </para>
		/// </summary>
		/// <param name="hWnd">A handle to the window whose parent window handle is to be retrieved.</param>
		/// <returns>
		///     <para>
		///         If the window is a child window, the return value is a handle to the parent window. If the window is a top-level window with the
		///         <see cref="WS.WS_POPUP" /> style, the return value is a handle to the owner window.
		///     </para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		///     <para>This function typically fails for one of the following reasons:</para>
		/// </returns>
		/// <remarks>
		///     To obtain a window's owner window, instead of using <see cref="GetParent" />, use <see cref="GetWindow" /> with the <see cref="GW.GW_OWNER" /> flag.
		///     To obtain the parent window and not the owner, instead of using <see cref="GetParent" />, use <see cref="GetAncestor" /> with the
		///     <see cref="GA_PARENT" /> flag.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetParent")]
		public static extern IntPtr GetParent([In] IntPtr hWnd);

		/// <summary>
		///     <para>Retrieves a handle to the current cursor.</para>
		///     <para>
		///         To get information on the global cursor, even if it is not owned by the current thread, use <see cref="GetCursorInfo" />.
		///     </para>
		/// </summary>
		/// <returns>The return value is the handle to the current cursor. If there is no cursor, the return value is NULL.</returns>
		[DllImport("user32.dll", EntryPoint = "GetCursor")]
		public static extern IntPtr GetCursor();

		/// <summary>
		///     The <see cref="FrameRect" /> function draws a border around the specified rectangle by using the specified brush. The width and height of the
		///     border are always one logical unit.
		/// </summary>
		/// <param name="hDC">A handle to the device context in which the border is drawn.</param>
		/// <param name="lprc">
		///     A pointer to a <see cref="RECT" /> structure that contains the logical coordinates of the upper-left and lower-right corners of the rectangle.
		/// </param>
		/// <param name="hbr">A handle to the brush used to draw the border.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The brush identified by the <paramref name="hbr" /> parameter must have been created by using the <see cref="CreateHatchBrush" />,
		///         <see cref="CreatePatternBrush" />, or <see cref="CreateSolidBrush" /> function, or retrieved by using the <see cref="GetStockObject" />
		///         function.
		///     </para>
		///     <para>
		///         If the <see cref="bottom" /> member of the <see cref="RECT" /> structure is less than the <see cref="top" /> member, or if the
		///         <see cref="right" /> member is less than the <see cref="left" /> member, the function does not draw the rectangle.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "FrameRect")]
		public static extern int FrameRect([In] IntPtr hDC, [In] ref RECT lprc, [In] IntPtr hbr);

		/// <summary>
		///     The <see cref="EqualRect" /> function determines whether the two specified rectangles are equal by comparing the coordinates of their upper-left
		///     and lower-right corners.
		/// </summary>
		/// <param name="lprc1">
		///     Pointer to a <see cref="RECT" /> structure that contains the logical coordinates of the first rectangle.
		/// </param>
		/// <param name="lprc2">
		///     Pointer to a <see cref="RECT" /> structure that contains the logical coordinates of the second rectangle.
		/// </param>
		/// <returns>
		///     <para>If the two rectangles are identical, the return value is nonzero.</para>
		///     <para>If the two rectangles are not identical, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="EqualRect" /> function does not treat empty rectangles as equal if their coordinates are different.
		///     </para>
		///     <para>
		///         Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all
		///         rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used
		///         determine the units of measure.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "EqualRect")]
		public static extern bool EqualRect([In] ref RECT lprc1, [In] ref RECT lprc2);

		/// <summary>Destroys a modal dialog box, causing the system to end any processing for the dialog box.</summary>
		/// <param name="hDlg">A handle to the dialog box to be destroyed.</param>
		/// <param name="nResult">The value to be returned to the application from the function that created the dialog box.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Dialog boxes created by the <see cref="DialogBox" />, <see cref="DialogBoxParam" />, <see cref="DialogBoxIndirect" />, and
		///         <see cref="DialogBoxIndirectParam" /> functions must be destroyed using the <see cref="EndDialog" /> function. An application calls
		///         <see cref="EndDialog" /> from within the dialog box procedure; the function must not be used for any other purpose.
		///     </para>
		///     <para>
		///         A dialog box procedure can call <see cref="EndDialog" /> at any time, even during the processing of the <see cref="WM.WM_INITDIALOG" />
		///         message. If your application calls the function while <see cref="WM.WM_INITDIALOG" /> is being processed, the dialog box is destroyed before
		///         it is shown and before the input focus is set.
		///     </para>
		///     <para>
		///         <see cref="EndDialog" /> does not destroy the dialog box immediately. Instead, it sets a flag and allows the dialog box procedure to return
		///         control to the system. The system checks the flag before attempting to retrieve the next message from the application queue. If the flag is
		///         set, the system ends the message loop, destroys the dialog box, and uses the value in <paramref name="nResult" /> as the return value from
		///         the function that created the dialog box.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "EndDialog")]
		public static extern bool EndDialog([In] IntPtr hDlg, int nResult);

		/// <summary>
		///     <para>
		///         The <see cref="DrawText" /> function draws formatted text in the specified rectangle. It formats the text according to the specified method
		///         (expanding tabs, justifying characters, breaking lines, and so forth).
		///     </para>
		///     <para>
		///         To specify additional formatting options, use the <see cref="DrawTextEx" /> function.
		///     </para>
		/// </summary>
		/// <param name="hDC">A handle to the device context.</param>
		/// <param name="lpchText">
		///     <para>
		///         A pointer to the string that specifies the text to be drawn. If the <paramref name="nCount" /> parameter is -1, the string must be
		///         null-terminated.
		///     </para>
		///     <para>
		///         If <paramref name="uFormat" /> includes DT_MODIFYSTRING, the function could add up to four additional characters to this string. The buffer
		///         containing the string should be large enough to accommodate these extra characters.
		///     </para>
		/// </param>
		/// <param name="nCount">
		///     The length, in characters, of the string. If <paramref name="nCount" /> is -1, then the <paramref name="lpchText" /> parameter is assumed to be a
		///     pointer to a null-terminated string and <see cref="DrawText" /> computes the character count automatically.
		/// </param>
		/// <param name="lpRect">
		///     A pointer to a <see cref="RECT" /> structure that contains the rectangle (in logical coordinates) in which the text is to be formatted.
		/// </param>
		/// <param name="uFormat">
		///     <para>The method of formatting the text. This parameter can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>DT_BOTTOM</term>
		///             <description>Justifies the text to the bottom of the rectangle. This value is used only with the DT_SINGLELINE value.</description>
		///         </item>
		///         <item>
		///             <term>DT_CALCRECT</term>
		///             <description>
		///                 Determines the width and height of the rectangle. If there are multiple lines of text, <see cref="DrawText" /> uses the width of the
		///                 rectangle pointed to by the <paramref name="lpRect" /> parameter and extends the base of the rectangle to bound the last line of
		///                 text. If the largest word is wider than the rectangle, the width is expanded. If the text is less than the width of the rectangle,
		///                 the width is reduced. If there is only one line of text, <see cref="DrawText" /> modifies the right side of the rectangle so that it
		///                 bounds the last character in the line. In either case, <see cref="DrawText" /> returns the height of the formatted text but does not
		///                 draw the text.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_CENTER</term>
		///             <description>Centers text horizontally in the rectangle.</description>
		///         </item>
		///         <item>
		///             <term>DT_EDITCONTROL</term>
		///             <description>
		///                 Duplicates the text-displaying characteristics of a multiline edit control. Specifically, the average character width is calculated
		///                 in the same manner as for an edit control, and the function does not display a partially visible last line.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_END_ELLIPSIS</term>
		///             <description>
		///                 <para>
		///                     For displayed text, if the end of a string does not fit in the rectangle, it is truncated and ellipses are added. If a word that
		///                     is not at the end of the string goes beyond the limits of the rectangle, it is truncated without ellipses.
		///                 </para>
		///                 <para>The string is not modified unless the DT_MODIFYSTRING flag is specified.</para>
		///                 <para>Compare with DT_PATH_ELLIPSIS and DT_WORD_ELLIPSIS.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_EXPANDTABS</term>
		///             <description>
		///                 Expands tab characters. The default number of characters per tab is eight. The DT_WORD_ELLIPSIS, DT_PATH_ELLIPSIS, and
		///                 DT_END_ELLIPSIS values cannot be used with the DT_EXPANDTABS value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_EXTERNALLEADING</term>
		///             <description>
		///                 Includes the font external leading in line height. Normally, external leading is not included in the height of a line of
		///                 text.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_HIDEPREFIX</term>
		///             <description>
		///                 <para>
		///                     Ignores the ampersand (&amp;) prefix character in the text. The letter that follows will not be underlined, but other
		///                     mnemonic-prefix characters are still processed.
		///                 </para>
		///                 <para>Example:</para>
		///                 <para>input string: "A&amp;bc&amp;&amp;d"</para>
		///                 <para>normal: "Abc&amp;d"</para>
		///                 <para>DT_HIDEPREFIX: "Abc&amp;d"</para>
		///                 <para>Compare with DT_NOPREFIX and DT_PREFIXONLY.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_INTERNAL</term>
		///             <description>Uses the system font to calculate text metrics.</description>
		///         </item>
		///         <item>
		///             <term>DT_LEFT</term>
		///             <description>Aligns text to the left.</description>
		///         </item>
		///         <item>
		///             <term>DT_MODIFYSTRING</term>
		///             <description>
		///                 Modifies the specified string to match the displayed text. This value has no effect unless DT_END_ELLIPSIS or
		///                 DT_PATH_ELLIPSIS is specified.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_NOCLIP</term>
		///             <description>
		///                 Draws without clipping. <see cref="DrawText" /> is somewhat faster when DT_NOCLIP is used.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_NOFULLWIDTHCHARBREAK</term>
		///             <description>
		///                 Prevents a line break at a DBCS (double-wide character string), so that the line breaking rule is equivalent to SBCS strings. For
		///                 example, this can be used in Korean windows, for more readability of icon labels. This value has no effect unless DT_WORDBREAK is
		///                 specified.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_NOPREFIX</term>
		///             <description>
		///                 <para>
		///                     Turns off processing of prefix characters. Normally, <see cref="DrawText" /> interprets the mnemonic-prefix character &amp; as a
		///                     directive to underscore the character that follows, and the mnemonic-prefix characters &amp;&amp; as a directive to print a
		///                     single &amp;. By specifying DT_NOPREFIX, this processing is turned off. For example,
		///                 </para>
		///                 <para>Example:</para>
		///                 <para>input string: "A&amp;bc&amp;&amp;d"</para>
		///                 <para>normal: "Abc&amp;d"</para>
		///                 <para>DT_NOPREFIX: "A&amp;bc&amp;&amp;d"</para>
		///                 <para>Compare with DT_HIDEPREFIX and DT_PREFIXONLY.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_PATH_ELLIPSIS</term>
		///             <description>
		///                 <para>
		///                     For displayed text, replaces characters in the middle of the string with ellipses so that the result fits in the specified
		///                     rectangle. If the string contains backslash (\) characters, DT_PATH_ELLIPSIS preserves as much as possible of the text after the
		///                     last backslash.
		///                 </para>
		///                 <para>The string is not modified unless the DT_MODIFYSTRING flag is specified.</para>
		///                 <para>Compare with DT_END_ELLIPSIS and DT_WORD_ELLIPSIS.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_PREFIXONLY</term>
		///             <description>
		///                 <para>
		///                     Draws only an underline at the position of the character following the ampersand (&amp;) prefix character. Does not draw any
		///                     other characters in the string. For example,
		///                 </para>
		///                 <para>Example:</para>
		///                 <para>input string: "A&amp;bc&amp;&amp;d"n</para>
		///                 <para>normal: "Abc&amp;d"</para>
		///                 <para>DT_PREFIXONLY: " _ "</para>
		///                 <para>Compare with DT_HIDEPREFIX and DT_NOPREFIX.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_RIGHT</term>
		///             <description>Aligns text to the right.</description>
		///         </item>
		///         <item>
		///             <term>DT_RTLREADING</term>
		///             <description>
		///                 Layout in right-to-left reading order for bidirectional text when the font selected into the <paramref name="hdc" /> is a Hebrew or
		///                 Arabic font. The default reading order for all text is left-to-right.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_SINGLELINE</term>
		///             <description>Displays text on a single line only. Carriage returns and line feeds do not break the line.</description>
		///         </item>
		///         <item>
		///             <term>DT_TABSTOP</term>
		///             <description>
		///                 Sets tab stops. Bits 15-8 (high-order byte of the low-order word) of the <paramref name="uFormat" /> parameter specify the number of
		///                 characters for each tab. The default number of characters per tab is eight. The DT_CALCRECT, DT_EXTERNALLEADING, DT_INTERNAL,
		///                 DT_NOCLIP, and DT_NOPREFIX values cannot be used with the DT_TABSTOP value.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_TOP</term>
		///             <description>Justifies the text to the top of the rectangle.</description>
		///         </item>
		///         <item>
		///             <term>DT_VCENTER</term>
		///             <description>Centers text vertically. This value is used only with the DT_SINGLELINE value.</description>
		///         </item>
		///         <item>
		///             <term>DT_WORDBREAK</term>
		///             <description>
		///                 <para>
		///                     Breaks words. Lines are automatically broken between words if a word would extend past the edge of the rectangle specified by the
		///                     <paramref name="lpRect" /> parameter. A carriage return-line feed sequence also breaks the line.
		///                 </para>
		///                 <para>If this is not specified, output is on one line.</para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>DT_WORD_ELLIPSIS</term>
		///             <description>
		///                 <para>Truncates any word that does not fit in the rectangle and adds ellipses.</para>
		///                 <para>Compare with DT_END_ELLIPSIS and DT_PATH_ELLIPSIS.</para>
		///             </description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds, the return value is the height of the text in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return
		///         value is the offset from lpRect->top to the bottom of the drawn text
		///     </para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="DrawText" /> function uses the device context's selected font, text color, and background color to draw the text. Unless the
		///         DT_NOCLIP format is used, <see cref="DrawText" /> clips the text so that it does not appear outside the specified rectangle. Note that text
		///         with significant overhang may be clipped, for example, an initial "W" in the text string or text that is in italics. All formatting is
		///         assumed to have multiple lines unless the DT_SINGLELINE format is specified.
		///     </para>
		///     <para>
		///         If the selected font is too large for the specified rectangle, the <see cref="DrawText" /> function does not attempt to substitute a smaller
		///         font.
		///     </para>
		///     <para>The text alignment mode for the device context must include the TA_LEFT, TA_TOP, and TA_NOUPDATECP flags.</para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "DrawText")]
		public static extern int DrawText([In] IntPtr hDC, StringBuilder lpchText, int nCount, ref RECT lpRect, uint uFormat);

		/// <summary>
		///     Creates a new image (icon, cursor, or bitmap) and copies the attributes of the specified image to the new one. If necessary, the function
		///     stretches the bits to fit the desired size of the new image.
		/// </summary>
		/// <param name="hImage">A handle to the image to be copied.</param>
		/// <param name="uType">
		///     <para>The type of image to be copied. This parameter can be one of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>IMAGE_BITMAP 0</term>
		///             <description>Copies a bitmap.</description>
		///         </item>
		///         <item>
		///             <term>IMAGE_CURSOR 2</term>
		///             <description>Copies a cursor.</description>
		///         </item>
		///         <item>
		///             <term>IMAGE_ICON 1</term>
		///             <description>Copies an icon.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="cxDesired">
		///     The desired width, in pixels, of the image. If this is zero, then the returned image will have the same width as the original
		///     <paramref name="hImage" />.
		/// </param>
		/// <param name="cyDesired">
		///     The desired height, in pixels, of the image. If this is zero, then the returned image will have the same height as the original
		///     <paramref name="hImage" />.
		/// </param>
		/// <param name="fuFlags">
		///     <para>This parameter can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>LR_COPYDELETEORG 0x00000008</term>
		///             <description>Deletes the original image after creating the copy.</description>
		///         </item>
		///         <item>
		///             <term>LR_COPYFROMRESOURCE 0x00004000</term>
		///             <description>
		///                 Tries to reload an icon or cursor resource from the original resource file rather than simply copying the current image. This is
		///                 useful for creating a different-sized copy when the resource file contains multiple sizes of the resource. Without this flag,
		///                 <see cref="CopyImage" /> stretches the original image to the new size. If this flag is set, <see cref="CopyImage" /> uses the size in
		///                 the resource file closest to the desired size. This will succeed only if <paramref name="hImage" /> was loaded by
		///                 <see cref="LoadIcon" /> or <see cref="LoadCursor" />, or by <see cref="LoadImage" /> with the LR_SHARED flag.
		///             </description>
		///         </item>
		///         <item>
		///             <term>LR_COPYRETURNORG 0x00000004</term>
		///             <description>
		///                 Returns the original <paramref name="hImage" /> if it satisfies the criteria for the copy—that is, correct dimensions and color
		///                 depth—in which case the <see cref="LR_COPYDELETEORG" /> flag is ignored. If this flag is not specified, a new object is always
		///                 created.
		///             </description>
		///         </item>
		///         <item>
		///             <term>LR_CREATEDIBSECTION 0x00002000</term>
		///             <description>
		///                 If this is set and a new bitmap is created, the bitmap is created as a DIB section. Otherwise, the bitmap image is created as a
		///                 device-dependent bitmap. This flag is only valid if <paramref name="uType" /> is <see cref="IMAGE_BITMAP" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>LR_DEFAULTSIZE 0x00000040</term>
		///             <description>
		///                 Uses the width or height specified by the system metric values for cursors or icons, if the <paramref name="cxDesired" /> or
		///                 <paramref name="cyDesired" /> values are set to zero. If this flag is not specified and <paramref name="cxDesired" /> and
		///                 <paramref name="cyDesired" /> are set to zero, the function uses the actual resource size. If the resource contains multiple images,
		///                 the function uses the size of the first image.
		///             </description>
		///         </item>
		///         <item>
		///             <term>LR_MONOCHROME 0x00000001</term>
		///             <description>Creates a new monochrome image.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the handle to the newly created image.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>When you are finished using the resource, you can release its associated memory by calling one of the functions in the following table.</remarks>
		[DllImport("user32.dll", EntryPoint = "CopyImage")]
		public static extern IntPtr CopyImage([In] IntPtr h, uint type, int cx, int cy, LR flags);

		/// <summary>
		///     Retrieves a pointer to the preceding character in a string. This function can handle strings consisting of either single- or multi-byte
		///     characters.
		/// </summary>
		/// <param name="lpszStart">The beginning of the string.</param>
		/// <param name="lpszCurrent">A character in a null-terminated string.</param>
		/// <returns>
		///     The return value is a pointer to the preceding character in the string, or to the first character in the string if the
		///     <paramref name="lpszCurrent" /> parameter equals the <paramref name="lpszStart" /> parameter.
		/// </returns>
		/// <remarks>
		///     <para>
		///         When called as an ANSI function, <see cref="CharPrev" /> uses the system default code-page, whereas <see cref="CharPrevExA" /> specifies a
		///         code-page to use.
		///     </para>
		///     <para>
		///         This function works with default "user" expectations of characters when dealing with diacritics. For example: A string that contains U+0061
		///         U+030a "LATIN SMALL LETTER A" + COMBINING RING ABOVE" — which looks like "å", will advance two code points, not one. A string that contains
		///         U+0061 U+0301 U+0302 U+0303 U+0304 — which looks like "a´^~¯", will advance five code points, not one, and so on.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CharPrev")]
		public static extern string CharPrev([In] string lpszStart, [In] string lpszCurrent);

		/// <summary>
		///     Retrieves a pointer to the next character in a string. This function can handle strings consisting of either single- or multi-byte
		///     characters.
		/// </summary>
		/// <param name="lpsz">A character in a null-terminated string.</param>
		/// <returns>
		///     <para>The return value is a pointer to the next character in the string, or to the terminating null character if at the end of the string.</para>
		///     <para>
		///         If <paramref name="lpsz" /> points to the terminating null character, the return value is equal to <paramref name="lpsz" />.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         When called as an ANSI function, CharNextW uses the system default code-page, whereas CharNextExA specifies a
		///         code-page to use.
		///     </para>
		///     <para>
		///         This function works with default "user" expectations of characters when dealing with diacritics. For example: A string that contains U+0061
		///         U+030a "LATIN SMALL LETTER A" + COMBINING RING ABOVE" — which looks like "å", will advance two code points, not one. A string that contains
		///         U+0061 U+0301 U+0302 U+0303 U+0304 — which looks like "a´^~¯", will advance five code points, not one, and so on.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CharNext")]
		public static extern string CharNext([In] string lpsz);

		/// <summary>Launches Windows Help (Winhelp.exe) and passes additional data that indicates the nature of the help requested by the application.</summary>
		/// <param name="hWndMain">
		///     A handle to the window requesting help. The <see cref="WinHelp" /> function uses this handle to keep track of which applications have requested
		///     help. If the <paramref name="uCommand" /> parameter specifies <see cref="HELP_CONTEXTMENU" /> or <see cref="HELP_WM_HELP" />,
		///     <paramref name="hWndMain" /> identifies the control requesting help.
		/// </param>
		/// <param name="lpszHelp">
		///     <para>
		///         The address of a null-terminated string containing the path, if necessary, and the name of the Help file that <see cref="WinHelp" /> is to
		///         display.
		///     </para>
		///     <para>
		///         The file name can be followed by an angle bracket (>) and the name of a secondary window if the topic is to be displayed in a secondary
		///         window rather than in the primary window. You must define the name of the secondary window in the [WINDOWS] section of the Help project
		///         (.hpj) file.
		///     </para>
		/// </param>
		/// <param name="uCommand">
		///     The type of help requested. For a list of possible values and how they affect the value to place in the <paramref name="dwData" /> parameter, see
		///     the Remarks section.
		/// </param>
		/// <param name="dwData">
		///     Additional data. The value used depends on the value of the <paramref name="uCommand" /> parameter. For a list of possible
		///     <paramref name="dwData" /> values, see the Remarks section.
		/// </param>
		/// <returns>Returns nonzero if successful, or zero otherwise. To retrieve extended error information, call GetLastError.</returns>
		/// <remarks>
		///     <para>
		///         Before closing the window that requested help, the application must call <see cref="WinHelp" /> with the <paramref name="uCommand" />
		///         parameter set to HELP_QUIT. Until all applications have done this, Windows Help will not terminate. Note that calling Windows Help with the
		///         HELP_QUIT command is not necessary if you used the HELP_CONTEXTPOPUP command to start Windows Help.
		///     </para>
		///     <para>This function fails if called from any context but the current user.</para>
		///     <para>
		///         The following table shows the possible values for the <paramref name="uCommand" /> parameter and the corresponding formats of the
		///         <paramref name="dwData" /> parameter.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "WinHelp")]
		public static extern bool WinHelp([In] IntPtr hWndMain, [In] string lpszHelp, uint uCommand, uint dwData);

		/// <summary>Creates a timer with the specified time-out value.</summary>
		/// <param name="hWnd">
		///     A handle to the window to be associated with the timer. This window must be owned by the calling thread. If a NULL value for
		///     <paramref name="hWnd" /> is passed in along with an <paramref name="nIDEvent" /> of an existing timer, that timer will be replaced in the same
		///     way that an existing non-NULL <paramref name="hWnd" /> timer will be.
		/// </param>
		/// <param name="nIDEvent">
		///     A nonzero timer identifier. If the <paramref name="hWnd" /> parameter is NULL, and the <paramref name="nIDEvent" /> does not match an existing
		///     timer then it is ignored and a new timer ID is generated. If the <paramref name="hWnd" /> parameter is not NULL and the window specified by
		///     <paramref name="hWnd" /> already has a timer with the value <paramref name="nIDEvent" />, then the existing timer is replaced by the new timer.
		///     When <see cref="SetTimer" /> replaces a timer, the timer is reset. Therefore, a message will be sent after the current time-out value elapses,
		///     but the previously set time-out value is ignored. If the call is not intended to replace an existing timer, <paramref name="nIDEvent" /> should
		///     be 0 if the <paramref name="hWnd" /> is NULL.
		/// </param>
		/// <param name="uElapse">
		///     <para>The time-out value, in milliseconds.</para>
		///     <para>
		///         If <paramref name="uElapse" /> is less than USER_TIMER_MINIMUM (0x0000000A), the timeout is set to
		///         USER_TIMER_MINIMUM. If <paramref name="uElapse" /> is greater than USER_TIMER_MAXIMUM (0x7FFFFFFF), the timeout
		///         is set to USER_TIMER_MAXIMUM.
		///     </para>
		/// </param>
		/// <param name="lpTimerFunc">
		///     A pointer to the function to be notified when the time-out value elapses. For more information about the function, see <see cref="TimerProc" />.
		///     If <paramref name="lpTimerFunc" /> is NULL, the system posts a <see cref="WM.WM_TIMER" /> message to the application queue. The
		///     <see cref="MSG.hwnd" /> member of the message's <see cref="MSG" /> structure contains the value of the <paramref name="hWnd" /> parameter.
		/// </param>
		/// <returns>
		///     <para>
		///         If the function succeeds and the <paramref name="hWnd" /> parameter is NULL, the return value is an integer identifying the new timer. An
		///         application can pass this value to the <see cref="KillTimer" /> function to destroy the timer.
		///     </para>
		///     <para>
		///         If the function succeeds and the <paramref name="hWnd" /> parameter is not NULL, then the return value is a nonzero integer. An application
		///         can pass the value of the <paramref name="nIDEvent" /> parameter to the <see cref="KillTimer" /> function to destroy the timer.
		///     </para>
		///     <para>If the function fails to create a timer, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         An application can process <see cref="WM.WM_TIMER" /> messages by including a <see cref="WM.WM_TIMER" /> case statement in the window
		///         procedure or by specifying a <see cref="TimerProc" /> callback function when creating the timer. When you specify a <see cref="TimerProc" />
		///         callback function, the default window procedure calls the callback function when it processes <see cref="WM.WM_TIMER" />. Therefore, you need
		///         to dispatch messages in the calling thread, even when you use <see cref="TimerProc" /> instead of processing <see cref="WM.WM_TIMER" />.
		///     </para>
		///     <para>
		///         The wParam parameter of the <see cref="WM.WM_TIMER" /> message contains the value of the <paramref name="nIDEvent" />
		///         parameter.
		///     </para>
		///     <para>
		///         The timer identifier, <paramref name="nIDEvent" />, is specific to the associated window. Another window can have its own timer which has the
		///         same identifier as a timer owned by another window. The timers are distinct.
		///     </para>
		///     <para>
		///         <see cref="SetTimer" /> can reuse timer IDs in the case where <paramref name="hWnd" /> is NULL.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.SysUInt)]
		[DllImport("user32.dll", EntryPoint = "SetTimer")]
		public static extern uint SetTimer([In] IntPtr hWnd, [MarshalAs(UnmanagedType.SysUInt)] uint nIDEvent, uint uElapse, TimerProc lpTimerFunc);

		/// <summary>
		///     Adds a new entry or changes an existing entry in the property list of the specified window. The function adds a new entry to the list if the
		///     specified character string does not exist already in the list. The new entry contains the string and the handle. Otherwise, the function replaces
		///     the string's current handle with the specified handle.
		/// </summary>
		/// <param name="hWnd">A handle to the window whose property list receives the new entry.</param>
		/// <param name="lpString">
		///     A null-terminated string or an atom that identifies a string. If this parameter is an atom, it must be a global atom created by a previous call
		///     to the GlobalAddAtom function. The atom must be placed in the low-order word of <paramref name="lpString" />; the high-order word
		///     must be zero.
		/// </param>
		/// <param name="hData">A handle to the data to be copied to the property list. The data handle can identify any value useful to the application.</param>
		/// <returns>
		///     <para>If the data handle and string are added to the property list, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Before a window is destroyed (that is, before it returns from processing the <see cref="WM.WM_NCDESTROY" /> message), an application must
		///         remove all entries it has added to the property list. The application must use the <see cref="RemoveProp" /> function to remove the entries.
		///     </para>
		///     <para>
		///         <see cref="SetProp" /> is subject to the restrictions of User Interface Privilege Isolation (UIPI). A process can only call this function on
		///         a window belonging to a process of lesser or equal integrity level. When UIPI blocks property changes, GetLastError will return 5.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetProp")]
		public static extern bool SetProp([In] IntPtr hWnd, [In] string lpString, [In] IntPtr hData);

		/// <summary>Sets the keyboard focus to the specified window. The window must be attached to the calling thread's message queue.</summary>
		/// <param name="hWnd">A handle to the window that will receive the keyboard input. If this parameter is NULL, keystrokes are ignored.</param>
		/// <returns>
		///     If the function succeeds, the return value is the handle to the window that previously had the keyboard focus. If the <paramref name="hWnd" />
		///     parameter is invalid or the window is not attached to the calling thread's message queue, the return value is NULL. To get extended error
		///     information, call GetLastError.
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="SetFocus" /> function sends a <see cref="WM.WM_KILLFOCUS" /> message to the window that loses the keyboard focus and a
		///         <see cref="WM.WM_SETFOCUS" /> message to the window that receives the keyboard focus. It also activates either the window that receives the
		///         focus or the parent of the window that receives the focus.
		///     </para>
		///     <para>
		///         If a window is active but does not have the focus, any key pressed will produce the <see cref="WM.WM_SYSCHAR" />,
		///         <see cref="WM.WM_SYSKEYDOWN" />, or <see cref="WM.WM_SYSKEYUP" /> message. If the <see cref="VK.VK_MENU" /> key is also pressed, the
		///         lParam parameter of the message will have bit 30 set. Otherwise, the messages produced do not have this bit set.
		///     </para>
		///     <para>
		///         By using the <see cref="AttachThreadInput" /> function, a thread can attach its input processing to another thread. This allows a thread to
		///         call <see cref="SetFocus" /> to set the keyboard focus to a window attached to another thread's message queue.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "SetFocus")]
		public static extern IntPtr SetFocus([In] IntPtr hWnd);

		/// <summary>
		///     The <see cref="ScrollDC" /> function scrolls a rectangle of bits horizontally and vertically.
		/// </summary>
		/// <param name="hDC">Handle to the device context that contains the bits to be scrolled.</param>
		/// <param name="dx">Specifies the amount, in device units, of horizontal scrolling. This parameter must be a negative value to scroll to the left.</param>
		/// <param name="dy">Specifies the amount, in device units, of vertical scrolling. This parameter must be a negative value to scroll up.</param>
		/// <param name="lprcScroll">
		///     Pointer to a <see cref="RECT" /> structure containing the coordinates of the bits to be scrolled. The only bits affected by the scroll operation
		///     are bits in the intersection of this rectangle and the rectangle specified by <paramref name="lprcClip" />. If <paramref name="lprcScroll" /> is
		///     NULL, the entire client area is used.
		/// </param>
		/// <param name="lprcClip">
		///     Pointer to a <see cref="RECT" /> structure containing the coordinates of the clipping rectangle. The only bits that will be painted are the bits
		///     that remain inside this rectangle after the scroll operation has been completed. If <paramref name="lprcClip" /> is NULL, the entire client area
		///     is used.
		/// </param>
		/// <param name="hrgnUpdate">
		///     Handle to the region uncovered by the scrolling process. <see cref="ScrollDC" /> defines this region; it is not necessarily a rectangle.
		/// </param>
		/// <param name="lprcUpdate">
		///     Pointer to a <see cref="RECT" /> structure that receives the coordinates of the rectangle bounding the scrolling update region. This is the
		///     largest rectangular area that requires repainting. When the function returns, the values in the structure are in client coordinates, regardless
		///     of the mapping mode for the specified device context. This allows applications to use the update region in a call to the
		///     <see cref="InvalidateRgn" /> function, if required.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         If the <paramref name="lprcUpdate" /> parameter is NULL, the system does not compute the update rectangle. If both the
		///         <paramref name="hrgnUpdate" /> and <paramref name="lprcUpdate" /> parameters are NULL, the system does not compute the update region. If
		///         <paramref name="hrgnUpdate" /> is not NULL, the system proceeds as though it contains a valid handle to the region uncovered by the scrolling
		///         process (defined by <see cref="ScrollDC" />).
		///     </para>
		///     <para>
		///         When you must scroll the entire client area of a window, use the <see cref="ScrollWindowEx" /> function.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "ScrollDC")]
		public static extern bool ScrollDC(
			[In] IntPtr hDC, int dx, int dy, [In] ref RECT lprcScroll, [In] ref RECT lprcClip, [In] IntPtr hrgnUpdate, ref RECT lprcUpdate);

		/// <summary>
		///     The <see cref="PtInRect" /> function determines whether the specified point lies within the specified rectangle. A point is within a rectangle if
		///     it lies on the left or top side or is within all four sides. A point on the right or bottom side is considered outside the rectangle.
		/// </summary>
		/// <param name="lprc">
		///     A pointer to a <see cref="RECT" /> structure that contains the specified rectangle.
		/// </param>
		/// <param name="pt">
		///     A <see cref="POINT" /> structure that contains the specified point.
		/// </param>
		/// <returns>
		///     <para>If the specified point lies within the rectangle, the return value is nonzero.</para>
		///     <para>If the specified point does not lie within the rectangle, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The rectangle must be normalized before <see cref="PtInRect" /> is called. That is, lprc.right must be greater than lprc.left and lprc.bottom
		///         must be greater than lprc.top. If the rectangle is not normalized, a point is never considered inside of the rectangle.
		///     </para>
		///     <para>
		///         Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all
		///         rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used
		///         determine the units of measure.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "PtInRect")]
		public static extern bool PtInRect([In] ref RECT lprc, POINT pt);

		/// <summary>Restores a minimized (iconic) window to its previous size and position; it then activates the window.</summary>
		/// <param name="hWnd">A handle to the window to be restored and activated.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <see cref="OpenIcon" /> sends a <see cref="WM.WM_QUERYOPEN" /> message to the given window.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "OpenIcon")]
		public static extern bool OpenIcon([In] IntPtr hWnd);

		/// <summary>Determines whether a window is maximized.</summary>
		/// <param name="hWnd">A handle to the window to be tested.</param>
		/// <returns>
		///     <para>If the window is zoomed, the return value is nonzero.</para>
		///     <para>If the window is not zoomed, the return value is zero.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "IsZoomed")]
		public static extern bool IsZoomed([In] IntPtr hWnd);

		/// <summary>Determines whether the specified window handle identifies an existing window.</summary>
		/// <param name="hWnd">A handle to the window to be tested.</param>
		/// <returns>
		///     <para>If the window handle identifies an existing window, the return value is nonzero.</para>
		///     <para>If the window handle does not identify an existing window, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     A thread should not use <see cref="IsWindow" /> for a window that it did not create because the window could be destroyed after this function was
		///     called. Further, because window handles are recycled the handle could even point to a different window.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "IsWindow")]
		public static extern bool IsWindow([In] IntPtr hWnd);

		/// <summary>Determines whether the specified window is minimized (iconic).</summary>
		/// <param name="hWnd">A handle to the window to be tested.</param>
		/// <returns>
		///     <para>If the window is iconic, the return value is nonzero.</para>
		///     <para>If the window is not iconic, the return value is zero.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "IsIconic")]
		public static extern bool IsIconic([In] IntPtr hWnd);

		/// <summary>
		///     Retrieves a data handle from the property list of the specified window. The character string identifies the handle to be retrieved. The string
		///     and handle must have been added to the property list by a previous call to the <see cref="SetProp" /> function.
		/// </summary>
		/// <param name="hWnd">A handle to the window whose property list is to be searched.</param>
		/// <param name="lpString">
		///     An atom that identifies a string. If this parameter is an atom, it must have been created by using the GlobalAddAtom function. The
		///     atom, a 16-bit value, must be placed in the low-order word of the <paramref name="lpString" /> parameter; the high-order word must be zero.
		/// </param>
		/// <returns>
		///     <para>If the property list contains the string, the return value is the associated data handle. Otherwise, the return value is NULL.</para>
		/// </returns>
		[DllImport("user32.dll", EntryPoint = "GetProp")]
		public static extern IntPtr GetProp([In] IntPtr hWnd, [In] string lpString);

		/// <summary>Retrieves the handle to the window that has the keyboard focus, if the window is attached to the calling thread's message queue.</summary>
		/// <returns>
		///     The return value is the handle to the window with the keyboard focus. If the calling thread's message queue does not have an associated window
		///     with the keyboard focus, the return value is NULL.
		/// </returns>
		/// <remarks>
		///     <para>
		///         <see cref="GetFocus" /> returns the window with the keyboard focus for the current thread's message queue. If <see cref="GetFocus" /> returns
		///         NULL, another thread's queue may be attached to a window that has the keyboard focus.
		///     </para>
		///     <para>
		///         Use the <see cref="GetForegroundWindow" /> function to retrieve the handle to the window with which the user is currently working. You can
		///         associate your thread's message queue with the windows owned by another thread by using the <see cref="AttachThreadInput" /> function.
		///     </para>
		///     <para>
		///         To get the window with the keyboard focus on the foreground queue or the queue of another thread, use the <see cref="GetGUIThreadInfo" />
		///         function.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetFocus")]
		public static extern IntPtr GetFocus();

		/// <summary>
		///     The <see cref="FillRect" /> function fills a rectangle by using the specified brush. This function includes the left and top borders, but
		///     excludes the right and bottom borders of the rectangle.
		/// </summary>
		/// <param name="hDC">A handle to the device context.</param>
		/// <param name="lprc">
		///     A pointer to a <see cref="RECT" /> structure that contains the logical coordinates of the rectangle to be filled.
		/// </param>
		/// <param name="hbr">A handle to the brush used to fill the rectangle.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     The brush identified by the <paramref name="hbr" /> parameter may be either a handle to a logical brush or a color value. If specifying a handle
		///     to a logical brush, call one of the following functions to obtain the handle: <see cref="CreateHatchBrush" />, <see cref="CreatePatternBrush" />,
		///     or <see cref="CreateSolidBrush" />. Additionally, you may retrieve a handle to one of the stock brushes by using the
		///     <see cref="GetStockObject" /> function. If specifying a color value for the <paramref name="hbr" /> parameter, it must be one of the standard
		///     system colors (the value 1 must be added to the chosen color). For example:
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "FillRect")]
		public static extern int FillRect([In] IntPtr hDC, [In] ref RECT lprc, [In] IntPtr hbr);

		/// <summary>
		///     The <see cref="EndPaint" /> function marks the end of painting in the specified window. This function is required for each call to the
		///     <see cref="BeginPaint" /> function, but only after painting is complete.
		/// </summary>
		/// <param name="hWnd">Handle to the window that has been repainted.</param>
		/// <param name="lpPaint">
		///     Pointer to a <see cref="PAINTSTRUCT" /> structure that contains the painting information retrieved by <see cref="BeginPaint" />.
		/// </param>
		/// <returns>The return value is always nonzero.</returns>
		/// <remarks>
		///     <para>
		///         If the caret was hidden by <see cref="BeginPaint" />, <see cref="EndPaint" /> restores the caret to the screen.
		///     </para>
		///     <para>
		///         <see cref="EndPaint" /> releases the display device context that <see cref="BeginPaint" /> retrieved.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "EndPaint")]
		public static extern bool EndPaint([In] IntPtr hWnd, [In] ref PAINTSTRUCT lpPaint);

		/// <summary>
		///     <para>Draws an icon or cursor into the specified device context.</para>
		///     <para>
		///         To specify additional drawing options, use the <see cref="DrawIconEx" /> function.
		///     </para>
		/// </summary>
		/// <param name="hDC">A handle to the device context into which the icon or cursor will be drawn.</param>
		/// <param name="X">The logical x-coordinate of the upper-left corner of the icon.</param>
		/// <param name="Y">The logical y-coordinate of the upper-left corner of the icon.</param>
		/// <param name="hIcon">A handle to the icon to be drawn.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         <see cref="DrawIcon" /> places the icon's upper-left corner at the location specified by the <paramref name="X" /> and <paramref name="Y" />
		///         parameters. The location is subject to the current mapping mode of the device context.
		///     </para>
		///     <para>
		///         <see cref="DrawIcon" /> draws the icon or cursor using the width and height specified by the system metric values for icons; for more
		///         information, see <see cref="GetSystemMetrics" />.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DrawIcon")]
		public static extern bool DrawIcon([In] IntPtr hDC, int X, int Y, [In] IntPtr hIcon);

		/// <summary>
		///     The <see cref="DrawEdge" /> function draws one or more edges of rectangle.
		/// </summary>
		/// <param name="hdc">A handle to the device context.</param>
		/// <param name="qrc">
		///     A pointer to a <see cref="RECT" /> structure that contains the logical coordinates of the rectangle.
		/// </param>
		/// <param name="edge">
		///     <para>
		///         The type of inner and outer edges to draw. This parameter must be a combination of one inner-border flag and one outer-border flag. The
		///         inner-border flags are as follows.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>BDR_RAISEDINNER</term>
		///             <description>Raised inner edge.</description>
		///         </item>
		///         <item>
		///             <term>BDR_SUNKENINNER</term>
		///             <description>Sunken inner edge.</description>
		///         </item>
		///     </list>
		///     <para>The outer-border flags are as follows.</para>
		///     <list type="table">
		///         <item>
		///             <term>BDR_RAISEDOUTER</term>
		///             <description>Raised outer edge.</description>
		///         </item>
		///         <item>
		///             <term>BDR_SUNKENOUTER</term>
		///             <description>Sunken outer edge.</description>
		///         </item>
		///     </list>
		///     <para>
		///         Alternatively, the <paramref name="edge" /> parameter can specify one of the following flags.
		///     </para>
		///     <list type="table">
		///         <item>
		///             <term>EDGE_BUMP</term>
		///             <description>Combination of BDR_RAISEDOUTER and BDR_SUNKENINNER.</description>
		///         </item>
		///         <item>
		///             <term>EDGE_ETCHED</term>
		///             <description>Combination of BDR_SUNKENOUTER and BDR_RAISEDINNER.</description>
		///         </item>
		///         <item>
		///             <term>EDGE_RAISED</term>
		///             <description>Combination of BDR_RAISEDOUTER and BDR_RAISEDINNER.</description>
		///         </item>
		///         <item>
		///             <term>EDGE_SUNKEN</term>
		///             <description>Combination of BDR_SUNKENOUTER and BDR_SUNKENINNER.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <param name="grfFlags">
		///     <para>The type of border. This parameter can be a combination of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>BF_ADJUST</term>
		///             <description>
		///                 <para>
		///                     If this flag is passed, shrink the rectangle pointed to by the <paramref name="qrc" /> parameter to exclude the edges that were
		///                     drawn.
		///                 </para>
		///                 <para>
		///                     If this flag is not passed, then do not change the rectangle pointed to by the <paramref name="qrc" /> parameter.
		///                 </para>
		///             </description>
		///         </item>
		///         <item>
		///             <term>BF_BOTTOM</term>
		///             <description>Bottom of border rectangle.</description>
		///         </item>
		///         <item>
		///             <term>BF_BOTTOMLEFT</term>
		///             <description>Bottom and left side of border rectangle.</description>
		///         </item>
		///         <item>
		///             <term>BF_BOTTOMRIGHT</term>
		///             <description>Bottom and right side of border rectangle.</description>
		///         </item>
		///         <item>
		///             <term>BF_DIAGONAL</term>
		///             <description>Diagonal border.</description>
		///         </item>
		///         <item>
		///             <term>BF_DIAGONAL_ENDBOTTOMLEFT</term>
		///             <description>Diagonal border. The end point is the lower-left corner of the rectangle; the origin is top-right corner.</description>
		///         </item>
		///         <item>
		///             <term>BF_DIAGONAL_ENDBOTTOMRIGHT</term>
		///             <description>Diagonal border. The end point is the lower-right corner of the rectangle; the origin is top-left corner.</description>
		///         </item>
		///         <item>
		///             <term>BF_DIAGONAL_ENDTOPLEFT</term>
		///             <description>Diagonal border. The end point is the top-left corner of the rectangle; the origin is lower-right corner.</description>
		///         </item>
		///         <item>
		///             <term>BF_DIAGONAL_ENDTOPRIGHT</term>
		///             <description>Diagonal border. The end point is the top-right corner of the rectangle; the origin is lower-left corner.</description>
		///         </item>
		///         <item>
		///             <term>BF_FLAT</term>
		///             <description>Flat border.</description>
		///         </item>
		///         <item>
		///             <term>BF_LEFT</term>
		///             <description>Left side of border rectangle.</description>
		///         </item>
		///         <item>
		///             <term>BF_MIDDLE</term>
		///             <description>Interior of rectangle to be filled.</description>
		///         </item>
		///         <item>
		///             <term>BF_MONO</term>
		///             <description>One-dimensional border.</description>
		///         </item>
		///         <item>
		///             <term>BF_RECT</term>
		///             <description>Entire border rectangle.</description>
		///         </item>
		///         <item>
		///             <term>BF_RIGHT</term>
		///             <description>Right side of border rectangle.</description>
		///         </item>
		///         <item>
		///             <term>BF_SOFT</term>
		///             <description>Soft buttons instead of tiles.</description>
		///         </item>
		///         <item>
		///             <term>BF_TOP</term>
		///             <description>Top of border rectangle.</description>
		///         </item>
		///         <item>
		///             <term>BF_TOPLEFT</term>
		///             <description>Top and left side of border rectangle.</description>
		///         </item>
		///         <item>
		///             <term>BF_TOPRIGHT</term>
		///             <description>Top and right side of border rectangle.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "DrawEdge")]
		public static extern bool DrawEdge([In] IntPtr hdc, ref RECT qrc, uint edge, BF grfFlags);

		/// <summary>
		///     The <see cref="CopyRect" /> function copies the coordinates of one rectangle to another.
		/// </summary>
		/// <param name="lprcDst">
		///     Pointer to the <see cref="RECT" /> structure that receives the logical coordinates of the source rectangle.
		/// </param>
		/// <param name="lprcSrc">
		///     Pointer to the <see cref="RECT" /> structure whose coordinates are to be copied in logical units.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all
		///     rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used
		///     determine the units of measure.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "CopyRect")]
		public static extern bool CopyRect([Out] out RECT lprcDst, [In] ref RECT lprcSrc);

		/// <summary>Copies the specified icon from another module to the current module.</summary>
		/// <param name="hIcon">A handle to the icon to be copied.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to the duplicate icon.</para>
		///     <para>If the function fails, the return value is NULL. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="CopyIcon" /> function enables an application or DLL to get its own handle to an icon owned by another module. If the other
		///         module is freed, the application icon will still be able to use the icon.
		///     </para>
		///     <para>
		///         Before closing, an application must call the <see cref="DestroyIcon" /> function to free any system resources associated with the icon.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "CopyIcon")]
		public static extern IntPtr CopyIcon([In] IntPtr hIcon);

		/// <summary>
		///     <para>
		///         Indicates whether an owned, visible, top-level pop-up, or overlapped window exists on the screen. The function searches the entire screen,
		///         not just the calling application's client area.
		///     </para>
		///     <para>This function is provided only for compatibility with 16-bit versions of Windows. It is generally not useful.</para>
		/// </summary>
		/// <returns>
		///     <para>If a pop-up window exists, the return value is nonzero, even if the pop-up window is completely covered by other windows.</para>
		///     <para>If a pop-up window does not exist, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     This function does not detect unowned pop-up windows or windows that do not have the <see cref="WS.WS_VISIBLE" /> style bit set.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "AnyPopup")]
		public static extern bool AnyPopup();

		/// <summary>
		///     <para>
		///         Translates the specified virtual-key code and keyboard state to the corresponding character or characters. The function translates the code
		///         using the input language and physical keyboard layout identified by the keyboard layout handle.
		///     </para>
		///     <para>
		///         To specify a handle to the keyboard layout to use to translate the specified code, use the <see cref="ToAsciiEx" /> function.
		///     </para>
		/// </summary>
		/// <param name="uVirtKey">The virtual-key code to be translated. See Virtual-Key Codes.</param>
		/// <param name="uScanCode">The hardware scan code of the key to be translated. The high-order bit of this value is set if the key is up (not pressed).</param>
		/// <param name="lpKeyState">
		///     <para>
		///         A pointer to a 256-byte array that contains the current keyboard state. Each element (byte) in the array contains the state of one key. If
		///         the high-order bit of a byte is set, the key is down (pressed).
		///     </para>
		///     <para>
		///         The low bit, if set, indicates that the key is toggled on. In this function, only the toggle bit of the CAPS LOCK key is relevant. The toggle
		///         state of the NUM LOCK and SCROLL LOCK keys is ignored.
		///     </para>
		/// </param>
		/// <param name="lpChar">The buffer that receives the translated character or characters.</param>
		/// <param name="uFlags">This parameter must be 1 if a menu is active, or 0 otherwise.</param>
		/// <returns>If the specified key is a dead key, the return value is negative. Otherwise, it is one of the following values.</returns>
		/// <remarks>
		///     <para>
		///         The parameters supplied to the <see cref="ToAscii" /> function might not be sufficient to translate the virtual-key code, because a previous
		///         dead key is stored in the keyboard layout.
		///     </para>
		///     <para>
		///         Typically, <see cref="ToAscii" /> performs the translation based on the virtual-key code. In some cases, however, bit 15 of the
		///         <paramref name="uScanCode" /> parameter may be used to distinguish between a key press and a key release. The scan code is used for
		///         translating ALT+ number key combinations.
		///     </para>
		///     <para>
		///         Although NUM LOCK is a toggle key that affects keyboard behavior, <see cref="ToAscii" /> ignores the toggle setting (the low bit) of
		///         <paramref name="lpKeyState" /> (<see cref="VK.VK_NUMLOCK" />) because the <paramref name="uVirtKey" /> parameter alone is sufficient to
		///         distinguish the cursor movement keys (<see cref="VK.VK_HOME" />, <see cref="VK.VK_INSERT" />, and so on) from the numeric keys (
		///         <see cref="VK.VK_DECIMAL" />, <see cref="VK.VK_NUMPAD0" /> - <see cref="VK.VK_NUMPAD9" />).
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "ToAscii")]
		public static extern int ToAscii(uint uVirtKey, uint uScanCode, [In] IntPtr lpKeyState, [Out] out ushort lpChar, TA uFlags);

		/// <summary>
		///     The <see cref="SetRect" /> function sets the coordinates of the specified rectangle. This is equivalent to assigning the left, top, right, and
		///     bottom arguments to the appropriate members of the <see cref="RECT" /> structure.
		/// </summary>
		/// <param name="lprc">
		///     Pointer to the <see cref="RECT" /> structure that contains the rectangle to be set.
		/// </param>
		/// <param name="xLeft">Specifies the x-coordinate of the rectangle's upper-left corner.</param>
		/// <param name="yTop">Specifies the y-coordinate of the rectangle's upper-left corner.</param>
		/// <param name="xRight">Specifies the x-coordinate of the rectangle's lower-right corner.</param>
		/// <param name="yBottom">Specifies the y-coordinate of the rectangle's lower-right corner.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero.</para>
		/// </returns>
		/// <remarks>
		///     Because applications can use rectangles for different purposes, the rectangle functions do not use an explicit unit of measure. Instead, all
		///     rectangle coordinates and dimensions are given in signed, logical values. The mapping mode and the function in which the rectangle is used
		///     determine the units of measure.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetRect")]
		public static extern bool SetRect([Out] out RECT lprc, int xLeft, int yTop, int xRight, int yBottom);

		/// <summary>Assigns a new menu to the specified window.</summary>
		/// <param name="hWnd">A handle to the window to which the menu is to be assigned.</param>
		/// <param name="hMenu">A handle to the new menu. If this parameter is NULL, the window's current menu is removed.</param>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     <para>The window is redrawn to reflect the menu change. A menu can be assigned to any window that is not a child window.</para>
		///     <para>
		///         The <see cref="SetMenu" /> function replaces the previous menu, if any, but it does not destroy it. An application should call the
		///         <see cref="DestroyMenu" /> function to accomplish this task.
		///     </para>
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "SetMenu")]
		public static extern bool SetMenu([In] IntPtr hWnd, [In] IntPtr hMenu);

		/// <summary>
		///     Determines whether a window is a child window or descendant window of a specified parent window. A child window is the direct descendant of a
		///     specified parent window if that parent window is in the chain of parent windows; the chain of parent windows leads from the original overlapped
		///     or pop-up window to the child window.
		/// </summary>
		/// <param name="hWndParent">A handle to the parent window.</param>
		/// <param name="hWnd">A handle to the window to be tested.</param>
		/// <returns>
		///     <para>If the window is a child or descendant window of the specified parent window, the return value is nonzero.</para>
		///     <para>If the window is not a child or descendant window of the specified parent window, the return value is zero.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "IsChild")]
		public static extern bool IsChild([In] IntPtr hWndParent, [In] IntPtr hWnd);

		/// <summary>Retrieves a handle to the menu assigned to the specified window.</summary>
		/// <param name="hWnd">A handle to the window whose menu handle is to be retrieved.</param>
		/// <returns>
		///     The return value is a handle to the menu. If the specified window has no menu, the return value is NULL. If the window is a child window, the
		///     return value is undefined.
		/// </returns>
		/// <remarks>
		///     <see cref="GetMenu" /> does not work on floating menu bars. Floating menu bars are custom controls that mimic standard menus; they are not menus.
		///     To get the handle on a floating menu bar, use the Active Accessibility APIs.
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetMenu")]
		public static extern IntPtr GetMenu([In] IntPtr hWnd);

		/// <summary>
		///     <para>
		///         The <see cref="GetDCEx" /> function retrieves a handle to a device context (DC) for the client area of a specified window or for the entire
		///         screen. You can use the returned handle in subsequent GDI functions to draw in the DC. The device context is an opaque data structure, whose
		///         values are used internally by GDI.
		///     </para>
		///     <para>
		///         This function is an extension to the <see cref="GetDC" /> function, which gives an application more control over how and whether clipping
		///         occurs in the client area.
		///     </para>
		/// </summary>
		/// <param name="hWnd">
		///     A handle to the window whose DC is to be retrieved. If this value is NULL, <see cref="GetDCEx" /> retrieves the DC for the entire screen.
		/// </param>
		/// <param name="hrgnClip">
		///     A clipping region that may be combined with the visible region of the DC. If the value of <paramref name="flags" /> is DCX_INTERSECTRGN or
		///     DCX_EXCLUDERGN, then the operating system assumes ownership of the region and will automatically delete it when it is no longer needed. In this
		///     case, the application should not use or delete the region after a successful call to <see cref="GetDCEx" />.
		/// </param>
		/// <param name="flags">
		///     <para>Specifies how the DC is created. This parameter can be one or more of the following values.</para>
		///     <list type="table">
		///         <item>
		///             <term>DCX_WINDOW</term>
		///             <description>Returns a DC that corresponds to the window rectangle rather than the client rectangle.</description>
		///         </item>
		///         <item>
		///             <term>DCX_CACHE</term>
		///             <description>Returns a DC from the cache, rather than the OWNDC or CLASSDC window. Essentially overrides CS_OWNDC and CS_CLASSDC.</description>
		///         </item>
		///         <item>
		///             <term>DCX_PARENTCLIP</term>
		///             <description>
		///                 Uses the visible region of the parent window. The parent's WS_CLIPCHILDREN and CS_PARENTDC style bits are ignored. The origin is set
		///                 to the upper-left corner of the window identified by <paramref name="hWnd" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DCX_CLIPSIBLINGS</term>
		///             <description>
		///                 Excludes the visible regions of all sibling windows above the window identified by <paramref name="hWnd" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DCX_CLIPCHILDREN</term>
		///             <description>
		///                 Excludes the visible regions of all child windows below the window identified by <paramref name="hWnd" />.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DCX_NORESETATTRS</term>
		///             <description>Does not reset the attributes of this DC to the default attributes when this DC is released.</description>
		///         </item>
		///         <item>
		///             <term>DCX_LOCKWINDOWUPDATE</term>
		///             <description>
		///                 Allows drawing even if there is a <see cref="LockWindowUpdate" /> call in effect that would otherwise exclude this window. Used for
		///                 drawing during tracking.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DCX_EXCLUDERGN</term>
		///             <description>
		///                 The clipping region identified by <paramref name="hrgnClip" /> is excluded from the visible region of the returned DC.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DCX_INTERSECTRGN</term>
		///             <description>
		///                 The clipping region identified by <paramref name="hrgnClip" /> is intersected with the visible region of the returned DC.
		///             </description>
		///         </item>
		///         <item>
		///             <term>DCX_INTERSECTUPDATE</term>
		///             <description>Reserved; do not use.</description>
		///         </item>
		///         <item>
		///             <term>DCX_VALIDATE</term>
		///             <description>Reserved; do not use.</description>
		///         </item>
		///     </list>
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is the handle to the DC for the specified window.</para>
		///     <para>
		///         If the function fails, the return value is NULL. An invalid value for the <paramref name="hWnd" /> parameter will cause the function to fail.
		///     </para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         Unless the display DC belongs to a window class, the <see cref="ReleaseDC" /> function must be called to release the DC after painting. Also,
		///         <see cref="ReleaseDC" /> must be called from the same thread that called <see cref="GetDCEx" />. The number of DCs is limited only by
		///         available memory.
		///     </para>
		///     <para>
		///         The function returns a handle to a DC that belongs to the window's class if CS_CLASSDC, CS_OWNDC or CS_PARENTDC was specified as a style in
		///         the <see cref="WNDCLASS" /> structure when the class was registered.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetDCEx")]
		public static extern IntPtr GetDCEx([In] IntPtr hWnd, [In] IntPtr hrgnClip, DCX flags);

		/// <summary>Ends the calling thread's active menu.</summary>
		/// <returns>
		///     <para>If the function succeeds, the return value is nonzero.</para>
		///     <para>If the function fails, the return value is zero. To get extended error information, call GetLastError.</para>
		/// </returns>
		/// <remarks>
		///     If a platform does not support <see cref="EndMenu" />, send the owner of the active menu a <see cref="WM.WM_CANCELMODE" /> message.
		/// </remarks>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "EndMenu")]
		public static extern bool EndMenu();

		/// <summary>Determines whether a handle is a menu handle.</summary>
		/// <param name="hMenu">A handle to be tested.</param>
		/// <returns>
		///     <para>If the handle is a menu handle, the return value is nonzero.</para>
		///     <para>If the handle is not a menu handle, the return value is zero.</para>
		/// </returns>
		[return: MarshalAs(UnmanagedType.Bool)]
		[DllImport("user32.dll", EntryPoint = "IsMenu")]
		public static extern bool IsMenu([In] IntPtr hMenu);

		/// <summary>
		///     <para>
		///         The <see cref="GetDC" /> function retrieves a handle to a device context (DC) for the client area of a specified window or for the entire
		///         screen. You can use the returned handle in subsequent GDI functions to draw in the DC. The device context is an opaque data structure, whose
		///         values are used internally by GDI.
		///     </para>
		///     <para>
		///         The <see cref="GetDCEx" /> function is an extension to <see cref="GetDC" />, which gives an application more control over how and whether
		///         clipping occurs in the client area.
		///     </para>
		/// </summary>
		/// <param name="hWnd">
		///     A handle to the window whose DC is to be retrieved. If this value is NULL, <see cref="GetDC" /> retrieves the DC for the entire screen.
		/// </param>
		/// <returns>
		///     <para>If the function succeeds, the return value is a handle to the DC for the specified window's client area.</para>
		///     <para>If the function fails, the return value is NULL.</para>
		/// </returns>
		/// <remarks>
		///     <para>
		///         The <see cref="GetDC" /> function retrieves a common, class, or private DC depending on the class style of the specified window. For class
		///         and private DCs, <see cref="GetDC" /> leaves the previously assigned attributes unchanged. However, for common DCs, <see cref="GetDC" />
		///         assigns default attributes to the DC each time it is retrieved. For example, the default font is System, which is a bitmap font. Because of
		///         this, the handle to a common DC returned by <see cref="GetDC" /> does not tell you what font, color, or brush was used when the window was
		///         drawn. To determine the font, call GetTextFace.
		///     </para>
		///     <para>Note that the handle to the DC can only be used by a single thread at any one time.</para>
		///     <para>
		///         After painting with a common DC, the <see cref="ReleaseDC" /> function must be called to release the DC. Class and private DCs do not have to
		///         be released. <see cref="ReleaseDC" /> must be called from the same thread that called <see cref="GetDC" />. The number of DCs is limited only
		///         by available memory.
		///     </para>
		/// </remarks>
		[DllImport("user32.dll", EntryPoint = "GetDC")]
		public static extern IntPtr GetDC([In] IntPtr hWnd);
	}

	// ReSharper restore InconsistentNaming
}